---
title: "2025-topic-03-group-02-code"
output: html_document
date: "2025-05-16"
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Group X Data Analysis Project 

# Project Overview
### Goal: 
- *Identification of RNA-Dependent Proteins*
Build a robust analysis pipeline to identify proteins with altered distribution profiles after RNase treatment, using mass spectrometry data from 7,159 proteins isolated from synchronized mitotic HeLa cells.

- *Identification of RBPs specifically active during mitosis*
Compare RNA-dependent protein profiles from synchronized mitotic cells with those from unsynchronized cells to find RBPs that are exclusively active during mitosis.

- *Screening for RBP complexes active in Mitosis*
Investigate whether mitosis-specific RBPs co-segregate in control gradients aiming to detect both known and potentially novel RNA-dependent protein complexes (using different clustering methods).

- *Testing R-DeeP for further use in molecular weight predictions*
Test if a protein's position in the sucrose gradient correlates with its molecular weight, using linear regression to evaluate predictive potential.

## Libraries 
```{r, message=FALSE, warning=FALSE}
# General
library(tidyverse) # Collection of tidy data tools (ggplot2, dplyr, tidyr, etc.) for wrangling, plotting, and transforming datasets
library(tidyr)# Provides functions for transforming and reshaping data structures â€” used for pivot_wider to convert long-format correlation data into a wide matrix for heatmap input
library(pheatmap)# Generates customizable heatmaps; used to visualize the Spearman correlation matrix between all replicate-fraction combinations
library(glue) # Easy string construction with embedded variables and functions
library(ggplot2) # Various plots (elegant, versatile and easy to use)
library(dplyr) # For conditional logic with case_when inside plot aesthetics, also for filtering and selecting relevant data 

# Clustering
library(dbscan) # Necessary for scaling in order to later run density based clustering

# Chunk Additional Data 
library(httr) # Making API requests to UniProt (GET requests and response handling)
library(jsonlite) # Parsing JSON responses from the UniProt API 
library(pbapply) # Applying functions with a progress bar
library(data.table) # Fast loading of large tables (CORUM) and simple grouping / restructuring of data using [i, j, by] syntax

```

# Loading MS-Data
```{r}
MS_Table <- read.table("RDeeP_HeLa_Mitosis.csv", header = TRUE, row.names = 1, sep = ";")
```

# Data Cleanup
## Description of the Data - Lina
### Goal: 
- Get a feeling for the dataset and decide on necessary clean-up steps
```{r}
glue("Number of proteins analysed /rows : {nrow(MS_Table)}")
glue("Number of columns: {ncol(MS_Table)} (25 fractions with each 3 replicates for Ctrl and RNase treatment)")
glue("Classification of variables: {unique(sapply(MS_Table, class))}")
glue("Any missing values: {any(is.na(MS_Table))}")
glue("Overall minimum intensity: {min(MS_Table)}")
glue("Overall maximum intensity: {max(MS_Table)}")
```

# Normalization - Cihan, Sofia,Lina
### Goal: 

- Generate a new dataframe with replicate-averaged intensity values,scaled so that each protein's total intensity sums to 100 across all fractions (for Ctrl and RNase)
- Build a function to plot protein profiles using the normalized data
- Confirm experimental reproducibility by comparing intensity profiles across replicates

## Normalization of triplicates - Lina
```{r}
# Create a metadata dataframe with factor columns that map each MS_Table column to its experimental treatment, replicate, and fraction number
treatment <- factor(rep(c("Ctrl", "RNase"), each = 3, length.out = 150))
replicate <- factor(rep(c("Ctrl_Rep1", "Ctrl_Rep2", "Ctrl_Rep3", "RNase_Rep1","RNase_Rep2", "RNase_Rep3"),25))
fraction <- factor(rep(paste0("Fraction_", 1:25), each = 6))

data <- data.frame(rownames = colnames(MS_Table),treatment = treatment, replicate = replicate, fraction = fraction)

# Iterate over all fraction levels: for each fraction, select replicate columns of Ctrl and RNase, compute row-wise means and store them in previously created list
average.list <- list()

for (f in levels(fraction)) {
  
  cols.Ctrl <- which(fraction == f & treatment == "Ctrl") 
  average.Ctrl <- rowMeans(MS_Table[,cols.Ctrl]) 
  average.list[[paste0("Ctrl_",f)]] <- average.Ctrl 
  
  cols.RNase <- which(fraction == f & treatment == "RNase")
  average.RNase <- rowMeans(MS_Table[,cols.RNase])
  average.list[[paste0("RNase_",f)]] <- average.RNase
}

# Convert the list of averages to a data frame and restore rownames
MS_Table_Averages <- as.data.frame(average.list) 
rownames(MS_Table_Averages) <- rownames(MS_Table) 

# Reorder columns: alphabetic order of 'levels()' disrupts correct fraction sequence,so construct correct order manually (Ctrl_1 to Ctrl_25, then RNase_1 to RNase_25)
fractions <- paste0("Fraction_", 1:25)
ordered_names <- as.vector(rbind(
  paste0("Ctrl_", fractions),
  paste0("RNase_", fractions)
))

MS_Table_Averages <- MS_Table_Averages[, ordered_names]
```

## Plot showing variance of our data - Sofia
```{r}
library(dplyr)
# -------------- PART 1: Plot for standard deviation for all 7159 proteins from MS_Table_Averages for each fraction for the CTRL condition ----------



# 1. Select Ctrl columns using grep
ctrl_cols <- grep("^Ctrl_Fraction_", colnames(MS_Table_Averages), value = TRUE)

# 2. Randomly pick 25 proteins (rows)
set.seed(123)
selected <- sample(rownames(MS_Table_Averages), 25)
data <- MS_Table_Averages[selected, ctrl_cols]

# 3. Calculate mean and SE per protein (row-wise)
mean_vals <- apply(data, 1, mean, na.rm = TRUE)
se_vals <- apply(data, 1, function(x) sd(x, na.rm = TRUE) / sqrt(length(na.omit(x))))

# 4. Identify outliers for each protein
outliers <- lapply(1:nrow(data), function(i) {
  vals <- as.numeric(data[i, ])
  q1 <- quantile(vals, 0.25, na.rm = TRUE)
  q3 <- quantile(vals, 0.75, na.rm = TRUE)
  iqr <- q3 - q1
  out_idx <- which(vals < (q1 - 1.5 * iqr) | vals > (q3 + 1.5 * iqr))
  if (length(out_idx) > 0) {
    data.frame(Protein = rownames(data)[i],
               Intensity = vals[out_idx])
  }
})
outlier_df <- do.call(rbind, outliers)

# 5. Create summary dataframe
summary_df <- data.frame(
  Protein = rownames(data),
  Mean = mean_vals,
  SE = se_vals
)

# 6. Plot (no log scale)
ggplot(summary_df, aes(x = Protein, y = Mean)) +
  geom_bar(stat = "identity", fill = "gray70") +
  geom_errorbar(aes(ymin = Mean - SE, ymax = Mean + SE), width = 0.3) +
  geom_point(data = outlier_df, aes(x = Protein, y = Intensity),
             color = "darkred", size = 2, position = position_jitter(width = 0.2)) +
  labs(title = "Mean Intensity per Protein",
       y = "Mean Intensity", x = "") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

## Normalization to 100 - Cihan
### Goal: 

- Create a new dataframe in which the values for each protein are scaled so that the distribution within the Ctrl and RNase conditions each sums to 100
- For less variance between the fractions --> This allows comparison of distribution independent of absolute abundance
```{r}
# Split up Control and RNAse values 
ctrl_cols <- grep("^Ctrl_", colnames(MS_Table_Averages))  
rnase_cols <- grep("^RNase_", colnames(MS_Table_Averages))

# Normalization of each group to 100 
ctrl_norm <- MS_Table_Averages[, ctrl_cols] / rowSums(MS_Table_Averages[, ctrl_cols]) * 100
rnase_norm <- MS_Table_Averages[, rnase_cols] / rowSums(MS_Table_Averages[, rnase_cols]) * 100

# Combine in one table 
MS_Table_Norm <- cbind(ctrl_norm, rnase_norm)
MS_Table_Norm <- MS_Table_Norm[, colnames(MS_Table_Averages)]

# Verify the calculation with one example; the row sum should be ~200 (Ctrl 100% + RNAse 100%)
rowSums(MS_Table_Norm["1433B_HUMAN", ]) 
```

## Plotting a Protein - Lina
### Goal: 
- Build a function to plot normalized intensity values of Ctrl and RNase across all fractions
```{r}
plot_protein <- function(x) {
  
  # Extract data, define all variables and range of x- and y-axis
  protein_of_interest <- x 
  protein_row <- MS_Table_Norm[rownames(MS_Table_Norm) == protein_of_interest, ]
  ctrl_values <- as.numeric(protein_row[seq(1, 49, by=2)])
  rnase_values <- as.numeric(protein_row[seq(2, 50, by=2)])
  fractions <- 1:25
  max_val <- max(ctrl_values, rnase_values, na.rm = TRUE)
  ylim_range <- c(0, max_val * 1.2)

  # Core plot function using crtl_values
  plot(fractions, ctrl_values, type="o", pch=20, lty=1, lwd = 1.5,  col="forestgreen", ylim= ylim_range,
       xlab="Fraction", ylab="Normalized Intensity", main= protein_of_interest, axes = FALSE)
       
  # Add line for rnase_values
  lines(fractions, rnase_values, type="o",pch =20, lty=1, lwd = 1.5,  col="firebrick3")
  
  # Color area under the curve
  polygon(c(fractions, rev(fractions)), 
          c(ctrl_values, rep(0, length(ctrl_values))), 
          col=adjustcolor("forestgreen", alpha.f=0.1), border=NA)
  
  polygon(c(fractions, rev(fractions)), 
          c(rnase_values, rep(0, length(rnase_values))), 
          col=adjustcolor("firebrick3", alpha.f=0.1), border=NA)
  
  # Add x- and y-axis with correct labels
  axis(1, at = 1:25, labels = 1:25, cex.axis = 0.7)
  axis(2, cex.axis = 0.7, las =2)
  grid(nx = NULL, ny = NULL, col = "lightgray", lty = "dotted", lwd = 0.8)

  # Add legend
  legend("topright", legend=c("Ctrl", "RNase"), col=c("forestgreen", "firebrick3"), 
         lty=1, lwd = 1.5,  pch=20, bg = "white", bty = "o", box.col = NA, horiz = TRUE)
}

# Example
plot_protein("RS6_HUMAN") 
```


## Reproducibility Analysis - Cihan, Sofia 
### Goal: 

- Assess reproducibility of MS-based protein measurements for both treatments 
- Visualize how consistent protein ranking patterns are across all replicates and fractions
- We expect a diagonal showing our r = 1, while the other combinations should show lower correlation
```{r}
# Create empty dataframe for correlation 
full_correlation_results <- data.frame(
  Treatment = character(),
  Replicate_1 = character(),
  Fraction_1 = character(),
  Replicate_2 = character(),
  Fraction_2 = character(),
  Spearman_r = numeric(),
  stringsAsFactors = FALSE
)

# Iterate over both Ctrl and RNase treatments 
for (treatment in c("Ctrl", "RNase")) {
  
  # Create all possible rep-fraction combinations
  combo1 <- expand.grid(Rep = 1:3, Fraction = 1:25)
  combo2 <- expand.grid(Rep = 1:3, Fraction = 1:25)
  
  # Iterate for every possible combination
  for (i in 1:nrow(combo1)) {
    for (j in 1:nrow(combo2)) {
      
      rep1 <- combo1$Rep[i]
      frac1 <- combo1$Fraction[i]
      rep2 <- combo2$Rep[j]
      frac2 <- combo2$Fraction[j]
      
      # Find right column position 
      col1 <- which(replicate == paste0(treatment, "_Rep", rep1) & fraction == paste0("Fraction_", frac1))
      col2 <- which(replicate == paste0(treatment, "_Rep", rep2) & fraction == paste0("Fraction_", frac2))
      
      # Calculate Spearman correlation
      cor_value <- cor(MS_Table[, col1], MS_Table[, col2], method = "spearman", use = "complete.obs")
      
      # Save results in dataframe
      full_correlation_results <- rbind(full_correlation_results, data.frame(
        Treatment = treatment,
        Replicate_1 = paste0("Rep", rep1),
        Fraction_1 = paste0("Fraction_", frac1),
        Replicate_2 = paste0("Rep", rep2),
        Fraction_2 = paste0("Fraction_", frac2),
        Spearman_r = cor_value
      ))
    }
  }
}


head(full_correlation_results)



# Create column for each axis 
full_correlation_results <- full_correlation_results %>%
   mutate(Row = paste0(Replicate_1, "_F", gsub("Fraction_", "", Fraction_1)),
         Col = paste0(Replicate_2, "_F", gsub("Fraction_", "", Fraction_2)))

# We select treatment RNase for our first heatmap
treatment_to_plot_RNase <- "RNase"

# Filter table for selected treatment: RNase
heatmap_data_RNase <- full_correlation_results %>%
  filter(Treatment == treatment_to_plot_RNase) %>%
  select(Row, Col, Spearman_r)

# Convert into matrix 
heatmap_matrix_RNase <- heatmap_data_RNase %>%
  pivot_wider(names_from = Col, values_from = Spearman_r, values_fill = NA) %>%
  column_to_rownames("Row") %>%
  as.matrix()

# Create heatmap for RNase treatment
print(pheatmap(heatmap_matrix_RNase,
         main = paste("Spearman Correlation Heatmap -", treatment_to_plot_RNase),
         cluster_rows = FALSE, 
         cluster_cols = FALSE, 
         show_rownames = TRUE, 
         show_colnames = TRUE,
         fontsize_row = 4,
         fontsize_col = 4))

# We select treatment Ctrl for our second heatmap
treatment_to_plot_Ctrl <- "Ctrl"

# Filter table for selected treatment: Ctrl
heatmap_data_Ctrl <- full_correlation_results %>%
  filter(Treatment == treatment_to_plot_Ctrl) %>%
  select(Row, Col, Spearman_r)

# Convert into matrix 
heatmap_matrix_Ctrl <- heatmap_data_Ctrl %>%
  pivot_wider(names_from = Col, values_from = Spearman_r, values_fill = NA) %>%
  column_to_rownames("Row") %>%
  as.matrix()

# Create heatmap for Ctrl treatment
print(pheatmap(heatmap_matrix_Ctrl,
         main = paste("Spearman Correlation Heatmap -", treatment_to_plot_Ctrl),
         cluster_rows = FALSE, 
         cluster_cols = FALSE, 
         show_rownames = TRUE, 
         show_colnames = TRUE,
         fontsize_row = 4,
         fontsize_col = 4))

```

# Data Analysis
### Goal:
- Identification of RNA-Dependent Proteins
- Identification of RBPs specifically active during mitosis

## Peak Detection in normalized Ctrl and RNase profiles  - Lina
### Goal:
- Identify peaks in normalized intensity profiles (Ctrl and RNase)
- Extract number of peaks, their positions and heights

**NOTE:** Peak data is not used for RBP identification. This step is purely descriptive. However, Peak_Data is later used for clustering and linear regression analysis.
```{r}
# Define x axis
x <- 1:25

# Build function for peak detection using slope between fractions
# Detects internal peaks above a given threshold (default: 3% of max intensity)
# Note: Cannot detect peaks at positions 1 and 25 (manually handled below)
find_peaks <- function(y, threshold = max(y) * 0.03) { 
  peaks <- which(diff(sign(diff(y))) == -2) + 1 # (+1 shifts index forward)
  peaks[y[peaks]>= threshold] 
}

# Initialize list to collect results per protein and iterate over all proteins (rows in MS_Table_Norm)
peak_results <- list()

for (p in seq_len(nrow(MS_Table_Norm))) {
  
  # Extract normalized values for Ctrl and RNase
  row_vals <- as.numeric(MS_Table_Norm [p,])
  ctrl_vals <- row_vals[seq(1, 50, by =2)]
  rnase_vals <- row_vals[seq(2, 50, by=2)]
  
  results_row <- list()
  
  # Process both conditions in one loop
  for (cond in c("Ctrl", "RNase")) {
    y <- if (cond == "Ctrl") ctrl_vals else rnase_vals
    threshold <- max(y, na.rm = TRUE) * 0.03
    
    peaks <- find_peaks(y)
    
    # Manually check for peaks at positions 1 and 25
    if (length(peaks) == 0) {
      peaks <- numeric(0)
      }
    if (!is.na(y[1]) && !is.na(y[2]) && y[1] > y[2] && y[1] >= threshold) {
      peaks <- c(1, peaks)
      }
    if (!is.na(y[25]) && !is.na(y[24]) && y[25] > y[24] && y[25] >= threshold) {
      peaks <- c(peaks, 25)
    }
    # Fallback: If no peaks are detected at all, use global maximum
    if(length(peaks) == 0) {
      peaks <- which.max(y)
      }
    
    # Limit number of stored peaks to max. 6
    n_peaks <- min(length(peaks), 6)
    
    # Extract peak height and peak position
    y_peaks <- y[peaks]
    x_peaks <- x[peaks]

    # Store data for current protein (Number of peaks, peak heights and peak positions)
    results_row[[paste0("n_peaks_", cond)]] <- n_peaks
    
    for(n in seq_len(n_peaks)) {
    results_row[[paste0("peak", n, "_height_", cond)]] <- y_peaks[n]
    results_row[[paste0("peak", n, "_position_", cond)]] <- x_peaks[n]
    }
  }
  # Store result for current protein
  peak_results[[p]] <- results_row
}

# Fill missing values with NAs to allow binding all rows together
rows_df <- lapply(peak_results, function(x){
  columns <- c("peak1_height", "peak1_position", 
               "peak2_height", "peak2_position", 
               "peak3_height", "peak3_position", 
               "peak4_height", "peak4_position", 
               "peak5_height", "peak5_position", 
               "peak6_height", "peak6_position")
  for (cond in c("Ctrl", "RNase")) {
    for (c in columns) {
      key <- paste0(c, "_", cond)
      if(!(key %in% names(x))) {
        x[[key]] <- NA
      }
    }
  }
  as.data.frame(x)
})

# Combine all protein results into one data frame 
Peak_Data <- do.call(rbind, rows_df) #do.call bind used because rows_df is a list of dataframes
rownames(Peak_Data) <- rownames(MS_Table_Norm)

# Reorder columns: first n_peaks, then all peak heights and positions (Ctrl & RNase)
order <- c("n_peaks_Ctrl", "n_peaks_RNase")

for (i in 1:6) {
  order <- c(order, 
                 paste0("peak", i, "_height_Ctrl"),
                 paste0("peak", i, "_position_Ctrl"),
                 paste0("peak", i, "_height_RNase"),
                 paste0("peak", i, "_position_RNase"))
}

Peak_Data <- Peak_Data[, order]
```


# Shift Characteristics - Lina, Sofia, Cihan

### Goal:

- Quantify and summarize positional shifts in protein distribution between Ctrl and RNase conditions using center of mass (CoM) calculation as a weighted average 
- Further shift characterization with:

  Shift distance: difference between CoM_Ctrl and CoM_RNase
  
  Shift direction: +1 = left-shift, â€“1 = right-shift, 0 = no shift

**NOTE:** CoM-based shift calculations is later repeated per replicate and used for statistical testing (t-test) to identify significantly shifting RBPs.
```{r}
# Initialize result vectors (one value per protein)
CoM_Ctrl <- numeric(nrow(MS_Table_Norm))
CoM_RNase <- numeric(nrow(MS_Table_Norm))
shift_distance <- numeric(nrow(MS_Table_Norm))
shift_direction <- numeric(nrow(MS_Table_Norm))

# Iterate over all proteins and calculate shift using center of mass
for (p in seq_len(nrow(MS_Table_Norm))) {
  
   # Extract normalized intensities for Ctrl and RNase
  row_vals <- as.numeric(MS_Table_Norm [p,])
  ctrl_vals <- row_vals[seq(1, 50, by =2)]
  rnase_vals <- row_vals[seq(2, 50, by=2)]
  
  # Calculate Center of Mass for both conditions
  CoM_Ctrl[p] <- sum(ctrl_vals * x) / sum(ctrl_vals)
  CoM_RNase[p] <- sum(rnase_vals * x) / sum(rnase_vals)
  
  # Compute shift distance and direction
  shift_distance[p] <- CoM_Ctrl[p] - CoM_RNase[p] 
  shift_direction[p] <- sign(shift_distance[p]) 
}

# Store results into a single dataframe
Shift_Data <- data.frame(
  CoM_Ctrl = CoM_Ctrl,
  CoM_RNase = CoM_RNase,
  shift_distance = shift_distance,
  shift_direction = shift_direction,
  row.names = rownames(MS_Table_Norm))
```

## T-Test
### 1. Normalization of whole MS_Table to 100 - Cihan

```{r}
# Split up all Ctrl and RNAse values and their individual Reps 
ctrl_cols_t1 <- grep("_Ctrl_Rep1", colnames(MS_Table))
ctrl_cols_t2 <- grep("_Ctrl_Rep2", colnames(MS_Table))
ctrl_cols_t3 <- grep("_Ctrl_Rep3", colnames(MS_Table))
RNase_cols_t1 <- grep("_RNase_Rep1", colnames(MS_Table))
RNase_cols_t2 <- grep("_RNase_Rep2", colnames(MS_Table))
RNase_cols_t3 <- grep("_RNase_Rep3", colnames(MS_Table))

# Normalization of each group to 100 
ctrl_norm_t1 <- MS_Table[, ctrl_cols_t1] / rowSums(MS_Table[, ctrl_cols_t1]) * 100
ctrl_norm_t2 <- MS_Table[, ctrl_cols_t2] / rowSums(MS_Table[, ctrl_cols_t2]) * 100
ctrl_norm_t3 <- MS_Table[, ctrl_cols_t3] / rowSums(MS_Table[, ctrl_cols_t3]) * 100
RNase_norm_t1 <- MS_Table[, RNase_cols_t1] / rowSums(MS_Table[, RNase_cols_t1]) * 100
RNase_norm_t2 <- MS_Table[, RNase_cols_t2] / rowSums(MS_Table[, RNase_cols_t2]) * 100
RNase_norm_t3 <- MS_Table[, RNase_cols_t3] / rowSums(MS_Table[, RNase_cols_t3]) * 100

# Combine in one table 
Norm_Data_for_t <- cbind(ctrl_norm_t1, RNase_norm_t1, ctrl_norm_t2, RNase_norm_t2, ctrl_norm_t3, RNase_norm_t3)

# In gewÃ¼nschter Reihenfolge ordnen
fractions <- 1:25
reps <- 1:3
conditions <- c("Ctrl", "RNase") 


ordered_names <- c()

for (fraction in fractions) {
  for (rep in reps) {
    for (condition in conditions) {
      name <- paste0("Fraction", fraction, "_", condition, "_Rep", rep)
      ordered_names <- c(ordered_names, name)
    }
  }
}

Norm_Data_for_t <- Norm_Data_for_t[, ordered_names]

# Verify the calculation with one example; the row sum should be ~600 (3*Ctrl 100% + 3*RNAse 100%)
rowSums(Norm_Data_for_t["1433B_HUMAN", ]) 
```

### 2. Calculation of Center of mass (CoM) - Sofia 

```{r}
# Setup
fractions <- 1:25
conditions <- c("Ctrl", "RNase")
replicates <- c("Rep1", "Rep2", "Rep3")

results_com <- list()

# Loop through conditions and replicates ( runs 6 times for all combinations)
for (cond in conditions) {
  for (rep in replicates) {
    
    # Single regex pattern to match all 25 fraction columns for this condition & replicate
    pattern <- paste0("^Fraction[0-9]+_", cond, "_", rep, "$") # defines a pattern 
    cols <- grep(pattern, colnames(Norm_Data_for_t), value = TRUE) # chooses pattern from colums (matching)

    # Subset and sort by fraction number
    subdata <- Norm_Data_for_t[, cols] # chooses all columns 
    subdata <- subdata[, order(as.numeric(gsub("Fraction(\\d+)_.*", "\\1", cols)))] # putting into the right order as Com assumes coloum 1 = fraction 1 

    # Center of mass calculation
    com <- apply(subdata, 1, function(x) sum(x * fractions) / sum(x)) # function (across rows)

    # Store result
    results_com[[paste(cond, rep, sep = "_")]] <- com # adds result from com to each cond/ rep, separates with _ 
  }
}

# Convert list to data frame
CoM_Data_for_t <- as.data.frame(results_com) 

rownames(CoM_Data_for_t) <- rownames(Norm_Data_for_t) # apply rownames from df to new df 

```

### 3. Calculating Shift-Values for T-Test - Lina

```{r}
# For each protein, subtract the RNase CoM from the corresponding Ctrl CoM across all three replicates to obtain replicate-wise shift distances.
# Columns 1â€“3 = Ctrl_Rep1â€“3, Columns 4â€“6 = RNase_Rep1â€“3 (in CoM_Data_for_t)
Shift_Data_for_t <- data.frame(
  shift_distance_rep1 = CoM_Data_for_t[, 1] - CoM_Data_for_t[, 4],
  shift_distance_rep2 = CoM_Data_for_t[, 2] - CoM_Data_for_t[, 5],
  shift_distance_rep3 = CoM_Data_for_t[, 3] - CoM_Data_for_t[, 6],
  row.names = rownames(CoM_Data_for_t)
)

# Count how many missing values (NA) are present across all shift distances. (proteins where CoM could not be calculated in at least one replicate)
sum(is.na(Shift_Data_for_t))
```

### 4. T-Test - Cihan
#### Goal: 

- Statistically test whether proteins show a significant left-shift in their center of mass (CoM) distribution in RNase vs. Ctrl, indicating RNA-dependent localization.
- This is done by:
  1. Applying the Shapiro-Wilk test to firstly ensure, that shift values of the replicates are normally distributed before running the t-test.
  2. Testing if the shift distance is significantly greater than 1 using a one-sided t-test.
- Significant hits are categorized as RBPs.
```{r}
# Create empty columns for statistical test results 
Shift_Data$shapiro_p <- NA
Shift_Data$normal_distributed <- NA
Shift_Data$p_value_ttest_filtered <- NA
Shift_Data$significant_ttest_filtered <- NA

# Iterate over all proteins 
for (protein in rownames(Shift_Data_for_t)) {
  
  # Extract shift distances for each replicate
  shift_values <- as.numeric(Shift_Data_for_t[protein, c("shift_distance_rep1", "shift_distance_rep2", "shift_distance_rep3")])
  
  # Make sure that no NAs are present
  if (all(!is.na(shift_values))) {
    
    # Check if all values are identical (no variance)
    if (length(unique(shift_values)) == 1) {
      
      # Set normal distribution to TRUE if no variance is present
      Shift_Data[protein, "shapiro_p"] <- NA
      Shift_Data[protein, "normal_distributed"] <- TRUE
      
    } else {
      
      # Perform Shapiro-Wilk test to check for normal distribution
      shapiro_result <- shapiro.test(shift_values)
      Shift_Data[protein, "shapiro_p"] <- shapiro_result$p.value
      Shift_Data[protein, "normal_distributed"] <- shapiro_result$p.value >= 0.05
    }
    
    # Perform one-sided t-test if data is normal distributed
    if (Shift_Data[protein, "normal_distributed"] == TRUE) {
      
      test_result <- t.test(shift_values, mu = 1, alternative = "greater")
      
      Shift_Data[protein, "p_value_ttest_filtered"] <- test_result$p.value
      Shift_Data[protein, "significant_ttest_filtered"] <- ifelse(test_result$p.value < 0.05, TRUE, FALSE)
      
    } else {
      # No t-test applied if data is not normal distributed
      Shift_Data[protein, "p_value_ttest_filtered"] <- NA
      Shift_Data[protein, "significant_ttest_filtered"] <- NA
    }
  }
}

# Summary of proteins regarding normal distribution
table(Shift_Data$normal_distributed, useNA = "ifany")

# Summary of proteins regarding significance of t-test
table(Shift_Data$significant_ttest_filtered, useNA = "ifany")
```

## Plot T-Test Results - Lina
### Goal: 
- Plot t-test results by visualizing CoM positions in Ctrl vs. RNase 
```{r}
# Create scatter plot of CoM values in Ctrl (x) vs. RNase (y) for all proteins
# Color points based on t-test result (significant or not)
ggplot(Shift_Data, aes(x = `CoM_Ctrl`, y = `CoM_RNase`, color = case_when(
  `significant_ttest_filtered` ~ "Significant Left Shift (RBP)",
    TRUE ~ "No significant Left Shift"
  ))) +
  geom_point(alpha = 0.6) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray20") +
  scale_color_manual(name = "RBP Identity",values = c(
    "Significant Left Shift (RBP)" = "darkred",
    "No significant Left Shift" = "gray70"
  ))+
  labs(title = "Center of Mass in Ctrl and RNase: T-Test Results",
       x = "Center of Mass - Control",
       y = "Center of Mass - RNase") +
  theme_minimal()+
  theme(
    legend.position = c(0.02, 0.98),
    legend.justification = c("left", "top"),
    legend.background = element_rect(fill = "white",color = "gray70")
  )
```

## Validation of T-Test with UniProt Data - Lina
### Goal:
Assess the validity of our T-test-based identification of RNA-binding proteins (RBPs), by comparing the results with annotated human RBPs from UniProt.

This includes:

- Overlap analysis between our tested proteins and known UniProt RBPs
- Calculation of a hit rate (percentage of known RBPs detected as T-test positives)
- Validation with literature-supported positive and negative control proteins
```{r}

# Load annotated RNA-binding proteins (Keyword KW-0694) from UniProt (human-specific)
uniprot_rbps <- read.delim("uniprotkb_KW_0694_AND_model_organism_96_2025_07_04.tsv", 
                           header = TRUE, sep = "\t", stringsAsFactors = FALSE)

# Extract UniProt entry names (used for matching)
known_rbps <- uniprot_rbps$Entry.Name
glue("Number of known RBPs in UniProt: {length(known_rbps)}")

# Extract RBP candidates identified by T-test
t_test_positives <- rownames(
  Shift_Data[Shift_Data$significant_ttest_filtered == TRUE & 
               !is.na(Shift_Data$significant_ttest_filtered), ])

# Determine overlap: known RBPs present in our dataset
overlap_MS_Table <- intersect(rownames(MS_Table), known_rbps)
glue("Number of UniProt RBPs tested with R-DeeP: {length(overlap_MS_Table)}")

# Determine overlap: known RBPs that were also T-test positive
overlap_t_test <- intersect(t_test_positives, known_rbps)
glue("Number identified as RBPs (T-Test positive): {length(overlap_t_test)}")
glue("Hit rate: {round(length(overlap_t_test)/length(overlap_MS_Table)*100, 2)}%")

# Determine number of identified RBS not listed as RBP in UniProt 
novel_candidates <- t_test_positives[!t_test_positives %in% known_rbps]
glue("Novel candidates identified as RBP but not listed in UniProt: {(length(novel_candidates))}")

# Positive Control Validation

  # RBM10, SMN1, and FMR1 are well-documented RBPs (literature-supported)
  pos_controls <- c("RBM10_HUMAN", "SMN_HUMAN", "FMR1_HUMAN")

  # Check whether they are in our dataset and classified as T-test positives
  pos_df <- data.frame(
    Protein_Positive_Control = pos_controls,
    InDataset = pos_controls %in% rownames(MS_Table),
    TTest = pos_controls %in% t_test_positives)
  print(pos_df)

# Positive Control Validation
  
  # ACTB, SDHB, and COX4I1 are typically not considered RNA-binding (negative controls)
  neg_controls <- c("ACTB_HUMAN", "SDHB_HUMAN", "COX41_HUMAN")
  
  # Same check as above for negatives
  neg_df <- data.frame(
    Protein_Negative_Control = neg_controls,
    InDataset = neg_controls %in% rownames(MS_Table),
    TTest = neg_controls %in% t_test_positives)
  print(neg_df)
```

### Evaluation of T-Test Limitations - Lina, Cihan, Sofia
### Goal:

This section investigates potential false negatives from the T-test-based RBP identification. 

- Explore cases where known RBPs were not classified as significant and examine possible causes.
- Manual inspection of  different samples of 40 proteins each:
  1. Not identified RBPs to assess false negative rate.
  2. T-Test positives to assess false positive rate. 
  3. Borderline cases (0.05 > p-value > 0.045)

**NOTE:** Here only samples of 10 proteins are shown, for visibility in html
```{r}
# Identify known UniProt RBPs not found by T-Test
not_identified <- known_rbps[! known_rbps %in% t_test_positives & known_rbps %in% rownames(MS_Table)]

# Total "missed" RBPs present in dataset
glue("RNA-binding/-interacting proteins (UniProt) analyzed but not detected in our data: {length(not_identified)}")

# Analyze potential causes
shapiro_failed <- Shift_Data[is.na(Shift_Data$shapiro_p),]
percentage_shapiro_failed <- sum(is.na(Shift_Data[not_identified, "shapiro_p"])) /length(not_identified) *100
glue("Number of Proteins, that were excluded, because shapiro results where NA: {nrow(shapiro_failed)}")
glue("Approx. Percentage of not identified RBPs that where lost in Shapiro-Wilk test: {round(percentage_shapiro_failed, 1)} %")

normality_failed <- Shift_Data[Shift_Data$normal_distributed == FALSE,]
percentage_normality_failed <- sum(Shift_Data[not_identified, "normal_distributed"] == FALSE) / length(not_identified) *100
glue("Number of Proteins, that where excluded, because replicates wheren't normally distributed: {nrow(normality_failed)}")
glue("Approx. Percentage of not identified RBPs that where lost in normality test: {round(percentage_normality_failed, 1)} %")

```

```{r}
#Visual inspection of a sample of non-identified proteins
par(mfrow = c(2, 5))
sample_not_identified <- head( not_identified, 10)
for (s in sample_not_identified ){
  plot_protein(s)
}
glue("Manual inspection of 40 non-identified RBPs suggests a false negative rate of approximately 13% (5 out of 40) within the testable subset (visual shift despite test results)")
```

```{r}
#Visual inspection of a sample of T-Test positive proteins
par(mfrow = c(2, 5))
sample_t_test_positives <-head(t_test_positives,10)
for (s in sample_t_test_positives){
  plot_protein(s)
}

glue("From a sample of 40 T-test-positive proteins, only 2 would have been visually rejected as RBPs, corresponding to a 5% false positive rate.")
```

```{r}
# Visual inspection of proteins with marginally significant p-values (above 0.045)
par(mfrow = c(4, 5))
t_test_positives_critical_p_value <- rownames(
  Shift_Data[
    Shift_Data$significant_ttest_filtered == TRUE &
    !is.na(Shift_Data$significant_ttest_filtered) &
    Shift_Data$p_value_ttest_filtered > 0.045,
  ]
)
for (s in t_test_positives_critical_p_value){
  plot_protein(s)
}

glue("Furthermore, of all proteins with p-values > 0.045 (n = 18), only 4 were judged inconsistent with an RBP-like shift profile, suggesting that most borderline cases still show convincing shift patterns.")
```

### Plot Validation of T-test with UniProt Data - Lina
### Goal:

- This plot extends the CoM-based T-test visualization by highlighting known RBPs from UniProt.
- This view helps assess the sensitivity and limitations of the shift-based identification method relative to external RBP annotations.
```{r}
# Create data subset of proteins for highlighting (was necessary for coloring sequence)
highlight_data <- subset(Shift_Data,
                         rownames(Shift_Data) %in% overlap_t_test |
                         rownames(Shift_Data) %in% not_identified |
                         rownames(Shift_Data) %in% novel_candidates)

# Classify each protein into a color group
highlight_data$color_group <- case_when(
  rownames(highlight_data) %in% overlap_t_test ~ "Overlapping with UniProt",
  rownames(highlight_data) %in% not_identified ~ "UniProt Proteins not identified",
  rownames(highlight_data) %in% novel_candidates ~ "Novel Candidates"
)

# Control transparency depending on group
highlight_data$alpha_group <- case_when(
  highlight_data$color_group == "Overlapping with UniProt" ~ "high",
  highlight_data$color_group == "UniProt Proteins not identified" ~ "high",
  highlight_data$color_group == "Novel Candidates" ~ "low"
)

# Base plot: all proteins shown in background
ggplot(Shift_Data, aes(x = `CoM_Ctrl`, y = `CoM_RNase`)) +
  
    # Background: all non-highlighted proteins in light gray
    geom_point(aes(color = "No significant Shift"), alpha = 0.3, show.legend = FALSE) +
  
    # Highlighted groups: UniProt hits, misses, and T-test positives
    geom_point(data = highlight_data,
             aes(color = color_group, alpha = alpha_group)) +
    scale_color_manual(name = "Significance as RBP",values = c(
    "No significant Shift" = "gray80",
    "Novel Candidates" = "lightcoral",
    "Overlapping with UniProt" = "darkblue",
    "UniProt Proteins not identified" = "#009ACD"
    ))+
    scale_alpha_manual(values = c("high" = 0.7, "low" = 0.3), guide = "none") +
  
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray20") +
  labs(title = "Validation of T-Test: Comparing with UniProt Data",
       x = "Center of Mass - Control",
       y = "Center of Mass - RNase") +
  theme_minimal()+
  theme(
    legend.position = c(0.02, 0.98),
    legend.justification = c("left", "top"),
    legend.background = element_rect(fill = "white",color = "gray70")
    )
```

## T-Test for non-synchronised HELA Cells - Lina

- This section reproduces all necessary pipeline steps with adjusted variable names. 

**NOTE:** All variables related to the non-synchronized dataset are suffixed with `_NS`.
```{r}
# Loading Data
MS_Table_NS <- read.table("RDeeP_HeLa_NS.csv", header = TRUE, row.names = 1, sep = ";")

# Dataframe
treatment <- factor(rep(c("Ctrl", "RNase"), each = 3, length.out = 150))
replicate <- factor(rep(c("Ctrl_Rep1", "Ctrl_Rep2", "Ctrl_Rep3", "RNase_Rep1","RNase_Rep2", "RNase_Rep3"),25))
fraction <- factor(rep(paste0("Fraction_", 1:25), each = 6))

data <- data.frame(rownames = colnames(MS_Table),treatment = treatment, replicate = replicate, fraction = fraction)

# Normalization of triplicates
average.list.NS <- list() 

for (f in levels(fraction)) {
  
  cols.Ctrl <- which(fraction == f & treatment == "Ctrl") 
  average.Ctrl <- rowMeans(MS_Table_NS[,cols.Ctrl]) 
  average.list.NS[[paste0("Ctrl_",f)]] <- average.Ctrl 
  
  cols.RNase <- which(fraction == f & treatment == "RNase")
  average.RNase <- rowMeans(MS_Table_NS[,cols.RNase])
  average.list.NS[[paste0("RNase_",f)]] <- average.RNase
}

MS_Table_Averages_NS <- as.data.frame(average.list.NS) 
rownames(MS_Table_Averages_NS) <- rownames(MS_Table_NS)

fractions <- paste0("Fraction_", 1:25)

ordered_names <- as.vector(rbind(
  paste0("Ctrl_", fractions),
  paste0("RNase_", fractions)
))

MS_Table_Averages_NS <- MS_Table_Averages_NS[, ordered_names]

# Normalization to 100

ctrl_cols <- grep("^Ctrl_", colnames(MS_Table_Averages_NS)) 
rnase_cols <- grep("^RNase_", colnames(MS_Table_Averages_NS))

ctrl_norm <- MS_Table_Averages_NS[, ctrl_cols] / rowSums(MS_Table_Averages_NS[, ctrl_cols]) * 100
rnase_norm <- MS_Table_Averages_NS[, rnase_cols] / rowSums(MS_Table_Averages_NS[, rnase_cols]) * 100

MS_Table_Norm_NS <- cbind(ctrl_norm, rnase_norm)
MS_Table_Norm_NS <- MS_Table_Norm_NS[, colnames(MS_Table_Averages_NS)]

# Function for protein plotting 
plot_protein_NS <- function(x) {
  protein_of_interest <- x 
  protein_row <- MS_Table_Norm_NS[rownames(MS_Table_Norm_NS) == protein_of_interest, ]
  ctrl_values <- as.numeric(protein_row[seq(1, 49, by=2)])
  rnase_values <- as.numeric(protein_row[seq(2, 50, by=2)])
  fractions <- 1:25
  max_val <- max(ctrl_values, rnase_values, na.rm = TRUE)
  ylim_range <- c(0, max_val * 1.1)

  plot(fractions, ctrl_values, type="o", pch=20, lty=1, lwd =1.5, col="forestgreen", ylim=range(c(ctrl_values, rnase_values)),
       xlab="Fraction", ylab="Normalized Intensity", main= paste(protein_of_interest, "non-synchronised"), axes = FALSE)
       
  lines(fractions, rnase_values, type="o",pch =20, lty=1,lwd =1.5, col="firebrick3")
  
  polygon(c(fractions, rev(fractions)), 
          c(ctrl_values, rep(0, length(ctrl_values))), 
          col=adjustcolor("forestgreen", alpha.f=0.1), border=NA)
  
  polygon(c(fractions, rev(fractions)), 
          c(rnase_values, rep(0, length(rnase_values))), 
          col=adjustcolor("firebrick3", alpha.f=0.1), border=NA)
  
  axis(1, at = 1:25, labels = 1:25, cex.axis = 0.7)
  axis(2, cex.axis = 0.7, las =2)
  grid(nx = NULL, ny = NULL, col = "lightgray", lty = "dotted", lwd = 0.8)
  
  legend("topright", legend=c("Ctrl", "RNase"), col=c("forestgreen", "firebrick3"), 
         lty=1, lwd = 1.5,  pch=20, bg = "white", bty = "o", box.col = NA)
}

# Shift Characteristics based on normalized Data and CoM
x <- 1:25

CoM_Ctrl_NS <- numeric(nrow(MS_Table_Norm_NS))
CoM_RNase_NS <- numeric(nrow(MS_Table_Norm_NS))
shift_distance_NS <- numeric(nrow(MS_Table_Norm_NS))
shift_direction_NS <- numeric(nrow(MS_Table_Norm_NS))

for (p in seq_len(nrow(MS_Table_Norm_NS))) {

  row_vals <- as.numeric(MS_Table_Norm_NS [p,])
  ctrl_vals <- row_vals[seq(1, 50, by =2)]
  rnase_vals <- row_vals[seq(2, 50, by=2)]

  CoM_Ctrl_NS[p] <- sum(ctrl_vals * x) / sum(ctrl_vals)
  CoM_RNase_NS[p] <- sum(rnase_vals * x) / sum(rnase_vals)
  shift_distance_NS[p] <- CoM_Ctrl_NS[p] - CoM_RNase_NS[p] 
  shift_direction_NS[p] <- sign(shift_distance_NS[p]) 
}

Shift_Data_NS <- data.frame(
  CoM_Ctrl= CoM_Ctrl_NS,
  CoM_RNase = CoM_RNase_NS,
  shift_distance = shift_distance_NS,
  shift_direction= shift_direction_NS,
  row.names = rownames(MS_Table_Norm_NS))

# Normalization of MS_Table_NS to 100

ctrl_cols_t1 <- grep("_Ctrl_Rep1", colnames(MS_Table_NS))
ctrl_cols_t2 <- grep("_Ctrl_Rep2", colnames(MS_Table_NS))
ctrl_cols_t3 <- grep("_Ctrl_Rep3", colnames(MS_Table_NS))
RNase_cols_t1 <- grep("_RNase_Rep1", colnames(MS_Table_NS))
RNase_cols_t2 <- grep("_RNase_Rep2", colnames(MS_Table_NS))
RNase_cols_t3 <- grep("_RNase_Rep3", colnames(MS_Table_NS))

ctrl_norm_t1 <- MS_Table_NS[, ctrl_cols_t1] / rowSums(MS_Table_NS[, ctrl_cols_t1]) * 100
ctrl_norm_t2 <- MS_Table_NS[, ctrl_cols_t2] / rowSums(MS_Table_NS[, ctrl_cols_t2]) * 100
ctrl_norm_t3 <- MS_Table_NS[, ctrl_cols_t3] / rowSums(MS_Table_NS[, ctrl_cols_t3]) * 100
RNase_norm_t1 <- MS_Table_NS[, RNase_cols_t1] / rowSums(MS_Table_NS[, RNase_cols_t1]) * 100
RNase_norm_t2 <- MS_Table_NS[, RNase_cols_t2] / rowSums(MS_Table_NS[, RNase_cols_t2]) * 100
RNase_norm_t3 <- MS_Table_NS[, RNase_cols_t3] / rowSums(MS_Table_NS[, RNase_cols_t3]) * 100

Norm_Data_for_t_NS <- cbind(ctrl_norm_t1, RNase_norm_t1, ctrl_norm_t2, RNase_norm_t2, ctrl_norm_t3, RNase_norm_t3)

fractions <- 1:25
reps <- 1:3
conditions <- c("Ctrl", "RNase") 
ordered_names <- c()
for (fraction in fractions) {
  for (rep in reps) {
    for (condition in conditions) {
      name <- paste0("Fraction", fraction, "_", condition, "_Rep", rep)
      ordered_names <- c(ordered_names, name)
    }
  }
}
Norm_Data_for_t_NS <- Norm_Data_for_t_NS[, ordered_names]

# Calculation of CoM for T-Test

fractions <- 1:25
conditions <- c("Ctrl", "RNase")
replicates <- c("Rep1", "Rep2", "Rep3")

results_com_NS <- list()

for (cond in conditions) {
  for (rep in replicates) {
    pattern <- paste0("^Fraction", fractions, "_", cond, "_", rep, "$")
    cols <- grep(paste(pattern, collapse="|"), colnames(Norm_Data_for_t_NS), value = TRUE)  
    subdata <- Norm_Data_for_t_NS[, cols]   
    subdata <- subdata[, order(as.numeric(gsub("Fraction(\\d+)_.*", "\\1", cols)))]  
    com <- apply(subdata, 1, function(x) {
      sum(x * fractions) / sum(x)
    })

    results_com_NS[[paste(cond, rep, sep = "_")]] <- com
  }
}

CoM_Data_for_t_NS <- as.data.frame(results_com_NS)  

rownames(CoM_Data_for_t_NS) <- rownames(Norm_Data_for_t_NS)

# Calculating Shift-Values for T-Test

Shift_Data_for_t_NS <- data.frame(
  shift_distance_rep1 = CoM_Data_for_t_NS[, 1] - CoM_Data_for_t_NS[, 4],
  shift_distance_rep2 = CoM_Data_for_t_NS[, 2] - CoM_Data_for_t_NS[, 5],
  shift_distance_rep3 = CoM_Data_for_t_NS[, 3] - CoM_Data_for_t_NS[, 6],
  row.names = rownames(CoM_Data_for_t_NS)
)

# T-Test

Shift_Data_NS$shapiro_p <- NA
Shift_Data_NS$normal_distributed <- NA
Shift_Data_NS$p_value_ttest_filtered <- NA
Shift_Data_NS$significant_ttest_filtered <- NA

for (protein in rownames(Shift_Data_for_t_NS)) {
 
  shift_values <- as.numeric(Shift_Data_for_t_NS[protein, c("shift_distance_rep1", "shift_distance_rep2", "shift_distance_rep3")])

  if (all(!is.na(shift_values))) {

    if (length(unique(shift_values)) == 1) {
      Shift_Data_NS[protein, "shapiro_p"] <- NA
      Shift_Data_NS[protein, "normal_distributed"] <- TRUE
      
    } else {
      shapiro_result <- shapiro.test(shift_values)
      Shift_Data_NS[protein, "shapiro_p"] <- shapiro_result$p.value
      Shift_Data_NS[protein, "normal_distributed"] <- shapiro_result$p.value >= 0.05
    }
    
    if (Shift_Data_NS[protein, "normal_distributed"] == TRUE) {
      test_result <- t.test(shift_values, mu = 1, alternative = "greater")
      Shift_Data_NS[protein, "p_value_ttest_filtered"] <- test_result$p.value
      Shift_Data_NS[protein, "significant_ttest_filtered"] <- ifelse(test_result$p.value < 0.05, TRUE, FALSE)
      
    } else {
      Shift_Data_NS[protein, "p_value_ttest_filtered"] <- NA
      Shift_Data_NS[protein, "significant_ttest_filtered"] <- NA
    }
  }
}
# Analysis of results for non-synchronized HeLa Cells
table(Shift_Data_NS$significant_ttest_filtered, useNA = "ifany")
```

# Comparison of Proteins found as RBP in Mitosis vs. in NS_Hela - Lina
### Goal:
- Compare proteins identified as RNA-binding by T-test in mitotic vs. non-synchronized HeLa cells. Analyze the overlap between datasets, list proteins uniquely shifted during mitosis, and visualize differences in shift characteristics. 
```{r}

# Identify proteins classified as significant RBPs in non-synchronized HeLa cells
t_test_positives_NS <- rownames(Shift_Data_NS[Shift_Data_NS$significant_ttest_filtered == TRUE & !is.na(Shift_Data_NS$significant_ttest_filtered), ])

# Determine protein overlapp across datasets
overlap_analysis <- intersect(rownames(MS_Table_NS), rownames(MS_Table))
glue("Number of Proteins in sample NS_Hela: {length(rownames(MS_Table_NS))}")
glue("Number of Proteins analysed in both samples: {length(overlap_analysis)}")

# Identify proteins found as RBPs in both conditions
overlap_t_test_positivs <- intersect(t_test_positives, t_test_positives_NS)
glue("Number of RBPs found in both samples: {length(overlap_t_test_positivs)}")

# Identify RBPs found *only* in mitosis, and also present in both datasets
RBPs_Mitosis <- setdiff(t_test_positives, t_test_positives_NS)
RBPs_Mitosis <- intersect(RBPs_Mitosis, overlap_analysis)
glue("Number RBPs found only in Mitosis: {length(RBPs_Mitosis)}")

# Number of RBPs found *only* in non-synchonized cells, and also present in both datasets
RBPs_Hela <- setdiff(t_test_positives_NS, t_test_positives)
RBPs_Hela <- intersect(RBPs_Hela, overlap_analysis)
glue("Number RBPs found only in non-synchonized cells: {length(RBPs_Hela)}")

# Display a sample of plots (mitosis and non-synchronised) of RBPs uniquely active in mitosis
par(mfrow = c(4, 5))
sample_RBPs_Mitosis <- head(RBPs_Mitosis,10)
for (r in sample_RBPs_Mitosis){
  plot_protein(r)
  plot_protein_NS(r)
}
```

# Visualise differences in shift characteristics
```{r}
# Define variables to extract from both datasets
cols_to_extract <- c("CoM_Ctrl", "CoM_RNase", "shift_distance", "shift_direction", "p_value_ttest_filtered", "significant_ttest_filtered")

# Subset and rename columns for both conditions
subset_data_S <- Shift_Data[overlap_analysis, cols_to_extract]
subset_data_NS <- Shift_Data_NS[overlap_analysis, cols_to_extract]
colnames(subset_data_S) <- paste0(colnames(subset_data_S), "_mitosis")
colnames(subset_data_NS) <- paste0(colnames(subset_data_NS), "_nonSync")

# Merge into one combined dataframe
Shift_Data_Combined <- cbind(subset_data_S,subset_data_NS)
head(Shift_Data_Combined)

# Scatterplot of shift distances

ggplot(Shift_Data_Combined, aes(x = `shift_distance_mitosis`,
                                y = `shift_distance_nonSync`,
                                color = case_when(
                                  !`significant_ttest_filtered_mitosis` & !`significant_ttest_filtered_nonSync` ~ "No significant RBPs",
                                  `significant_ttest_filtered_mitosis` & !`significant_ttest_filtered_nonSync` ~ "RBPs only active in Mitosis",
                                  !`significant_ttest_filtered_mitosis` & `significant_ttest_filtered_nonSync` ~ "RBPs not active in Mitosis",
                                  TRUE ~ "RBPs always active"
                                  ))) +
  geom_point(alpha = 0.6) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "red") +
  scale_color_manual(name = "Significance as RBP",
                     values = c(
                       "No significant RBPs" = "grey80",
                       "RBPs not active in Mitosis" = "gray30",
                       "RBPs always active" = "lightcoral",
                       "RBPs only active in Mitosis" = "darkred"
                       ))+
  labs(title = "Shift Distance: Mitosis vs. Non-Synchronized",
       x = "Shift Distance (Mitosis)",
       y = "Shift Distance (Non-Synchronized)") +
  theme_minimal()
```





# Further Data Analysis

## Additional Data for all Proteins using Uniprot and CORUM - Lina (carefull runs ~35 min!... grab a coffee :)

###Goal: 
Build dataframe with annotations for further analysis such as references for RNA-dependent complexes or predicting molecular weight from peak position.
- Molecular weights retrieved via the UniProt REST API
- Complex membership based on the CORUM database (HUMAN complexes only)

```{r}
# Map each protein's UniProt entry name to its accession ID
get_accession_from_entryname <- function(entry_name) {
  url <- paste0("https://rest.uniprot.org/uniprotkb/search?query=", 
                entry_name, "&fields=accession&format=json&size=1")
  res <- try(GET(url), silent = TRUE)
  if (inherits(res, "try-error") || res$status_code != 200) {
    return(NA)
    }
  txt <- content(res, "text", encoding = "UTF-8")
  data <- fromJSON(txt, simplifyVector = FALSE)
  if (length(data$results) == 0) {
    return(NA)
    }
  else{
  return(data$results[[1]]$primaryAccession)
    }
    
}

# Function to retrieve the molecular weight from UniProt for each accession ID
get_uniprot_mass <- function(accession_ids) {
  url <- paste0("https://rest.uniprot.org/uniprotkb/", accession_ids, ".json")
  res <- try(GET(url), silent = TRUE)
  if (inherits(res, "try-error") || res$status_code != 200) {
    return(NA)
    }
  data <- fromJSON(content(res, "text", encoding = "UTF-8"))
  return(data$sequence$molWeight)
}

# Apply both functions to the MS_Table entries
entry_names <- rownames(MS_Table)
accession_ids <- pbsapply(entry_names, get_accession_from_entryname)
masses <- pbsapply(accession_ids, get_uniprot_mass)

# Convert mass results into numeric vector (set to NA for proteins with failed retrieval)
masses_vec <- rep(NA_real_, length(accession_ids))
names(masses_vec) <- accession_ids
valid_idx <- which(!sapply(masses, is.null))
masses_vec[valid_idx] <- as.numeric(unlist(masses[valid_idx]))

# Create annotated dataframe with UniProt and molecular weight
protein_data <- data.frame(
  Entry = entry_names,
  UniProtAccession = accession_ids,
  MolecularWeight_kDa = masses_vec / 1000
)

# Load CORUM data (human protein complexes only)
corum <- fread("corum_humanComplexes.txt", sep = "\t", header = TRUE) 

# Expand CORUM entries /Unlist so each UniProt ID is listed individually with its complex name
corum_expanded <- corum[, .(
  UniProtAccession = unlist(strsplit(subunits_uniprot_id, ";"))
), by = .(ComplexName = complex_name)]

corum_expanded <- unique(corum_expanded)

# Add binary Expression wheather protein is part of any complex in CORUM?
protein_data$CORUM_member <- protein_data$UniProtAccession %in% corum_expanded$UniProtAccession

# Link all complex names associated with each protein (multiple allowed)
corum_complex_list <- corum_expanded[, .(
  CORUM_complex_names = paste(unique(ComplexName), collapse = "; ")
), by = UniProtAccession]

# Add complex names to protein data
protein_data <- merge(protein_data, corum_complex_list, by = "UniProtAccession", all.x = TRUE, sort = FALSE)
protein_data$CORUM_member <- !is.na(protein_data$CORUM_complex_names)

# Background info â€” total number of unique proteins and complexes in CORUM
n_human_complexes <- unique(corum$complex_id)
length(n_human_complexes) # number of complexes

all_proteins <- unlist(strsplit(corum$subunits_uniprot_id, ";"))
unique_proteins <- unique(all_proteins)
length(unique_proteins) # number of proteins in complexes

sum(protein_data$CORUM_member== TRUE) # number of our proteins known to be in complex 
```

## New Plot Protein function with all additional data
```{r}
plot_protein_info <- function(x) {
  
  # Split up plot area
  layout(matrix(1:2, nrow = 1), widths = c(4, 2))  
  
  # Extract data, define all variables and range of x- and y-axis
  protein_of_interest <- x 
  protein_row <- MS_Table_Norm[rownames(MS_Table_Norm) == protein_of_interest, ]
  ctrl_values <- as.numeric(protein_row[seq(1, 49, by=2)])
  rnase_values <- as.numeric(protein_row[seq(2, 50, by=2)])
  fractions <- 1:25
  max_val <- max(ctrl_values, rnase_values, na.rm = TRUE)
  ylim_range <- c(0, max_val * 1.2)

  # Core plot function using crtl_values
  plot(fractions, ctrl_values, type="o", pch=20, lty=1, lwd = 1.5,  col="forestgreen", ylim= ylim_range,
       xlab="Fraction", ylab="Normalized Intensity", main= protein_of_interest, axes = FALSE)
       
  # Add line for rnase_values
  lines(fractions, rnase_values, type="o",pch =20, lty=1, lwd = 1.5,  col="firebrick3")
  
  # Color area under the curve
  polygon(c(fractions, rev(fractions)), 
          c(ctrl_values, rep(0, length(ctrl_values))), 
          col=adjustcolor("forestgreen", alpha.f=0.1), border=NA)
  
  polygon(c(fractions, rev(fractions)), 
          c(rnase_values, rep(0, length(rnase_values))), 
          col=adjustcolor("firebrick3", alpha.f=0.1), border=NA)
  
  # Add x- and y-axis with correct labels
  axis(1, at = 1:25, labels = 1:25, cex.axis = 0.7)
  axis(2, cex.axis = 0.7, las =2)
  grid(nx = NULL, ny = NULL, col = "lightgray", lty = "dotted", lwd = 0.8)

  # Add legend
  legend("topright", legend=c("Ctrl", "RNase"), col=c("forestgreen", "firebrick3"), 
         lty=1, lwd = 1.5,  pch=20, bg = "white", bty = "o", box.col = NA, horiz = TRUE)
  
  # Add info panel
  par(mar = c(0, 0, 2, 0))
  plot.new()
  
  shift_info <- subset_data_S[rownames(subset_data_S) == x, ]
  protein_info <- protein_data[protein_data$Entry == x, ]
  info_lines <- c(
    paste("CoM Ctrl:",round(shift_info$CoM_Ctrl_mitosis, 1)),
    paste("CoM RNase:", round(shift_info$CoM_RNase_mitosis, 1)),
    paste("Shift Distance:", round(shift_info$shift_distance_mitosis, 1)),
    paste("Identified as RBP:", shift_info$significant_ttest_filtered_mitosis),
    paste("Known Complex (CORUM):", protein_info$CORUM_member),
    paste("Weight (monomeric):", round(protein_info$MolecularWeight_kDa, 2) ,"kDA")
  )
  line_height <- 0.06
  n_lines <- length(info_lines)
  y_start <- 0.5 + (n_lines - 1) * line_height / 2
  for (i in seq_along(info_lines)) {
    y_pos <- y_start - (i - 1) * line_height
    text(x = 0, y = y_pos, labels = info_lines[i], adj = c(0, 1), cex = 0.9)
    }
}

plot_protein_info("RS6_HUMAN")
```

## Screening for RBP complexes active in Mitosis - Sofia and Cihan 

### Selection of clustering criteria and hierarchical clustering
### Goal: 
Select necessary parameters/dimensions and get an idea of the distribution of clusters. 

### Additional Information:

Peak_data is mainly taken into consideration, specifically peak height (not position or number of peaks) we only focus on Ctrl samples, not RNase as we expect different proteins to have different distributions after RNase degradation, even when they are in the same complex. Following this logic shift data is also irrelevant. To this data we add COM of Ctrl, here peak position is relevant. Overall similar height is more important than similar peak fraction. Runs only on set of RBPS exculsively active in mitosis . Wards method (euclidean distance applied), !i think here we have to say it did not work. 

```{r}

#from the two shift and peak characteristics we extract some variables creating a new merged table which also has only the names of the RBPs that are aktive in mitosis !! hier stimmt was nicht.

# 1) Filter only the RBPs relevant in Mitosis 

filtered_shift_Mitosis <- Shift_Data[rownames(Shift_Data) %in% RBPs_Mitosis, ]

filtered_peak_Mitosis <- Peak_Data[rownames(Peak_Data) %in% RBPs_Mitosis, ]

# 2) Selecting only the interesting coloumns creating comon dataframe

merged_filterd_mitosis <- cbind(
  filtered_shift_Mitosis[, c("CoM_Ctrl")], # selecting a specific col
  filtered_peak_Mitosis %>% select(ends_with("height_Ctrl")) # choosing only col that end with
)


# 3) clean data for further steps 

# Replace NA values with 0 (when there was no peak there was not protein)
clean_merged_filterd_mitosis <- merged_filterd_mitosis
clean_merged_filterd_mitosis[is.na(clean_merged_filterd_mitosis)] <- 0


# 4) do hirarchical clustering in order to analize number of clusters that could be found


# Distance matrix (Euclidean)
dist_matrix <- dist(clean_merged_filterd_mitosis)

# Hierarchical clustering (Wards)
hc_ward <- hclust(dist_matrix, method = "ward.D2")

# Plot dendrogram
par(mfrow = c(2, 2))
#plot(hc_ward, main = "Ward's Method")  was sollte das 


plot(hc_ward, labels = FALSE, main = "Ward's Method (no labels)")

# image for download: 

png("C://Users//Sofi//Desktop//4 Semester//Bioinfo_project//Downloadsdendrogram_large.png", width = 1200, height = 800)
plot(hc_ward, labels = FALSE, main = "Ward's Method (Large Output)")
dev.off()


```

### Using DBSCAN algorithm 

### Goal: 
Find and applying a clustering method, that will highlight proteins, which could be working in a complex. 

### Additional Information:
DBSCAN is a function that can classify points in low-density regions as "noise." This means clusters are not only defined by distance (like in k-means), but also by density.
The code I wrote has two important parameters. These parameters are:

Îµ (epsilon): The maximum distance between two points to be considered neighbors.
If this number is very small, everything is classified as noise; if itâ€™s too large, noise may be included as relevant (resulting in one huge cluster).

MinPts: The minimum number of neighbors required for a point to be considered a so-called core point.
A core point must have at least MinPts other points within Îµ.
If this value is too low, even single points can form clusters. On the other hand, if itâ€™s too high, only large clusters are formed and smaller ones might not be recognized at all.
There are also border points, which are within Îµ distance of a core point but do not have enough neighbors themselves to be core points.

Everything that does not meet these conditions is filtered out and labeled as noise.
```{r}
# 1) Scale data

scaled_data <- scale(clean_merged_filterd_mitosis) # substracts mean, scales it by dividing sd=> data was normalized per row => here Goal is compare Proteins 

# 2) DBSCAN # its important to choose eps and minPts correctly, eps is the max distance for two points to be neighbors, minPts  minimum number of points required to form a dense region.

db <- dbscan(scaled_data, eps = 0.7, minPts = 4) # parameters can be changed

# 3) PCA for plotting

pca <- prcomp(scaled_data) # function for PCA
pca_df <- as.data.frame(pca$x[, 1:2])  # PC1 and PC2, for all Proteins 
pca_df$cluster <- as.factor(db$cluster)
pca_df$protein <- rownames(clean_merged_filterd_mitosis)  # Protein names from cleaned data 

# 4) Plot with noise in grey

ggplot(pca_df, aes(x = PC1, y = PC2, color = cluster, label = ifelse(cluster == 0, "", protein))) +
  geom_point(size = 2) +
  geom_text(check_overlap = TRUE, size = 2.5, vjust = -1) +
  scale_color_manual(values = c("0" = "grey", "1" = "blue", "2" = "red", "3" = "green", "4" = "purple", "5" = "orange")) +
  theme_minimal() +
  labs(title = "DBSCAN Clustering of Proteins",
       subtitle = "Visualized with PCA (2D)",
       color = "Cluster") +
  theme(plot.title = element_text(face = "bold"))

# 5) Create table: which proteins are in which cluster

clustered_proteins <- split(rownames(clean_merged_filterd_mitosis), db$cluster) # asignes the cluster to each Protein name from original dataframe 

# Print each cluster's members
for (cl in sort(unique(db$cluster))) { # loops over each cluster number in sorted order
  
  cat(paste0("Cluster ", cl, ifelse(cl == 0, " (noise)", ""), ": ")) # pastes to console , separation of cluster name from list of Proteins 
  
  cat(paste(clustered_proteins[[as.character(cl)]], collapse = ", ")) # extracts list of proteins and collapses them 
  
  cat("\n\n") # adds spacing between clusters 
}
```


### Looking at plots of different clusters 
###Goal: 
Looking if the plots look similar or not in order to validate the parameters choosen above. 

Note! This code can be always run to get a better feeling over clusters 
```{r}
# Code from ploting a protein to visualize the proteins that seam to make a complex
# View Examples

sample_RBPs_Cluster <- c("RL22_HUMAN", "RL23_HUMAN", "RL24_HUMAN", "RL27_HUMAN", "RL30_HUMAN", "RL34_HUMAN", "RLA1_HUMAN", "RS26_HUMAN", "RS2_HUMAN", "RS6_HUMAN", "RS12_HUMAN") # insert names of clustered proteins you want to compare 

for (r in sample_RBPs_Cluster){
  plot_protein(r)
}
```


### Finding the right parameters to choose the perfect cluster size 
###Goal: 
Getting a good idea of how parameters affect our clustering results, by trying all combinations and creating a heat map based on the performance on a cluster. 

Additional Information:
For the heatmap we made up following logic. 

a) Based on all combinations from one cluster (positive control):
- If two proteins are in the same cluster â†’ +1
- If two proteins are in different clusters â†’ -1
- If one or both are classified as noise â†’ 0

b) Based on two (or more) unrelated proteins (negative control):
- If they end up in the same cluster as our example proteins â†’ -1
- If they end up in different clusters â†’ +1
- If noise â†’ 0 (Iâ€™m least sure about this case)

```{r}

# -------------- PART 1: Creating a loop for all possible combinations for Îµ between the numbers ( 0.5-1.5) in steps of 0.1 and for MinPts (1-10) in steps of 1 ----------

# 1. Scale data like chunk before 
scaled_data <- scale(clean_merged_filterd_mitosis)
protein_names <- rownames(clean_merged_filterd_mitosis)
n_proteins <- nrow(scaled_data)

# 2. Create empty data frame to collect results
results_df <- data.frame(row.names = protein_names)

# 3. Loop over all combinations
for (eps in seq(0.5, 1.5, by = 0.1)) {
  for (minPts in 1:10) {
    
    # Run DBSCAN
    db <- dbscan(scaled_data, eps = eps, minPts = minPts) # runs combinations 
    
    # Store cluster assignments
    col_name <- paste0("eps_", eps, "_minPts_", minPts)
    results_df[[col_name]] <- db$cluster
  }
}

# -------------- PART 2: Creating a loop for all possible combinations for Îµ between the numbers ( 0.5-1.5) in steps of 0.1 and for MinPts (1-10) in steps of 1 ----------


# 1)Define your proteins of interest ( from Corum Data)

target_proteins <- c("RS12_HUMAN", "RS26_HUMAN", "RS2_HUMAN", "RS6_HUMAN") # this would be positiv controll, a complex we know about. 

negative_controls <- c("LPPRC_HUMAN", "UIMC1_HUMAN")

all_proteins <- c(target_proteins, negative_controls)

# 2) create all pairwise combinations (postiv control)

protein_pairs <- combn(all_proteins, 2, simplify = FALSE) 

# --- Step 4: scoring for each DBSCAN setting ---

score_results <- data.frame()

for (col_name in colnames(results_df)) { # selcts all coloums from DBSCAN combinations 
  
  cluster_assignments <- as.numeric(results_df[[col_name]]) # extracts data and converts to numeric
  
  names(cluster_assignments) <- rownames(results_df) # assignes its cluster number back to its protein name 
  
  pair_scores <- c()

  for (pair in protein_pairs) {
    p1 <- pair[1] # selects first protein 
    p2 <- pair[2] # selects second protein 
    c1 <- cluster_assignments[p1] 
    c2 <- cluster_assignments[p2]

    # Skip if NA
    if (is.na(c1) || is.na(c2)) {
      score <- NA

    # Both are targets
    } else if (p1 %in% target_proteins && p2 %in% target_proteins) {
      if (c1 == 0 || c2 == 0) {
        score <- 0 # noise is always 0
      } else if (c1 == c2) {
        score <- 1 # here when the two clusters are equal, its good 
      } else {
        score <- -1
      }

    # One is negative control, one is target
    } else if ((p1 %in% negative_controls && p2 %in% target_proteins) || 
               (p2 %in% negative_controls && p1 %in% target_proteins)) {
      if (c1 == 0 || c2 == 0) {
        score <- 0 # noise is always 0
      } else if (c1 == c2) {
        score <- -1 # here when the two clusters are equal its bad 
      } else {
        score <- 1  # Properly separated
      }

    # Both are negative controls â€“ don't score this pair
    } else {
      next # skips scoring booth negatives 
    }

    pair_scores <- c(pair_scores, score) # apart from neg neg pairs all resulting scores are listed  
  }

  avg_score <- mean(pair_scores, na.rm = TRUE) # computes the avaredge 

  parts <- strcapture("eps_([0-9.]+)_minPts_([0-9]+)", col_name, data.frame(eps = 0, minPts = 0))# extracts from colnames the values for eps and minPts as numbers 
  
  score_results <- rbind(score_results, data.frame( # three columns 
    eps = as.numeric(parts$eps),
    minPts = as.numeric(parts$minPts),
    score = avg_score
  ))
}

# --- Step 6: Plot heatmap ---
ggplot(score_results, aes(x = eps, y = minPts, fill = score)) +
  geom_tile(color = "grey70") +
  scale_fill_gradient2(low = "red", mid = "white", high = "blue", midpoint = 0, limits = c(-1, 1)) +
  labs(title = "Clustering Consistency of Protein Pairs",
       subtitle = "Based on DBSCAN parameter combinations",
       x = "Epsilon (Îµ)",
       y = "MinPts",
       fill = "Avg. Pair Score") +
  theme_minimal()


```


## Testing R-Deep for further use in molecular weight predictions (Linear Regression) - Lina
### GoaL: 
Investigate whether a linear model predicting molecular weight based on RNase values of this method (maximal peak position) can predict the molecular weight of proteins after RNase treatment.

-->  Conclusion: This approach does NOT yield a valid predictive model!
Possible reasons include:
- Elution position depends not only on mass, but also shape and density of the protein.
- Many proteins remain in RNA-independent protein complexes even after RNase treatment.(However, even after removing CORUM complex proteins, no strong correlation appears)
- Maximal Peak Position is not the correct parameter to predict molecular weight. (However, also parameter CoM showed no correlation)
- Peak-based features (e.g. max position or CoM) are too simplistic for modeling this complex system

```{r}
# Extract the position of the strongest (highest) peak for each protein in the RNase condition
max_peak_positions <- numeric(nrow(Peak_Data))

for (p in seq_len(nrow(Peak_Data))) {
  p_data <- Peak_Data [p,]
  peak_heights <- as.numeric(p_data[, paste0("peak", 1:6, "_height_RNase")])
  peak_positions <- as.numeric(p_data[, paste0("peak", 1:6, "_position_RNase")])
  
  if (all(is.na(peak_heights))) {
    max_peak_positions[p] <- NA
  } else {
    max_idx <- which.max(peak_heights)
    max_peak_positions[p] <- peak_positions[max_idx]
  }
  
}  
# Combine with molecular weight and center of mass information
Protein_Data_for_LR <- data.frame(
  max_peak_position_RNase = max_peak_positions,
  MolecularWeight_kDa = protein_data$MolecularWeight_kDa,
  CoM_RNase = Shift_Data$CoM_RNase
)
rownames(Protein_Data_for_LR) <- rownames(Peak_Data)

# Spearman correlation: molecular weight vs. strongest peak position
cor.test(Protein_Data_for_LR$max_peak_position_RNase,
         Protein_Data_for_LR$MolecularWeight_kDa,
         method = "spearman", use = "complete.obs")

# Linear model: can we predict molecular weight from peak position?
lm_model_peak_position <- lm(MolecularWeight_kDa ~ max_peak_position_RNase, data = Protein_Data_for_LR)
summary(lm_model_peak_position)

# 5 reference proteins with known molecular weight and elution fraction (Caudron et al.)
reference_proteins <- data.frame(
   x = c(3, 6, 9, 11, 14),
   y = c(14, 65, 160, 240, 480),
   name = c("RNaseA 14kDa", "BSA 65kDa", "Aldolase 4*40kDa", "Catalase 4*60kDa", "Ferritin 4*40 kDa") 
)

# Linear fit through reference points
linear_reference <- lm(y ~ x, data = reference_proteins)

# Extract subset of CORUM-listed complex members (for highlighting in scatter plot)
CORUM_comlexes <- protein_data[protein_data$CORUM_member == TRUE, ]
CORUM_comlexes <- Protein_Data_for_LR[rownames(Protein_Data_for_LR) %in% CORUM_comlexes$Entry, ]

# Scatter plot with reference line and annotations
ggplot(Protein_Data_for_LR %>% filter(MolecularWeight_kDa <= 1000), aes(x = max_peak_position_RNase, y = MolecularWeight_kDa)) +
  geom_point(aes(color = "All analyzed Proteins")) +
  geom_point(data = CORUM_comlexes,aes(x = max_peak_position_RNase, y = MolecularWeight_kDa, color = "Proteins in Complex (CORUM)"),alpha = 0.3)  +
  geom_abline(intercept = coef(linear_reference)[1], 
              slope = coef(linear_reference)[2], 
              color = "darkred", size = 1) +
  geom_point(data = reference_proteins, aes(x = x, y = y), color = "darkred", size = 3) +
  geom_text(data = reference_proteins[c(1), ], aes(x = x, y = y, label = name),
            vjust = -1,   hjust = 0.6, color = "darkred", size = 4, fontface = "bold") +
  geom_text(data = reference_proteins[c(5), ], aes(x = x, y = y, label = name),
            vjust = 0.3 ,   hjust = 1.2, color = "darkred", size = 4, fontface = "bold") +
  geom_text(data = reference_proteins[c(2, 3, 4), ], aes(x = x, y = y, label = name),
            vjust = 0.3,   hjust = -0.2, color = "darkred", size = 4, fontface = "bold") +
  theme_classic() + 
  theme(
    legend.position = c(0.02, 0.98),
    legend.justification = c("left", "top"),
    legend.background = element_rect(fill = "white",color = "gray70")) +
  scale_color_manual(values = c("All analysed Proteins" = "gray75", "Proteins in Complex (CORUM)" = "lightcoral"))+
  labs(x = "Peak Position", y = "Molecular Weight (kDa)", color = "Protein Category", 
    title = "Molecular Weight vs. Peak Position ")
```
