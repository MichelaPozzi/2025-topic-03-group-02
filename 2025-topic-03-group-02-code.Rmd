---
title: "2025-topic-03-group-02-code"
output: html_document
date: "2025-05-16"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

##Loading MS-Data
```{r}
MS_Table <- read.table("RDeeP_HeLa_Mitosis.csv", header = TRUE, row.names = 1, sep = ";")
```

# Data Cleanup
## Despription of the Data
```{r}
n_rows = nrow(MS_Table) 
n_rows # Number of Proteins
n_cols = ncol(MS_Table) 
n_cols # Number of varibale
unique(sapply(MS_Table, class)) # classification of variables
any(is.na(MS_Table)) # missing values
min(MS_Table) # minimum intensity
max(MS_Table) # maximum intensity


```

## Restructuration of the data
Create a dataframe with factors that make it possible to access specific data from MS_Table
```{r}
treatment <- factor(rep(c("Ctrl", "RNAse"), each = 3, length.out = 150))
replicate <- factor(rep(c("Ctrl_Rep1", "Ctrl_Rep2", "Ctrl_Rep3", "RNAse_Rep1","RNAse_Rep2", "RNAse_Rep3"),25))
fraction <- factor(rep(paste0("Fraction_", 1:25), each = 6))

data <- data.frame(rownames = colnames(MS_Table),treatment = treatment, replicate = replicate, fraction = fraction)
data
```
## Normalization of triplicates 
Create a new dataframe with average values of the replicates 
```{r}
average.list <- list() #create list

# for loop, going through all fractions: 
# selecting Ctrl columns for specific fraction
# computing average of these columns 
# adding a new vector to list e.g."Ctrl_Fraction_1" and assigning average values 

for (f in levels(fraction)) {
  
  cols.Ctrl <- which(fraction == f & treatment == "Ctrl") 
  average.Ctrl <- rowMeans(MS_Table[,cols.Ctrl]) 
  average.list[[paste0("Ctrl_",f)]] <- average.Ctrl # paste0 funktion checken
  
  cols.RNAse <- which(fraction == f & treatment == "RNAse")
  average.RNAse <- rowMeans(MS_Table[,cols.RNAse])
  average.list[[paste0("RNAse_",f)]] <- average.RNAse
}

MS_Table_Averages <- as.data.frame(average.list) #convert list to dataframe
rownames(MS_Table_Averages) <- rownames(MS_Table) #assign Protein IDs to average values

#Define new order of columns ("levels" works in alphabetic order, not useful for us)
fractions <- paste0("Fraction_", 1:25)

ordered_names <- as.vector(rbind(
  paste0("Ctrl_", fractions),
  paste0("RNAse_", fractions)
))

MS_Table_Averages <- MS_Table_Averages[, ordered_names]
head(MS_Table_Averages)
```
## Normalization to 100 
Create a new dataframe in which the values for each protein are scaled so that the distribution within the Ctrl and RNAse conditions each sums to 100
```{r}
# Split up Control and RNAse values 
ctrl_cols <- grep("^Ctrl_", colnames(MS_Table_Averages)) # grep function genauer schauen 
rnase_cols <- grep("^RNAse_", colnames(MS_Table_Averages))
# Normalization of each group to 100 
ctrl_norm <- MS_Table_Averages[, ctrl_cols] / rowSums(MS_Table_Averages[, ctrl_cols]) * 100
rnase_norm <- MS_Table_Averages[, rnase_cols] / rowSums(MS_Table_Averages[, rnase_cols]) * 100
# Combine in one table 
MS_Table_Norm <- cbind(ctrl_norm, rnase_norm)
MS_Table_Norm <- MS_Table_Norm[, colnames(MS_Table_Averages)]
head(round(MS_Table_Norm, 2))
# Verify the calculation with one example; the row sum should be ~200 (Ctrl 100% + RNAse 100%)
rowSums(MS_Table_Norm["1433B_HUMAN", ]) 
```

## Testung auf Normalverteilung 
--> work in progress, nicht sicher ob wir das direkt schon brauchen 
--> hab nur bisschen rumprobiert ---> Bin mir wirklich nicht sicher ob das so stimmt, muss ich nochmal anschauen, aber bin zu müde, möchte es aber hier schon mal speichern 
--> Note: QQ Plots für Normalverteilung 
```{r}
# Pakete laden 
library(dplyr)

# Leere Liste für Zwischenspeicherung 
results_list <- list()
counter <- 1

# Proteine durchlaufen
for (protein in rownames(MS_Table)) {
  
  for (fraction_num in 1:25) {
    
    # Die korrekten Spaltennamen für Ctrl generieren
    cols_ctrl <- paste0("Fraction", fraction_num, "_Ctrl_Rep", 1:3)
    
    # Prüfen ob alle Spalten existieren 
    existing_cols <- cols_ctrl[cols_ctrl %in% colnames(MS_Table)]
    
    if(length(existing_cols) == 3){
      
      # Werte extrahieren
      protein_values <- as.numeric(MS_Table[protein, existing_cols])
      
      # Nur testen, wenn es Streuung gibt
      if (length(unique(protein_values)) > 1) {
        shapiro_result <- shapiro.test(protein_values)
        shapiro_W <- shapiro_result$statistic
        shapiro_p <- shapiro_result$p.value
      } else {
        shapiro_W <- NA
        shapiro_p <- NA
      }
      
      # Zwischenspeichern
      results_list[[counter]] <- data.frame(
        Protein_ID = protein,
        Fraction = fraction_num,
        Shapiro_W = shapiro_W,
        Shapiro_p = shapiro_p
      )
      counter <- counter + 1
    }
  }
}

# Am Ende alles zusammenfügen
shapiro_results <- do.call(rbind, results_list)

# Entscheidung über Normalverteilung ergänzen
shapiro_results$Is_Normal_Distributed <- shapiro_results$Shapiro_p >= 0.05

# Ergebnisse ausgeben
head(shapiro_results)

# Übersicht wie viele normalverteilt
table(shapiro_results$Is_Normal_Distributed)



```

## Plotting a protein with normalised data (Notfitted)
```{r}
# Protein auswählen
protein_of_interest <- "A2MG_HUMAN" # hier dein Protein einsetzen

# Zeile für das Protein extrahieren
protein_row <- MS_Table_Norm[rownames(MS_Table_Norm) == protein_of_interest, ]

# Vektoren für Ctrl und RNAse erstellen
ctrl_values <- as.numeric(protein_row[seq(1, 49, by=2)])
rnase_values <- as.numeric(protein_row[seq(2, 50, by=2)])

# Fraktionen
fractions <- 1:25

# Plot
plot(fractions, ctrl_values, type="o", col="green", ylim=range(c(ctrl_values, rnase_values)),
     xlab="Fraction", ylab="Normalized Intensity", main=protein_of_interest)
lines(fractions, rnase_values, type="o", col="red")
legend("topright", legend=c("Ctrl", "RNAse"), col=c("green", "red"), lty=1, pch=1)
```




# Data Analysis
## Gaussian Fitting

```{r}
# Load package to use a sturdy fuction for gaussian fitting, that also works with critical starting values and sloping curves

library(minpack.lm)

# Build multi gaussian sumfuction up to 3 peaks (for later use)
# note: A = amplitude (height of peak), µ = mean (peak position); sigma = standard deviation (width of peak), x = fraction
# we can exclude the normalization factor, since our data is already normalized
# for more than one peak we need to sum up the gaussian curves of multiple peaks
# for the 2nd /3rd peak we are using default values, so we can also use the function for one peak

multi_gauss <- function(x, A1, mu1, sigma1,
                          A2 = 0, mu2 = 0, sigma2 = 1,
                          A3 =0, mu3 = 0, sigma3 = 1) {
    A1 * exp(-(x - mu1)^2 / (2 * sigma1^2)) + 
    A2 * exp (-(x - mu2)^2 / (2* sigma2^2)) + 
    A3 * exp(-(x - mu3)^2 / (2* sigma3^2))
  }

# build fuction to determin of number of peaks on raw data (for later use)
# threshold t is the minimal peak hight we are acepting (3% of maximal intensity, the rest ist noise) <- has proven to be a good limit
# note: diff() computes the slope between to points, sign() then gives the sign of the slope +1/0/-1, if slope changes from positive to negative diff() between +1 and -1 = -2

t = max(y) * 0.03 
find_peaks <- function(y, threshold = t) { 
  peaks <- which(diff(sign(diff(y))) == -2) + 1 #(+1 shifts index back)
  peaks[y[peaks]>= threshold] # [peaks] = peak intensität <- only those over thresohold
}

# create list for results

fit_results <- list()

# x-achsis for fited curves (fraction 1-25)

x <- 1:25

# fitting of every protein (Ctrl and RNAse) using for-loops
# for loop that goes through every protein/row, extracts the Ctrl values and RNAse and saves them in seperate vectors

for (p in seq_len(nrow(MS_Table_Norm))) {
  row_vals <- as.numeric(MS_Table_Norm [p,])
  ctrl_vals <- row_vals[seq(1, 50, by =2)]
  rnase_vals <- row_vals[seq(2, 50, by=2)]
  
  #create emty list for results of this protein
  
  results_row <- list()
  
  # second for loop that first works with Ctrl, then RNAse values of protein
  # with cond and vector c("Ctrl", "RNAse"), we are computing the for loop to run exactly two times, first under condition "Ctrl" then under condition "RNAse"
  # in the first loop under "Ctrl" the ctrl_values are used, then in the second loop the rnase_vals
  #
  for (cond in c("Ctrl", "RNAse")) {
    y <- if (cond == "Ctrl") ctrl_vals else rnase_vals 
    
    # finding peaks, if no peaks are detected --> fallback mechanism: find maximum intensity and asign fraction as peak position
    
    peaks <- find_peaks(y)
    if(length(peaks) == 0) {
      peaks <- which.max(y)
    }
    
    #determine how many peaks have been found, but use 3 at a max
    
    n_peaks <- min(length(peaks),3)
    
    # extract intensity values for each peak as starting values for A (y[peaks]) and fraction of each peak as starting value for mu (x[peaks])
    
    y_peaks <- y[peaks]
    x_peaks <- x[peaks]
    
    #define start values for up to three peaks using if clauses; sigma = 2 was an estimate that has proven to be a good starting value, since there are 25 fractions
    
    starts <- list(A1 = y_peaks[1], mu1 = x_peaks[1], sigma1 = 2)
    if (n_peaks >= 2) {
      starts <- c(starts, list(A2 = y_peaks[2], mu2 = x_peaks[2], sigma2 = 2)) }
      else {
        starts <- c(starts, list(A2 = 0, mu2 = 0, sigma2 = 2))}
    if (n_peaks == 3) {
      starts <- c(starts, list(A3 = y_peaks[3], mu3 = x_peaks[3], sigma3 = 2)) }
      else {
        starts <- c(starts, list(A3 = 0, mu3 = 0, sigma3 = 2))}

  
    # fitting with our multi gaussian fuction and try(), collect fit data in vector "fit"
    # using if clauses to go through every possibility: 1, 2,  or 3 peaks, and build a model with 1 up to three gaussian curves
    # we can't use multi_gauss with one peak, so we fit those with a normal gauss function (has proven to be necessary)
    # nlsLM = function that fits our gaussian curves formular /function we are giving "y ~..." (this is a nonlinear fitting fuction)
    # we need a lower and a upper limit, since in extreme cases, the estimation can be unrealistic (proven)
    # we are using "maxiter = 500" , meaning that the function will try to fit until 500 iterations and not break of earlier/longer search time (proven to be needed, since the function would terminate many estimations, that could be successful)
    # not all fits ar going to be successful:
    # "warnOnly" guarantees that the code keeps running, even if the fitting of a protein is not successful (happens for a few proteins)
    # function try() is another important protective measure, to ensure, that if "try" was not successful, the code keeps running, and there is only an error message for this protein (silent = TRUE <- error message not shown in console) 
    
    if (n_peaks == 1) {
      fit <- try(nlsLM(y ~ A1 * exp(-((x - mu1)^2) / (2 * sigma1^2)),
                       start = list(A1 = y_peaks[1], mu1 = x_peaks[1], sigma1 = 2),
                                    lower = c(A1 = 0, mu1 = 1, sigma1 = 0.3),
                                    upper = c(A1 = Inf, mu1 = 25, sigma1 = 5),
                       control = list(maxiter = 500, warnOnly = TRUE)
                       ), 
                 silent = TRUE)
      } 
    else if (n_peaks == 2) {
      fit <- try(nlsLM(y ~ multi_gauss(x, A1, mu1, sigma1, A2, mu2, sigma2),
                       start = list(
                         A1 = y_peaks[1], mu1 = x_peaks[1], sigma1 = 2,
                         A2 = y_peaks[2], mu2 = x_peaks[2], sigma2 = 2),
                       lower = c(A1 = 0, mu1 = 1, sigma1 = 0.3,
                                 A2 = 0, mu2 = 1, sigma2 = 0.3),
                       upper = c(A1 = Inf, mu1 = 25, sigma1 = 5,
                                 A2 = Inf, mu2 = 25, sigma2 = 5),
                       control = list(maxiter = 500, warnOnly = TRUE)
                       ), 
                 silent = TRUE)
      } 
    else {fit <- try(nlsLM(y ~ multi_gauss(x, A1, mu1, sigma1, A2, mu2, sigma2, A3, mu3, sigma3),
                           start = list(
                              A1 = y_peaks[1], mu1 = x_peaks[1], sigma1 = 2,
                             A2 = y_peaks[2], mu2 = x_peaks[2], sigma2 = 2,
                             A3 = y_peaks[3], mu3 = x_peaks[3], sigma3 = 2),
                           lower = c(A1 = 0, mu1 = 1, sigma1 = 0.3,
                                     A2 = 0, mu2 = 1, sigma2 = 0.3,
                                     A3 = 0, mu3 = 1, sigma3 = 0.3),
                           upper = c(A1 = Inf, mu1 = 25, sigma1 = 5,
                                     A2 = Inf, mu2 = 25, sigma2 = 5,
                                     A3 = Inf, mu3 = 25, sigma3 = 5),
                           control = list(maxiter = 500, warnOnly = TRUE)
                           ), 
                     silent = TRUE)
   }
    
    # collect results for this protein in results_row and add to fit_results list
    # if clauses for when there is no "try-error" message (successful fit) for protein and when there is an error (n)
    # "coef" extracts parameter values (A1, mu1, ../ coefficients)
    # give parameters name in loist results_row and assign computed values 
    # "paste0" takes a text frgment given and puts them together without spaces
    # [[]] needed to access a specific value, not a list
    # assign new variable "Fit_OK_ " to result list to show successful and not successfully fitted proteins
    
    if(!inherits(fit, "try-error")) {
      coef_vals <- coef(fit)
      for (i in names(coef_vals)) {
        results_row[[paste0(i,"_", cond)]] <- coef_vals[i]
      }
      results_row[[paste0("Fit_OK_", cond)]] <- TRUE
      results_row[[paste0("n_peaks_", cond)]] <- n_peaks
    }
    else {
      results_row[[paste0("Fit_OK_", cond)]] <- FALSE
      results_row[[paste0("n_peaks_", cond)]] <- 0
    }
  }
  # close for loop, and save protein data in list fit_results
  fit_results[[p]] <- results_row
}

# make data.frame out of list (quite complicated, cause not every protein has the same amount of values)
# going through data for each protein x in fit_results
# if there is no value for a specific field/parameter (A1, mu1,...) we are assigning "NA" (%in% = "is included in")

rows_df <- lapply(fit_results, function(x){
  fields <- c("A1", "mu1", "sigma1", "A2", "mu2", "sigma2", "A3", "mu3", "sigma3")
  for (cond in c("Ctrl", "RNAse")) {
    for (f in fields) {
      key <- paste0(f, "_", cond)
      if(!(key %in% names(x))) {
        x[[key]] <- NA
      }
    }
  }
  as.data.frame(x)
})

#assemble all data in one dataframe
# problem: rows_df is a list of one row dataframes (since we used lapply), we need to split up the list with do.call, and bind all dataframes with rbind
MS_Data_Fitted <- do.call(rbind, rows_df)
rownames(MS_Data_Fitted) <- rownames(MS_Table_Norm)
head(MS_Data_Fitted)

# Number of proteins that where successfully fitted
sum(MS_Data_Fitted$Fit_OK_Ctrl & MS_Data_Fitted$Fit_OK_RNAse) 

# Vector with all non-successfully fitted proteins
Protein_IDs_fit_error <- rownames(subset(MS_Data_Fitted, Fit_OK_Ctrl == FALSE | Fit_OK_RNAse == FALSE))
```
## Plotting a Protein
```{r}
#Choose protein
protein <- "A2MG_HUMAN"  

#Was gausian fitting successful for this protein?
!protein %in% Protein_IDs_fit_error

#Select protein data in MS_Data_Fitted 
row <- MS_Data_Fitted[rownames(MS_Data_Fitted) == protein, , drop = FALSE]

#x-achsis for the plot
x_vals <- seq(1, 25, by = 0.1)

#Compute function for gauss curve with all relevant parameters
#create vector y with as much values as x (intensity_values)
# we extract data for A,mu,etc. through columnname, recreated by paste0 function
# see that we use y to sum um the intensity-values for all peaks /for each gauss curve per peak 
gauss_curve <- function(row, condition, x) {
  y <- rep(0, length(x))
  n_peaks <- row[[paste0("n_peaks_", condition)]]
  for (i in 1:n_peaks) {
    A <- row[[paste0("A", i, "_", condition)]]
    mu <- row[[paste0("mu", i, "_", condition)]]
    sigma <- row[[paste0("sigma", i, "_", condition)]]
    y <- y + A * exp(-((x - mu)^2) / (2 * sigma^2))
  }
  return(y)
}

# compute intensity values for Ctrl and RNAse
y_ctrl <- gauss_curve(row, "Ctrl", x_vals)
y_rnase <- gauss_curve(row, "RNAse", x_vals)

# Plot
# ylim is for focus on intensity range (not 100% but only important range)
# fit iensitenity ≠ ms_intensity!!! addition of gaus values for the peaks, make it possible that we have more than 100%
plot(x_vals, y_ctrl, type = "l", col = "green", lwd = 2,
     ylim = range(c(y_ctrl, y_rnase), na.rm = TRUE), 
     xlab = "Fraction", ylab = "Fit-Intensity",
     main = paste("Gaussian-Fits for", protein))
lines(x_vals, y_rnase, col = "red", lwd = 2)

legend("topright", legend = c("Ctrl", "RNAse"),
       col = c("green", "red"), lwd = 2)

```

######## BackUP
Idee Correlation: 
- mit allen 3 Reps und Proteinenanzahl die wir signifikant empfinden (langsam rantasten, wann sieht man keinen Unterschied mehr) --> Sofia macht R-Werte etc  
- schöne Heatmap :)))) --> Cihan macht Korrelationsmatrix und Heatmap 
- zwar schwieriger wahrscheinlicher, aber cooler 

Idee Normalisierung der Daten: 
- MS-Tabel komplett normalisieren 
- einfacher, aber nicht so schön 



## Reproducibility Analysis
```{r}
# Leere Liste für Ergebnisse
full_correlation_results <- data.frame(
  Treatment = character(),
  Replicate_1 = character(),
  Fraction_1 = character(),
  Replicate_2 = character(),
  Fraction_2 = character(),
  Spearman_r = numeric(),
  stringsAsFactors = FALSE
)

# Alle Treatments durchgehen (Ctrl und RNAse)
for (treatment in c("Ctrl", "RNAse")) {
  
  # Alle Replikat-Fraktions-Kombinationen erzeugen
  combo1 <- expand.grid(Rep = 1:3, Fraction = 1:25)
  combo2 <- expand.grid(Rep = 1:3, Fraction = 1:25)
  
  # Für jede mögliche Kombination
  for (i in 1:nrow(combo1)) {
    for (j in 1:nrow(combo2)) {
      
      rep1 <- combo1$Rep[i]
      frac1 <- combo1$Fraction[i]
      rep2 <- combo2$Rep[j]
      frac2 <- combo2$Fraction[j]
      
      # Spaltenpositionen finden
      col1 <- which(replicate == paste0(treatment, "_Rep", rep1) & fraction == paste0("Fraction_", frac1))
      col2 <- which(replicate == paste0(treatment, "_Rep", rep2) & fraction == paste0("Fraction_", frac2))
      
      # Pearson Korrelation berechnen
      cor_value <- cor(MS_Table[, col1], MS_Table[, col2], method = "spearman", use = "complete.obs")
      
      # Ergebnis speichern
      full_correlation_results <- rbind(full_correlation_results, data.frame(
        Treatment = treatment,
        Replicate_1 = paste0("Rep", rep1),
        Fraction_1 = paste0("Fraction_", frac1),
        Replicate_2 = paste0("Rep", rep2),
        Fraction_2 = paste0("Fraction_", frac2),
        Spearman_r = cor_value
      ))
    }
  }
}

# Ergebnis anschauen
head(full_correlation_results)


library(tidyverse)
library(pheatmap)

# Erstmal eine Spalte erzeugen für die beiden Achsen
full_correlation_results <- full_correlation_results %>%
   mutate(Row = paste0(Replicate_1, "_F", gsub("Fraction_", "", Fraction_1)),
         Col = paste0(Replicate_2, "_F", gsub("Fraction_", "", Fraction_2)))

# Wir machen das einmal für ein Treatment, z.B. "RNAse"
treatment_to_plot <- "RNAse"

# Tabelle filtern
heatmap_data <- full_correlation_results %>%
  filter(Treatment == treatment_to_plot) %>%
  select(Row, Col, Spearman_r)

# In Matrix umwandeln
heatmap_matrix <- heatmap_data %>%
  pivot_wider(names_from = Col, values_from = Spearman_r, values_fill = NA) %>%
  column_to_rownames("Row") %>%
  as.matrix()

# Jetzt Heatmap zeichnen
pheatmap(heatmap_matrix,
         main = paste("Spearman Correlation Heatmap -", treatment_to_plot),
         cluster_rows = FALSE, 
         cluster_cols = FALSE, 
         show_rownames = TRUE, 
         show_colnames = TRUE,
         fontsize_row = 4,
         fontsize_col = 4)

```

#looking at standart deviation and mean to get an idea 

```{r}


# create empty vectors to store the values

sd_values <- numeric(25)
mean_values <- numeric(25)

# create loop for all 25 fractions 
for (i in 1:25) {
  # Define replicate labels ( RNAse or Ctrl)
  reps <- paste0("RNAse_Rep", 1:3)
  
  # Filter just the current fraction and replicates
  subset_data <- data[data$fraction == paste0("Fraction_", i) & data$replicate %in% reps, ]
  
  # Extract abundance values
  values <- subset_data$abundance
  
  # Compute standard deviation + compute mean
  sd_values[i] <- sd(values)
  
  mean_values[i] <- mean(values)
}

# Create result table 
result_tablesd <- data.frame(
  Fraction = paste0("Fraction_", 1:25),
  SD = sd_values
)
result_tablesd

result_tablemean <- data.frame(
  Fraction = paste0("Fraction_", 1:25),
  MEAN = mean_values
)
result_tablemean

```

##trzing to run Pearson correlation for all proteins => for now between Repetitions Rep1 and Rep2 across 25 fractions for Ctrl and RNase seperatly 

#1) frist creating a long format table with=> Protein names repeat themselfs for all combinations maybe this is the problem 


```{r}
# Load necessary packages
library(dplyr)
library(tidyr)

#naming coloum for Protein names with Protein so i can run my code => this is ugly open for suggestions

MS_Table$Protein <- rownames(MS_Table)
MS_Table2 <- MS_Table %>% relocate(Protein)
head(MS_Table2)

# Step 2: Pivot longer — convert the wide columns into long format
# The first column is protein names, so we keep it as id

ms_long <- MS_Table %>%
  pivot_longer(
    cols = -Protein,  # all columns except the first (protein names)
    names_to = "Condition",  # temporary column to store original column names
    values_to = "Value"      # this column will store the measured values
  )

# Step 3: Separate 'Condition' into Fraction, Treatment, and Replicate
ms_long <- ms_long %>%
  separate(
    col = Condition,
    into = c("Fraction", "Treatment", "Replicate"),
    sep = "_"
  )

# Step 4: Extract the numeric fraction number (since it's like 'Fraction1')
ms_long <- ms_long %>%
  mutate(
    Fraction = as.numeric(sub("Fraction", "", Fraction))
  )

# Step 5: Rename first column to "Protein" (if it's not already)
names(ms_long)[1] <- "Protein"

# Optional: Check result
head(ms_long)
rownames(ms_long)


# Now you have your tidy table:
# Protein | Fraction | Treatment | Replicate | Value



```


#2) with table trying to run pearson correlation 

```{r}

library(dplyr)
library(tidyr)

# First: keep only the replicates we want
filtered <- ms_long %>%
  filter(Replicate %in% c("Rep1", "Rep2"),
         Treatment %in% c("Ctrl", "RNAse"),
         Fraction %in% paste0("Fraction_", 1:25))

# Then: calculate correlation per protein + treatment
results <- filtered %>%
  group_by(Protein, Treatment) %>%
  pivot_wider(
    names_from = Replicate,
    values_from = Value,
    values_fill = list(abundance = 0)   # fill missing values with 0
  ) %>%
  summarise(correlation = cor(Rep1, Rep2), .groups = "drop")  # here something dosent work=> Rep2 is not recognized 

# Print results
print(results)

ms_long %>%
  count(Protein, Treatment)



```

