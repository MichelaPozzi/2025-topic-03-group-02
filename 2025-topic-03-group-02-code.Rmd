---
title: "2025-topic-03-group-02-code"
output: html_document
date: "2025-05-16"
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Group X Data Analysis Project 

# Project Overview
### Goal: 

- Briefly describe the purpose of this analysis

## Libraries 

- Briefly explain for which functions/steps are these needed

```{r, message=FALSE, warning=FALSE}

```

#Loading MS-Data
```{r}
MS_Table <- read.table("RDeeP_HeLa_Mitosis.csv", header = TRUE, row.names = 1, sep = ";")
```

# Data Cleanup
## Despription of the Data - Lina
### Goal: 
- Get a feeling for the dataset and decide on necessary clean-up steps
```{r}
library(glue)

glue("Number of proteins analysed /rows : {nrow(MS_Table)}")
glue("Number of columns: {ncol(MS_Table)} (25 fractions with each 3 replicates for Ctrl and RNase treatment)")
glue("Classifikation of variables: {unique(sapply(MS_Table, class))}")
glue("Any missing values: {any(is.na(MS_Table))}")
glue("Overall minimum intenstity: {min(MS_Table)}")
glue("Overall maximum intenstity: {max(MS_Table)}")
```

#Normalisation
### Goal: 
- Generate a new dataframe with replicate-averaged intensity values,scaled so that each protein's total intensity sums to 100 across all fractions (fopr Ctrl and RNase)
- Build a function to plot protein profiles using the normalized data  
- Confirm experimental reproducibility by comparing intensity profiles across replicates

## Normalization of triplicates - Lina
```{r}
# Create a metadata dataframe with factor columns that map each MS_Table column to its experimental treatment, replicate, and fraction number
treatment <- factor(rep(c("Ctrl", "RNase"), each = 3, length.out = 150))
replicate <- factor(rep(c("Ctrl_Rep1", "Ctrl_Rep2", "Ctrl_Rep3", "RNase_Rep1","RNase_Rep2", "RNase_Rep3"),25))
fraction <- factor(rep(paste0("Fraction_", 1:25), each = 6))

data <- data.frame(rownames = colnames(MS_Table),treatment = treatment, replicate = replicate, fraction = fraction)

# Iterate over all fraction levels: for each fraction, select replicate columns of Ctrl and RNase, compute row-wise means and store them in previously created list
average.list <- list()

for (f in levels(fraction)) {
  
  cols.Ctrl <- which(fraction == f & treatment == "Ctrl") 
  average.Ctrl <- rowMeans(MS_Table[,cols.Ctrl]) 
  average.list[[paste0("Ctrl_",f)]] <- average.Ctrl 
  
  cols.RNase <- which(fraction == f & treatment == "RNase")
  average.RNase <- rowMeans(MS_Table[,cols.RNase])
  average.list[[paste0("RNase_",f)]] <- average.RNase
}

# Convert the list of averages to a data frame and restore rownames
MS_Table_Averages <- as.data.frame(average.list) 
rownames(MS_Table_Averages) <- rownames(MS_Table) 

# Reorder columns: alphabetic order of 'levels()' breaks fraction sequence,
# so construct correct order manually (Ctrl_1 to Ctrl_25, then RNase_1 to RNase_25)
fractions <- paste0("Fraction_", 1:25)
ordered_names <- as.vector(rbind(
  paste0("Ctrl_", fractions),
  paste0("RNase_", fractions)
))

MS_Table_Averages <- MS_Table_Averages[, ordered_names]
```

## Normalization to 100 - Cihan
### Goal: 
- Create a new dataframe in which the values for each protein are scaled so that the distribution within the Ctrl and RNAse conditions each sums to 100
- Will help with easier visualtization of the plots
```{r}
# Split up Control and RNAse values 
ctrl_cols <- grep("^Ctrl_", colnames(MS_Table_Averages)) # grep function genauer schauen 
rnase_cols <- grep("^RNase_", colnames(MS_Table_Averages))

# Normalization of each group to 100 
ctrl_norm <- MS_Table_Averages[, ctrl_cols] / rowSums(MS_Table_Averages[, ctrl_cols]) * 100
rnase_norm <- MS_Table_Averages[, rnase_cols] / rowSums(MS_Table_Averages[, rnase_cols]) * 100

# Combine in one table 
MS_Table_Norm <- cbind(ctrl_norm, rnase_norm)
MS_Table_Norm <- MS_Table_Norm[, colnames(MS_Table_Averages)]
head(round(MS_Table_Norm, 2))

# Verify the calculation with one example; the row sum should be ~200 (Ctrl 100% + RNAse 100%)
rowSums(MS_Table_Norm["1433B_HUMAN", ]) 
```

## Plotting a Protein - Lina
### Goal: 
- Build a function to plot normalized intensity values of Ctrl and RNase across all fractions
```{r}
plot_protein <- function(x) {
  
  #extract data, define all variables and range of x- and y-achsis
  protein_of_interest <- x 
  protein_row <- MS_Table_Norm[rownames(MS_Table_Norm) == protein_of_interest, ]
  ctrl_values <- as.numeric(protein_row[seq(1, 49, by=2)])
  rnase_values <- as.numeric(protein_row[seq(2, 50, by=2)])
  fractions <- 1:25
  max_val <- max(ctrl_values, rnase_values, na.rm = TRUE)
  ylim_range <- c(0, max_val * 1.2)

  #core plot function using crtl_values
  plot(fractions, ctrl_values, type="o", pch=20, lty=1, lwd = 1.5,  col="forestgreen", ylim= ylim_range,
       xlab="Fraction", ylab="Normalized Intensity", main= protein_of_interest, axes = FALSE)
       
  #add line for rnase_values
  lines(fractions, rnase_values, type="o",pch =20, lty=1, lwd = 1.5,  col="firebrick3")
  
  #color area under the curve
  polygon(c(fractions, rev(fractions)), 
          c(ctrl_values, rep(0, length(ctrl_values))), 
          col=adjustcolor("forestgreen", alpha.f=0.1), border=NA)
  
  polygon(c(fractions, rev(fractions)), 
          c(rnase_values, rep(0, length(rnase_values))), 
          col=adjustcolor("firebrick3", alpha.f=0.1), border=NA)
  
  #add x- and y-achsis with correct lables
  axis(1, at = 1:25, labels = 1:25, cex.axis = 0.7)
  axis(2, cex.axis = 0.7, las =2)
  grid(nx = NULL, ny = NULL, col = "lightgray", lty = "dotted", lwd = 0.8)

  #add legend
  legend("topright", legend=c("Ctrl", "RNase"), col=c("forestgreen", "firebrick3"), 
         lty=1, lwd = 1.5,  pch=20, bg = "white", bty = "o", box.col = NA, horiz = TRUE)
}

#example
plot_protein("RL27_HUMAN") 
```


## Reproducibility Analysis : Cihan and Sofia 
### Goal: 
- Assess reproducibility of MS-based protein measurements for both treatments 
- Visualize how consistent protein ranking patterns are across all replicates and fractions
- We expect a diagonal showing our r-value = 1, while the other combinations should show lower correlation
```{r}
# Create empty dataframe for correlation 
full_correlation_results <- data.frame(
  Treatment = character(),
  Replicate_1 = character(),
  Fraction_1 = character(),
  Replicate_2 = character(),
  Fraction_2 = character(),
  Spearman_r = numeric(),
  stringsAsFactors = FALSE
)

# iterate over both Ctrl and RNase Treatment 
for (treatment in c("Ctrl", "RNase")) {
  
  # Create all possible rep-fraction combinations
  combo1 <- expand.grid(Rep = 1:3, Fraction = 1:25)
  combo2 <- expand.grid(Rep = 1:3, Fraction = 1:25)
  
  # iterate for every possible combination
  for (i in 1:nrow(combo1)) {
    for (j in 1:nrow(combo2)) {
      
      rep1 <- combo1$Rep[i]
      frac1 <- combo1$Fraction[i]
      rep2 <- combo2$Rep[j]
      frac2 <- combo2$Fraction[j]
      
      # Find right column position 
      col1 <- which(replicate == paste0(treatment, "_Rep", rep1) & fraction == paste0("Fraction_", frac1))
      col2 <- which(replicate == paste0(treatment, "_Rep", rep2) & fraction == paste0("Fraction_", frac2))
      
      # calculate Spearmen correlation
      cor_value <- cor(MS_Table[, col1], MS_Table[, col2], method = "spearman", use = "complete.obs")
      
      # safe results in dataframe
      full_correlation_results <- rbind(full_correlation_results, data.frame(
        Treatment = treatment,
        Replicate_1 = paste0("Rep", rep1),
        Fraction_1 = paste0("Fraction_", frac1),
        Replicate_2 = paste0("Rep", rep2),
        Fraction_2 = paste0("Fraction_", frac2),
        Spearman_r = cor_value
      ))
    }
  }
}


head(full_correlation_results)


library(tidyverse)
library(pheatmap)

# create column for each axis 
full_correlation_results <- full_correlation_results %>%
   mutate(Row = paste0(Replicate_1, "_F", gsub("Fraction_", "", Fraction_1)),
         Col = paste0(Replicate_2, "_F", gsub("Fraction_", "", Fraction_2)))

# we select treament RNase for our first heatmap
treatment_to_plot_RNase <- "RNase"

# filter table for selected treatment: RNase
heatmap_data_RNase <- full_correlation_results %>%
  filter(Treatment == treatment_to_plot_RNase) %>%
  select(Row, Col, Spearman_r)

# convert into matrix 
heatmap_matrix_RNase <- heatmap_data_RNase %>%
  pivot_wider(names_from = Col, values_from = Spearman_r, values_fill = NA) %>%
  column_to_rownames("Row") %>%
  as.matrix()

# create heatmap for RNase treatment
print(pheatmap(heatmap_matrix_RNase,
         main = paste("Spearman Correlation Heatmap -", treatment_to_plot_RNase),
         cluster_rows = FALSE, 
         cluster_cols = FALSE, 
         show_rownames = TRUE, 
         show_colnames = TRUE,
         fontsize_row = 4,
         fontsize_col = 4))

# we select treament Ctrl for our second heatmap
treatment_to_plot_Ctrl <- "Ctrl"

# filter table for selected treatment: Ctrl
heatmap_data_Ctrl <- full_correlation_results %>%
  filter(Treatment == treatment_to_plot_Ctrl) %>%
  select(Row, Col, Spearman_r)

# convert into matrix 
heatmap_matrix_Ctrl <- heatmap_data_Ctrl %>%
  pivot_wider(names_from = Col, values_from = Spearman_r, values_fill = NA) %>%
  column_to_rownames("Row") %>%
  as.matrix()

# create heatmap for Ctrl treatment
print(pheatmap(heatmap_matrix_Ctrl,
         main = paste("Spearman Correlation Heatmap -", treatment_to_plot_Ctrl),
         cluster_rows = FALSE, 
         cluster_cols = FALSE, 
         show_rownames = TRUE, 
         show_colnames = TRUE,
         fontsize_row = 4,
         fontsize_col = 4))

```

# Data Analysis
### Goal:
- Finding RBPs in our dataset 
- Filtering them for only active in mitosis

## Peak Detection in Normalized Ctrl/RNase Profiles  - Lina
### Goal:
- Identify peaks in normalized intensity profiles (Ctrl and RNase)
- Extract number of peaks, their positions and heights
- Store the results in a structured data frame for description of proteins
! NOTE: Peak data is not used for RBP identification.  
This step is purely descriptive. However, Peak_Data is later used for clustering and linear regression analysis.

```{r}
# Define x-axis
x <- 1:25

# Build function for peak detection using slope between fractions
# Detects internal peaks above a given threshold (default: 3% of max intensity)
# Note: Cannot detect peaks at positions 1 and 25 (manually handled below)
find_peaks <- function(y, threshold = max(y) * 0.03) { 
  peaks <- which(diff(sign(diff(y))) == -2) + 1 #(+1 shifts index back)
  peaks[y[peaks]>= threshold] 
}

# Initialize list to collect results per protein and iterate over all proteins (rows in MS_Table_Norm)
peak_results <- list()

for (p in seq_len(nrow(MS_Table_Norm))) {
  
  # Extract normalized values for Ctrl and RNase
  row_vals <- as.numeric(MS_Table_Norm [p,])
  ctrl_vals <- row_vals[seq(1, 50, by =2)]
  rnase_vals <- row_vals[seq(2, 50, by=2)]
  
  results_row <- list()
  
  # Process both conditions in one loop
  for (cond in c("Ctrl", "RNase")) {
    y <- if (cond == "Ctrl") ctrl_vals else rnase_vals
    threshold <- max(y, na.rm = TRUE) * 0.03
    
    peaks <- find_peaks(y)
    
    # Manually check for peak at position 1 and 25
    if (length(peaks) == 0) {
      peaks <- numeric(0)
      }
    if (!is.na(y[1]) && !is.na(y[2]) && y[1] > y[2] && y[1] >= threshold) {
      peaks <- c(1, peaks)
      }
    if (!is.na(y[25]) && !is.na(y[24]) && y[25] > y[24] && y[25] >= threshold) {
      peaks <- c(peaks, 25)
    }
    # Fallback: If no peaks detected at all, use global maximum
    if(length(peaks) == 0) {
      peaks <- which.max(y)
      }
    
    # Limit number of stored peaks to max. 6
    n_peaks <- min(length(peaks), 6)
    
    # Extract peak height and peak position
    y_peaks <- y[peaks]
    x_peaks <- x[peaks]

    # Store data for current protein (Number of peaks, peak heights and peak positions)
    results_row[[paste0("n_peaks_", cond)]] <- n_peaks
    
    for(n in seq_len(n_peaks)) {
    results_row[[paste0("peak", n, "_height_", cond)]] <- y_peaks[n]
    results_row[[paste0("peak", n, "_position_", cond)]] <- x_peaks[n]
    }
  }
  # Store result for current protein
  peak_results[[p]] <- results_row
}

# Fill missing values with NAs to allow binding all rows together
rows_df <- lapply(peak_results, function(x){
  columns <- c("peak1_height", "peak1_position", 
               "peak2_height", "peak2_position", 
               "peak3_height", "peak3_position", 
               "peak4_height", "peak4_position", 
               "peak5_height", "peak5_position", 
               "peak6_height", "peak6_position")
  for (cond in c("Ctrl", "RNase")) {
    for (c in columns) {
      key <- paste0(c, "_", cond)
      if(!(key %in% names(x))) {
        x[[key]] <- NA
      }
    }
  }
  as.data.frame(x)
})

# Combine all protein results into one data frame 
Peak_Data <- do.call(rbind, rows_df) #do.call bind used because rows_df is a list of dataframes
rownames(Peak_Data) <- rownames(MS_Table_Norm)

# Reorder columns: first n_peaks, then all peak heights and positions (Ctrl & RNase)
order <- c("n_peaks_Ctrl", "n_peaks_RNase")

for (i in 1:6) {
  order <- c(order, 
                 paste0("peak", i, "_height_Ctrl"),
                 paste0("peak", i, "_position_Ctrl"),
                 paste0("peak", i, "_height_RNase"),
                 paste0("peak", i, "_position_RNase"))
}

Peak_Data <- Peak_Data[, order]
```


# Shift Characteristics - Lina
To quantify positional shifts in protein profiles between Ctrl and RNase conditions, we calculate the Center of Mass (CoM) for each protein.
The CoM is a weighted average of all fraction positions, where weights are the normalized intensity values.

CoM is defined as:
   Σ(intensity × fraction) / Σ(intensity)

Since we did not apply Gaussian fitting, a direct peak-to-peak comparison between Ctrl and RNase was difficult and unreliable. 
Using the CoM allows us to include both position and intensity information and proofed to be a robust, single-value summary of the overall protein distribution.

Based on this, we calculate:
 - Shift distance: difference between CoM_Ctrl and CoM_RNase
 - Shift direction: +1 = left-shift, –1 = right-shift, 0 = no shift

! NOTE:CoM-based shift calculations were later repeated per replicate and used for statistical testing (t-test) to identify significantly shifting RBPs.
```{r}
# Initialize result vectors (one value per protein)
CoM_Ctrl <- numeric(nrow(MS_Table_Norm))
CoM_RNase <- numeric(nrow(MS_Table_Norm))
shift_distance <- numeric(nrow(MS_Table_Norm))
shift_direction <- numeric(nrow(MS_Table_Norm))

# Iterate over all proteins and calculate shift using center of mass
for (p in seq_len(nrow(MS_Table_Norm))) {
  
   # Extract normalized intensities for Ctrl and RNase
  row_vals <- as.numeric(MS_Table_Norm [p,])
  ctrl_vals <- row_vals[seq(1, 50, by =2)]
  rnase_vals <- row_vals[seq(2, 50, by=2)]
  
  # Calculate Center of Mass for both conditions
  CoM_Ctrl[p] <- sum(ctrl_vals * x) / sum(ctrl_vals)
  CoM_RNase[p] <- sum(rnase_vals * x) / sum(rnase_vals)
  
  # Compute shift distance and direction
  shift_distance[p] <- CoM_Ctrl[p] - CoM_RNase[p] 
  shift_direction[p] <- sign(shift_distance[p]) 
}

# Store results into a single dataframe
Shift_Data <- data.frame(
  CoM_Ctrl = CoM_Ctrl,
  CoM_RNase = CoM_RNase,
  shift_distance = shift_distance,
  shift_direction = shift_direction,
  row.names = rownames(MS_Table_Norm))
```

##T-Test
### First Normalization of whole MS_Table to 100 - Cihan
#### Goal: 
- To normalize the values of each replicate within each treatment (Ctrl and RNase) so that the total across all 25 fractions equals 100 per replicate.
- This ensures comparability between replicates by removing global intensity differences, and prepares the data for center of mass (CoM) calculation and statistical testing (t-test) later on.
```{r}
# Split up all Ctrl and RNAse values and their individual Reps 
ctrl_cols_t1 <- grep("_Ctrl_Rep1", colnames(MS_Table))
ctrl_cols_t2 <- grep("_Ctrl_Rep2", colnames(MS_Table))
ctrl_cols_t3 <- grep("_Ctrl_Rep3", colnames(MS_Table))
RNase_cols_t1 <- grep("_RNase_Rep1", colnames(MS_Table))
RNase_cols_t2 <- grep("_RNase_Rep2", colnames(MS_Table))
RNase_cols_t3 <- grep("_RNase_Rep3", colnames(MS_Table))

# Normalization of each group to 100 
ctrl_norm_t1 <- MS_Table[, ctrl_cols_t1] / rowSums(MS_Table[, ctrl_cols_t1]) * 100
ctrl_norm_t2 <- MS_Table[, ctrl_cols_t2] / rowSums(MS_Table[, ctrl_cols_t2]) * 100
ctrl_norm_t3 <- MS_Table[, ctrl_cols_t3] / rowSums(MS_Table[, ctrl_cols_t3]) * 100
RNase_norm_t1 <- MS_Table[, RNase_cols_t1] / rowSums(MS_Table[, RNase_cols_t1]) * 100
RNase_norm_t2 <- MS_Table[, RNase_cols_t2] / rowSums(MS_Table[, RNase_cols_t2]) * 100
RNase_norm_t3 <- MS_Table[, RNase_cols_t3] / rowSums(MS_Table[, RNase_cols_t3]) * 100

# Combine in one table 
Norm_Data_for_t <- cbind(ctrl_norm_t1, RNase_norm_t1, ctrl_norm_t2, RNase_norm_t2, ctrl_norm_t3, RNase_norm_t3)

# In gewünschter Reihenfolge ordnen
fractions <- 1:25
reps <- 1:3
conditions <- c("Ctrl", "RNase") 


ordered_names <- c()

for (fraction in fractions) {
  for (rep in reps) {
    for (condition in conditions) {
      name <- paste0("Fraction", fraction, "_", condition, "_Rep", rep)
      ordered_names <- c(ordered_names, name)
    }
  }
}

Norm_Data_for_t <- Norm_Data_for_t[, ordered_names]
head(Norm_Data_for_t)
# Verify the calculation with one example; the row sum should be ~600 (3*Ctrl 100% + 3*RNAse 100%)
rowSums(Norm_Data_for_t["1433B_HUMAN", ]) 
```

### Caluclation of Center of mass (CoM) : Sofia 
### Goal:
- All dimensions of our data, such as multiple peak positions and heights, are simplified for later t-tests (only one value) by using Center of Mass (CoM) values. The CoM is calculated for all replicates and treatments and data comes from Norm_Data_for_t (normalised Data) and stored in a data frame. It represents the weighted average position of a signal: the sum of all fraction numbers multiplied by their intensity values, divided by the total intensity. This way, if a peak is "split" into two in one experiment but not in another, it should not affect the result significantly, as both would have similar CoM values. 
```{r}
# aufstellen von variablen  

fractions <- 1:25
conditions <- c("Ctrl", "RNase")
replicates <- c("Rep1", "Rep2", "Rep3")

#liste erstellen 

results_com <- list()

#looping through conditions and replicates as we want them all seperate

for (cond in conditions) {
  for (rep in replicates) {
    
#selecting colums with grep diesen strich verssteh ich nicht "chat sagt "makes one combined pattern with ORs (|) between them, so grep matches any of them."

    pattern <- paste0("^Fraction", fractions, "_", cond, "_", rep, "$")
    cols <- grep(paste(pattern, collapse="|"), colnames(Norm_Data_for_t), value = TRUE)  

    subdata <- Norm_Data_for_t[, cols]   
#storing coloums 

    subdata <- subdata[, order(as.numeric(gsub("Fraction(\\d+)_.*", "\\1", cols)))]  #extracts the fraction number from column names.

#center of mass calculation as discribed above

    com <- apply(subdata, 1, function(x) {
      sum(x * fractions) / sum(x)
    })
#store result in list 

    results_com[[paste(cond, rep, sep = "_")]] <- com
  }
}

#convert list to dataframe

CoM_Data_for_t <- as.data.frame(results_com)   # convert list into data frame

# Add correct rownames:
rownames(CoM_Data_for_t) <- rownames(Norm_Data_for_t)

# View the first few rows to check
head(CoM_Data_for_t)
```


### Calculating Shift-Values for T-Test - Lina
#### Goal: 
- Calculate deviation between CoM of Ctrl and CoM of RNase and store in df for t-test 
```{r}
# For each protein, subtract the RNase CoM from the corresponding Ctrl CoM across all three replicates to obtain replicate-wise shift distances.
# Columns 1–3 = Ctrl_Rep1–3, Columns 4–6 = RNase_Rep1–3 (in CoM_Data_for_t)
Shift_Data_for_t <- data.frame(
  shift_distance_rep1 = CoM_Data_for_t[, 1] - CoM_Data_for_t[, 4],
  shift_distance_rep2 = CoM_Data_for_t[, 2] - CoM_Data_for_t[, 5],
  shift_distance_rep3 = CoM_Data_for_t[, 3] - CoM_Data_for_t[, 6],
  row.names = rownames(CoM_Data_for_t)
)

# Count how many missing values (NA) are present across all shift distances. (proteins where CoM could not be calculated in at least one replicate)
sum(is.na(Shift_Data_for_t))
```

### T-Test - Cihan
#### Goal: 
- To statistically test whether proteins show a significant left-shift in their center of mass (CoM) distribution in RNase vs. Ctrl, indicating RNA-dependent localization.
- This is done by:
1. Applying the Shapiro-Wilk test first to ensure the shift values are normally distributed before running the t-test.
2. Testing if the shift distance is significantly greater than 1 using a one-sided t-test.
- Significant hits are categorized as RBPs.
```{r}
# create empty columns for statistical test results 
Shift_Data$shapiro_p <- NA
Shift_Data$normal_distributed <- NA
Shift_Data$p_value_ttest_filtered <- NA
Shift_Data$significant_ttest_filtered <- NA

# iterate over all proteins 
for (protein in rownames(Shift_Data_for_t)) {
  
  # extract shift distances for each replicate
  shift_values <- as.numeric(Shift_Data_for_t[protein, c("shift_distance_rep1", "shift_distance_rep2", "shift_distance_rep3")])
  
  # make sure that no NAs are present
  if (all(!is.na(shift_values))) {
    
    # check if all values are identical (no variance)
    if (length(unique(shift_values)) == 1) {
      
      # set normal distribution to TRUE if no variance is present
      Shift_Data[protein, "shapiro_p"] <- NA
      Shift_Data[protein, "normal_distributed"] <- TRUE
      
    } else {
      
      # perform Shapiro-Wilk test to check for normal distribution
      shapiro_result <- shapiro.test(shift_values)
      Shift_Data[protein, "shapiro_p"] <- shapiro_result$p.value
      Shift_Data[protein, "normal_distributed"] <- shapiro_result$p.value >= 0.05
    }
    
    # perfrom one-sided t-test if data is normal distributed
    if (Shift_Data[protein, "normal_distributed"] == TRUE) {
      
      test_result <- t.test(shift_values, mu = 1, alternative = "greater")
      
      Shift_Data[protein, "p_value_ttest_filtered"] <- test_result$p.value
      Shift_Data[protein, "significant_ttest_filtered"] <- ifelse(test_result$p.value < 0.05, TRUE, FALSE)
      
    } else {
      # no t-test applied if data is not normal distributed
      Shift_Data[protein, "p_value_ttest_filtered"] <- NA
      Shift_Data[protein, "significant_ttest_filtered"] <- NA
    }
  }
}

# summary of proteins regarding normal distribution
table(Shift_Data$normal_distributed, useNA = "ifany")

# summary of proteins regarding significant of t-test
table(Shift_Data$significant_ttest_filtered, useNA = "ifany")

head(Shift_Data)
```

## Plot T-Test Results - Lina
GOAL: Plot t-test results by visualizing CoM positions in Ctrl vs. RNase 
```{r}
library(ggplot2)
library(dplyr)

# Create scatter plot of CoM values in Ctrl (x) vs. RNase (y) for all proteins
# Color points based on t-test result (significant or not)
ggplot(Shift_Data, aes(x = `CoM_Ctrl`, y = `CoM_RNase`, color = case_when(
  `significant_ttest_filtered` ~ "Significant Left Shift / RBPs",
    TRUE ~ "No significant Shift"
  ))) +
  geom_point(alpha = 0.6) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray20") +
  scale_color_manual(name = "Significance as RBP",values = c(
    "Significant Left Shift / RBPs" = "darkred",
    "No significant Shift" = "gray70"
  ))+
  labs(title = "Center of Mass in Ctrl and RNase: T-Test positives",
       x = "CoM Ctrl",
       y = "CoM RNase") +
  theme_minimal()
```

## Validation of T-Test with UniProt Data -Lina
To assess the validity of our T-test-based identification of RNA-binding proteins (RBPs), we compare the results with annotated human RBPs from UniProt.

This includes:
- Overlap analysis between our tested proteins and known UniProt RBPs
- Calculation of a hit rate (percentage of known RBPs detected as T-test positives)
- Validation with literature-supported positive and negative control proteins
```{r}
library(glue)

# Load annotated RNA-binding proteins (RBPs) from UniProt (human-specific)
uniprot_rbps <- read.delim("uniprotkb_RNA_binding_HUMAN_AND_model_o_2025_06_09.tsv", 
                           header = TRUE, sep = "\t", stringsAsFactors = FALSE)

# Extract UniProt entry names (used for matching)
known_rbps <- uniprot_rbps$Entry.Name
glue("Number of known RBPs in UniProt: {length(known_rbps)}")

# Extract RBP candidates identified by T-test
t_test_positives <- rownames(
  Shift_Data[Shift_Data$significant_ttest_filtered == TRUE & 
               !is.na(Shift_Data$significant_ttest_filtered), ])

# Determine overlap: known RBPs present in our dataset
overlap_MS_Table <- intersect(rownames(MS_Table), known_rbps)
glue("Number of UniProt RBPs tested with R-DeeP: {length(overlap_MS_Table)}")

# Determine overlap: known RBPs that were also T-test positive
overlap_t_test <- intersect(t_test_positives, known_rbps)
glue("Number identified as RBPs (T-Test positive): {length(overlap_t_test)}")
glue("Hit rate: {round(length(overlap_t_test)/length(overlap_MS_Table)*100, 2)}%")

# Positive Control Validation

  # RBM10, SMN1, and FMR1 are well-documented RBPs (literature-supported)
  pos_controls <- c("RBM10_HUMAN", "SMN_HUMAN", "FMR1_HUMAN")

  # Check whether they are in our dataset and classified as T-test positives
  pos_df <- data.frame(
    Protein_Postive_Control = pos_controls,
    InDataset = pos_controls %in% rownames(MS_Table),
    TTest = pos_controls %in% t_test_positives)
  print(pos_df)

# Positive Control Validation
  
  # ACTB, SDHB, and COX4I1 are typically not considered RNA-binding (negative controls)
  neg_controls <- c("ACTB_HUMAN", "SDHB_HUMAN", "COX41_HUMAN")
  
  # Same check as above for negatives
  neg_df <- data.frame(
    Protein_Negative_Control = neg_controls,
    InDataset = neg_controls %in% rownames(MS_Table),
    TTest = neg_controls %in% t_test_positives)
  print(neg_df)
```

###Plot Validation of T-test with UniProt Data -Lina
This plot extends the CoM-based T-test visualization by highlighting known RBPs from UniProt.
This view helps assess the sensitivity and limitations of the shift-based identification method relative to external RBP annotations.
```{r}
library(ggplot2)
library(dplyr)

# Create data subset of proteins for highlighting (was nessesary for coloring sequence)
highlight_data <- subset(Shift_Data,
                         rownames(Shift_Data) %in% overlap_t_test |
                         rownames(Shift_Data) %in% not_indentified |
                         significant_ttest_filtered)

# Classify each protein into a color group
highlight_data$color_group <- case_when(
  rownames(highlight_data) %in% overlap_t_test ~ "Overlaping with UniProt",
  rownames(highlight_data) %in% not_indentified ~ "UniProt Proteins not identified",
  highlight_data$significant_ttest_filtered ~ "Significant Left Shift / RBPs"
)

# Control transparency depending on group
highlight_data$alpha_group <- case_when(
  highlight_data$color_group == "Overlaping with UniProt" ~ "high",
  highlight_data$color_group == "UniProt Proteins not identified" ~ "high",
  highlight_data$color_group == "Significant Left Shift / RBPs" ~ "low"
)

# Base plot: all proteins shown in background
ggplot(Shift_Data, aes(x = `CoM_Ctrl`, y = `CoM_RNase`)) +
  
    # Background: all non-highlighted proteins in light gray
    geom_point(aes(color = "No significant Shift"), alpha = 0.3, show.legend = FALSE) +
  
    # Highlighted groups: UniProt hits, misses, and T-test positives
    geom_point(data = highlight_data,
             aes(color = color_group, alpha = alpha_group)) +
    scale_color_manual(name = "Significance as RBP",values = c(
    "No significant Shift" = "gray80",
    "Significant Left Shift / RBPs" = "gray40",
    "Overlaping with UniProt" = "lightcoral",
    "UniProt Proteins not identified" = "darkred"
    ))+
    scale_alpha_manual(values = c("high" = 0.9, "low" = 0.3), guide = "none") +
  
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "gray20") +
  labs(title = "Validation of T-Test: Comparing with UniProt Data",
       x = "CoM Ctrl",
       y = "CoM RNase") +
  theme_minimal()
```

### Evaluation of T-Test Limitations - Lina

This section investigates potential false negatives from the T-test-based RBP identification.  
We explore cases where known RBPs were not classified as significant and examine possible causes:

- **Incomplete data**: 12% of non-identified RBPs were excluded due to missing measurements (e.g., only RNase or only Ctrl values available)  
- **Violation of normality assumption**: 10% failed the Shapiro-Wilk test for normal distribution (e.g., HTSF1, LSM8)  
- **Marginal p-values**: ~8% exhibited consistent shifts but did not reach significance (e.g., RPP29_HUMAN with p = 0.08)

Manual inspection of 40 non-identified RBPs suggests a false negative rate of approximately 19% within the testable subset.  
From a sample of 40 T-test-positive proteins, only 2 would have been visually rejected as RBPs, corresponding to a 5% false positive rate. 
Furthermore, of all proteins with p-values > 0.045 (n = 18), only 4 were judged inconsistent with an RBP-like shift profile,  
suggesting that most borderline cases still show convincing shift patterns.

```{r}
#Identify known UniProt RBPs not found by T-Test
not_indentified <- known_rbps[! known_rbps %in% t_test_positives & known_rbps %in% rownames(MS_Table)]

# Total "missed" RBPs present in dataset
length(not_indentified)

# Analyze potential causes
sum(is.na(Shift_Data[not_indentified, "shapiro_p"])) /length(not_indentified) # Missing Shapiro results because of missing values
sum(Shift_Data[not_indentified, "normal_distributed"] == FALSE) / length(not_indentified) # Failed normality
sum(Shift_Data[not_indentified, "p_value_ttest_filtered"] < 0.1, na.rm = TRUE) / length(not_indentified) # Would be detected at alpha = 0.1

```

```{r}
#Visual inspection of a sample of non-identified proteins
sample_not_identified <- head( not_indentified, 40)
for (s in sample_not_identified ){
  plot_protein(s)
}
# Display statistical values for this subset
print(Shift_Data_for_t[sample_not_identified,])
print(Shift_Data[sample_not_identified, c("shapiro_p","normal_distributed","p_value_ttest_filtered","significant_ttest_filtered")])
```

```{r}
#Visual inspection of a sample of T-Test positive proteins
sample_t_test_positives <-head(t_test_positives,40)
for (s in sample_t_test_positives){
  plot_protein(s)
}
```

```{r}
# Visual inspection of proteins with marginally significant p-values (above 0.045)
t_test_positives_critical_p_value <- rownames(
  Shift_Data[
    Shift_Data$significant_ttest_filtered == TRUE &
    !is.na(Shift_Data$significant_ttest_filtered) &
    Shift_Data$p_value_ttest_filtered > 0.045,
  ]
)
for (s in t_test_positives_critical_p_value){
  plot_protein(s)
}
```


## T-Test for non-synchronised HELA Cells - includes previous coded parts of all group members, slightly adjusted by Lina
This section reproduces all necessary pipeline steps with adjusted variable names.  
All variables related to the non-synchronized dataset are suffixed with `_NS`.
```{r}
#loading Data
MS_Table_NS <- read.table("RDeeP_HeLa_NS.csv", header = TRUE, row.names = 1, sep = ";")

#Dataframe
treatment <- factor(rep(c("Ctrl", "RNase"), each = 3, length.out = 150))
replicate <- factor(rep(c("Ctrl_Rep1", "Ctrl_Rep2", "Ctrl_Rep3", "RNase_Rep1","RNase_Rep2", "RNase_Rep3"),25))
fraction <- factor(rep(paste0("Fraction_", 1:25), each = 6))

data <- data.frame(rownames = colnames(MS_Table),treatment = treatment, replicate = replicate, fraction = fraction)

# normalisation of triplicates
average.list.NS <- list() 

for (f in levels(fraction)) {
  
  cols.Ctrl <- which(fraction == f & treatment == "Ctrl") 
  average.Ctrl <- rowMeans(MS_Table_NS[,cols.Ctrl]) 
  average.list.NS[[paste0("Ctrl_",f)]] <- average.Ctrl 
  
  cols.RNase <- which(fraction == f & treatment == "RNase")
  average.RNase <- rowMeans(MS_Table_NS[,cols.RNase])
  average.list.NS[[paste0("RNase_",f)]] <- average.RNase
}

MS_Table_Averages_NS <- as.data.frame(average.list.NS) 
rownames(MS_Table_Averages_NS) <- rownames(MS_Table_NS)

fractions <- paste0("Fraction_", 1:25)

ordered_names <- as.vector(rbind(
  paste0("Ctrl_", fractions),
  paste0("RNase_", fractions)
))

MS_Table_Averages_NS <- MS_Table_Averages_NS[, ordered_names]

# Normalisation to 100

ctrl_cols <- grep("^Ctrl_", colnames(MS_Table_Averages_NS)) 
rnase_cols <- grep("^RNase_", colnames(MS_Table_Averages_NS))

ctrl_norm <- MS_Table_Averages_NS[, ctrl_cols] / rowSums(MS_Table_Averages_NS[, ctrl_cols]) * 100
rnase_norm <- MS_Table_Averages_NS[, rnase_cols] / rowSums(MS_Table_Averages_NS[, rnase_cols]) * 100

MS_Table_Norm_NS <- cbind(ctrl_norm, rnase_norm)
MS_Table_Norm_NS <- MS_Table_Norm_NS[, colnames(MS_Table_Averages_NS)]

# Fuction for protein ploting 
plot_protein_NS <- function(x) {
  protein_of_interest <- x 
  protein_row <- MS_Table_Norm_NS[rownames(MS_Table_Norm_NS) == protein_of_interest, ]
  ctrl_values <- as.numeric(protein_row[seq(1, 49, by=2)])
  rnase_values <- as.numeric(protein_row[seq(2, 50, by=2)])
  fractions <- 1:25
  max_val <- max(ctrl_values, rnase_values, na.rm = TRUE)
  ylim_range <- c(0, max_val * 1.1)

  plot(fractions, ctrl_values, type="o", pch=20, lty=1, lwd =1.5, col="forestgreen", ylim=range(c(ctrl_values, rnase_values)),
       xlab="Fraction", ylab="Normalized Intensity", main= paste(protein_of_interest, "non-synchronised"), axes = FALSE)
       
  lines(fractions, rnase_values, type="o",pch =20, lty=1,lwd =1.5, col="firebrick3")
  
  polygon(c(fractions, rev(fractions)), 
          c(ctrl_values, rep(0, length(ctrl_values))), 
          col=adjustcolor("forestgreen", alpha.f=0.1), border=NA)
  
  polygon(c(fractions, rev(fractions)), 
          c(rnase_values, rep(0, length(rnase_values))), 
          col=adjustcolor("firebrick3", alpha.f=0.1), border=NA)
  
  axis(1, at = 1:25, labels = 1:25, cex.axis = 0.7)
  axis(2, cex.axis = 0.7, las =2)
  grid(nx = NULL, ny = NULL, col = "lightgray", lty = "dotted", lwd = 0.8)
  
  legend("topright", legend=c("Ctrl", "RNase"), col=c("forestgreen", "firebrick3"), 
         lty=1, lwd = 1.5,  pch=20, bg = "white", bty = "o", box.col = NA)
}

# Shift Characteristics based on normalised Data and CoM
x <- 1:25

CoM_Ctrl_NS <- numeric(nrow(MS_Table_Norm_NS))
CoM_RNase_NS <- numeric(nrow(MS_Table_Norm_NS))
shift_distance_NS <- numeric(nrow(MS_Table_Norm_NS))
shift_direction_NS <- numeric(nrow(MS_Table_Norm_NS))

for (p in seq_len(nrow(MS_Table_Norm_NS))) {

  row_vals <- as.numeric(MS_Table_Norm_NS [p,])
  ctrl_vals <- row_vals[seq(1, 50, by =2)]
  rnase_vals <- row_vals[seq(2, 50, by=2)]

  CoM_Ctrl_NS[p] <- sum(ctrl_vals * x) / sum(ctrl_vals)
  CoM_RNase_NS[p] <- sum(rnase_vals * x) / sum(rnase_vals)
  shift_distance_NS[p] <- CoM_Ctrl_NS[p] - CoM_RNase_NS[p] 
  shift_direction_NS[p] <- sign(shift_distance_NS[p]) 
}

Shift_Data_NS <- data.frame(
  CoM_Ctrl= CoM_Ctrl_NS,
  CoM_RNase = CoM_RNase_NS,
  shift_distance = shift_distance_NS,
  shift_direction= shift_direction_NS,
  row.names = rownames(MS_Table_Norm_NS))

# Normalisation of MS_Table_NS to 100

ctrl_cols_t1 <- grep("_Ctrl_Rep1", colnames(MS_Table_NS))
ctrl_cols_t2 <- grep("_Ctrl_Rep2", colnames(MS_Table_NS))
ctrl_cols_t3 <- grep("_Ctrl_Rep3", colnames(MS_Table_NS))
RNase_cols_t1 <- grep("_RNase_Rep1", colnames(MS_Table_NS))
RNase_cols_t2 <- grep("_RNase_Rep2", colnames(MS_Table_NS))
RNase_cols_t3 <- grep("_RNase_Rep3", colnames(MS_Table_NS))

ctrl_norm_t1 <- MS_Table_NS[, ctrl_cols_t1] / rowSums(MS_Table_NS[, ctrl_cols_t1]) * 100
ctrl_norm_t2 <- MS_Table_NS[, ctrl_cols_t2] / rowSums(MS_Table_NS[, ctrl_cols_t2]) * 100
ctrl_norm_t3 <- MS_Table_NS[, ctrl_cols_t3] / rowSums(MS_Table_NS[, ctrl_cols_t3]) * 100
RNase_norm_t1 <- MS_Table_NS[, RNase_cols_t1] / rowSums(MS_Table_NS[, RNase_cols_t1]) * 100
RNase_norm_t2 <- MS_Table_NS[, RNase_cols_t2] / rowSums(MS_Table_NS[, RNase_cols_t2]) * 100
RNase_norm_t3 <- MS_Table_NS[, RNase_cols_t3] / rowSums(MS_Table_NS[, RNase_cols_t3]) * 100

Norm_Data_for_t_NS <- cbind(ctrl_norm_t1, RNase_norm_t1, ctrl_norm_t2, RNase_norm_t2, ctrl_norm_t3, RNase_norm_t3)

fractions <- 1:25
reps <- 1:3
conditions <- c("Ctrl", "RNase") 
ordered_names <- c()
for (fraction in fractions) {
  for (rep in reps) {
    for (condition in conditions) {
      name <- paste0("Fraction", fraction, "_", condition, "_Rep", rep)
      ordered_names <- c(ordered_names, name)
    }
  }
}
Norm_Data_for_t_NS <- Norm_Data_for_t_NS[, ordered_names]

#Calculation of CoM for T-Test

fractions <- 1:25
conditions <- c("Ctrl", "RNase")
replicates <- c("Rep1", "Rep2", "Rep3")

results_com_NS <- list()

for (cond in conditions) {
  for (rep in replicates) {
    pattern <- paste0("^Fraction", fractions, "_", cond, "_", rep, "$")
    cols <- grep(paste(pattern, collapse="|"), colnames(Norm_Data_for_t_NS), value = TRUE)  
    subdata <- Norm_Data_for_t_NS[, cols]   
    subdata <- subdata[, order(as.numeric(gsub("Fraction(\\d+)_.*", "\\1", cols)))]  
    com <- apply(subdata, 1, function(x) {
      sum(x * fractions) / sum(x)
    })

    results_com_NS[[paste(cond, rep, sep = "_")]] <- com
  }
}

CoM_Data_for_t_NS <- as.data.frame(results_com_NS)  

rownames(CoM_Data_for_t_NS) <- rownames(Norm_Data_for_t_NS)

# Calculating Shift-Values for T-Test

Shift_Data_for_t_NS <- data.frame(
  shift_distance_rep1 = CoM_Data_for_t_NS[, 1] - CoM_Data_for_t_NS[, 4],
  shift_distance_rep2 = CoM_Data_for_t_NS[, 2] - CoM_Data_for_t_NS[, 5],
  shift_distance_rep3 = CoM_Data_for_t_NS[, 3] - CoM_Data_for_t_NS[, 6],
  row.names = rownames(CoM_Data_for_t_NS)
)

#T-Test

Shift_Data_NS$shapiro_p <- NA
Shift_Data_NS$normal_distributed <- NA
Shift_Data_NS$p_value_ttest_filtered <- NA
Shift_Data_NS$significant_ttest_filtered <- NA

for (protein in rownames(Shift_Data_for_t_NS)) {
 
  shift_values <- as.numeric(Shift_Data_for_t_NS[protein, c("shift_distance_rep1", "shift_distance_rep2", "shift_distance_rep3")])

  if (all(!is.na(shift_values))) {

    if (length(unique(shift_values)) == 1) {
      Shift_Data_NS[protein, "shapiro_p"] <- NA
      Shift_Data_NS[protein, "normal_distributed"] <- TRUE
      
    } else {
      shapiro_result <- shapiro.test(shift_values)
      Shift_Data_NS[protein, "shapiro_p"] <- shapiro_result$p.value
      Shift_Data_NS[protein, "normal_distributed"] <- shapiro_result$p.value >= 0.05
    }
    
    if (Shift_Data_NS[protein, "normal_distributed"] == TRUE) {
      test_result <- t.test(shift_values, mu = 1, alternative = "greater")
      Shift_Data_NS[protein, "p_value_ttest_filtered"] <- test_result$p.value
      Shift_Data_NS[protein, "significant_ttest_filtered"] <- ifelse(test_result$p.value < 0.05, TRUE, FALSE)
      
    } else {
      Shift_Data_NS[protein, "p_value_ttest_filtered"] <- NA
      Shift_Data_NS[protein, "significant_ttest_filtered"] <- NA
    }
  }
}
#Analysis of results for Nonsynchronised HeLa Cells
table(Shift_Data_NS$significant_ttest_filtered, useNA = "ifany")
```

#Comparison of Proteins found as RBP in Mitosis vs. in NS_Hela - Lina
This section compares proteins identified as RNA-binding by T-test in mitotic vs. non-synchronized HeLa cells.  
We analyze the overlap between datasets, list proteins uniquely shifted during mitosis, and visualize differences in shift characteristics.
Finally, a scatterplot compares shift distances across both conditions and highlights condition-specific RBPs.
```{r}
library(glue)

# Identify proteins classified as significant RBPs in non-synchronized HeLa cells
t_test_positives_NS <- rownames(Shift_Data_NS[Shift_Data_NS$significant_ttest_filtered == TRUE & !is.na(Shift_Data_NS$significant_ttest_filtered), ])

# Determine protein overlap across datasets
overlap_analysis <- intersect(rownames(MS_Table_NS), rownames(MS_Table))
glue("Number of Proteins in sample NS_Hela: {length(rownames(MS_Table_NS))}")
glue("Number of Proteins analysed in both samples: {length(overlap_analysis)}")

# Identify proteins found as RBPs in both conditions
overlap_t_test_positivs <- intersect(t_test_positives, t_test_positives_NS)
glue("Number of RBPs found in both samples: {length(overlap_t_test_positivs)}")

# Identify RBPs found *only* in mitosis, and also present in both datasets
RBPs_Mitosis <- setdiff(t_test_positives, t_test_positives_NS)
RBPs_Mitosis <- intersect(RBPs_Mitosis, overlap_analysis)
glue("Number RBPs found only in Mitosis: {length(RBPs_Mitosis)}")


# Display a sample of plots (mitosis and non-synchronised) of RBPs uniquely active in mitosis
sample_RBPs_Mitosis <- head(RBPs_Mitosis,10)
for (r in sample_RBPs_Mitosis){
  plot_protein(r)
  plot_protein_NS(r)
}

# Visualise differences in shift characteristics

# Define variables to extract from both datasets
cols_to_extract <- c("CoM_Ctrl", "CoM_RNase", "shift_distance", "shift_direction", "p_value_ttest_filtered", "significant_ttest_filtered")

# Subset and rename columns for both conditions
subset_data_S <- Shift_Data[overlap_analysis, cols_to_extract]
subset_data_NS <- Shift_Data_NS[overlap_analysis, cols_to_extract]
colnames(subset_data_S) <- paste0(colnames(subset_data_S), "_mitosis")
colnames(subset_data_NS) <- paste0(colnames(subset_data_NS), "_nonSync")

# Merge into one combined dataframe
Shift_Data_Combined <- cbind(subset_data_S,subset_data_NS)
head(Shift_Data_Combined)

#Scatterplot of shift distances

library(ggplot2)
library(dplyr)

ggplot(Shift_Data_Combined, aes(x = `shift_distance_mitosis`,
                                y = `shift_distance_nonSync`,
                                color = case_when(
                                  !`significant_ttest_filtered_mitosis` & !`significant_ttest_filtered_nonSync` ~ "No significant RBPs",
                                  `significant_ttest_filtered_mitosis` & !`significant_ttest_filtered_nonSync` ~ "RBPs only active in Mitosis",
                                  !`significant_ttest_filtered_mitosis` & `significant_ttest_filtered_nonSync` ~ "RBPs not active in Mitosis",
                                  TRUE ~ "RBPs always active"
                                  ))) +
  geom_point(alpha = 0.6) +
  geom_abline(slope = 1, intercept = 0, linetype = "dashed", color = "red") +
  scale_color_manual(name = "Significance as RBP",
                     values = c(
                       "No significant RBPs" = "grey80",
                       "RBPs not active in Mitosis" = "gray30",
                       "RBPs always active" = "lightcoral",
                       "RBPs only active in Mitosis" = "darkred"
                       ))+
  labs(title = "Shift Distance: Mitosis vs. Non-Synchronized",
       x = "Shift Distance (Mitosis)",
       y = "Shift Distance (Non-Synchronized)") +
  theme_minimal()
```





#Clustering to find posible RBP complexes in our RBPs in Mitosis - Sofia and Cihan 

#1) Selection of clustering criteria and Hirarchical clustering to look at distribution of values posibel number of clusters

Goal: select necessary parameters/ dimensions, get an idea of the distribution of clusters. Peak data is mainly taken into consideration, specifically peak hight ( not position or number of peaks) we only focus on Ctrl samples, not RNase as we expect different proteins to have different distributions after RNase degradation even when they are in the same complex. Following this logic shift data is also irrelevant. To this data we add COM of Ctrl, here peak position is relevant, overall. overall similar hight is more important than similar peak fraction. Runs only on RBPS only active in mitosis ( when compared to synchronized cells). Wards method ( euclidean distance applied), !i think here we have to say it didnt work. 

```{r}
#from the two shift and peak characteristics we extract some variables creating a new merged table which also has only the names of the RBPs that are aktive in mitosis !! hier stimmt was nicht.

library(dplyr)

# 1) Filter only the RBPs relevant in Mitosis 

filtered_shift_Mitosis <- Shift_Data[rownames(Shift_Data) %in% RBPs_Mitosis, ]

filtered_peak_Mitosis <- Peak_Data[rownames(Peak_Data) %in% RBPs_Mitosis, ]

# 2) Selecting only the interesting coloumns creating comon dataframe

merged_filterd_mitosis <- cbind(
  filtered_shift_Mitosis[, c("CoM_Ctrl")],
  filtered_peak_Mitosis %>% select(ends_with("height_Ctrl"))
)

head(merged_filterd_mitosis)

# 3) clean data for further steps 

# Replace NA values with 0 (when there was no peak there was not protein)
clean_merged_filterd_mitosis <- merged_filterd_mitosis
clean_merged_filterd_mitosis[is.na(clean_merged_filterd_mitosis)] <- 0


# 4) do hirarchical clustering in order to analize number of clusters that could be found

clean2_merged_filterd_mitosis <- as.matrix(clean2_merged_filterd_mitosis)   # Convert to numeric matrix if it's not already

# Distance matrix (Euclidean)
dist_matrix <- dist(clean2_merged_filterd_mitosis)

# Hierarchical clustering with different linkage methods
hc_ward <- hclust(dist_matrix, method = "ward.D2")

# Plot dendrogram
par(mfrow = c(2, 2))
#plot(hc_ward, main = "Ward's Method")  was sollte das 


plot(hc_ward, labels = FALSE, main = "Ward's Method (no labels)")

# image for download: 

png("C://Users//Sofi//Desktop//4 Semester//Bioinfo_project//Downloadsdendrogram_large.png", width = 1200, height = 800)
plot(hc_ward, labels = FALSE, main = "Ward's Method (Large Output)")
dev.off()


```

#2) Using DBSCAN algorithm 

Goal: find a clustering method that will highlite proteins which could be working in a complex based on the clustering method. 

DBSCAN is a function that can classify points in low-density regions as "noise." This means clusters are not only defined by distance (like in k-means), but also by density.
The code I wrote has two important parameters. These parameters are:

ε (epsilon): The maximum distance between two points to be considered neighbors.
If this number is very small, everything is classified as noise; if it’s too large, noise may be included as relevant (resulting in one huge cluster).

MinPts: The minimum number of neighbors required for a point to be considered a so-called core point.
A core point must have at least MinPts other points within ε.
If this value is too low, even single points can form clusters. On the other hand, if it’s too high, only large clusters are formed and smaller ones might not be recognized at all.
There are also border points, which are within ε distance of a core point but do not have enough neighbors themselves to be core points.

Everything that does not meet these conditions is filtered out and labeled as noise.
```{r}
library(dplyr)

# Optionally remove constant columns

#clean2_merged_filterd_mitosis <- clean_merged_filterd_mitosis[, apply(clean_merged_filterd_mitosis, 2, function(col) sd(col, na.rm = TRUE) != 0)]


# Load libraries => fals nicht installiert mussen die instaliert werden
#install.packages("dbscan")
#install.packages("factoextra")

# Load libraries
library(dbscan)
library(ggplot2)
library(factoextra)


# Scale data
scaled_data <- scale(clean2_merged_filterd_mitosis)

# DBSCAN # its important to choose eps and minPts correctly, eps is the max distance for two points to be neighbors, minPts  minimum number of points required to form a dense region ( here i choose x based on the dimension of the data and the averedge protein komplex )

db <- dbscan(scaled_data, eps = 0.7, minPts = 4) # here parameters can be changed

# PCA for plotting
pca <- prcomp(scaled_data)
pca_df <- as.data.frame(pca$x[, 1:2])  # PC1 and PC2
pca_df$cluster <- as.factor(db$cluster)
pca_df$protein <- rownames(clean2_merged_filterd_mitosis)  # Protein names from cleaned data 

# Plot with noise in grey

ggplot(pca_df, aes(x = PC1, y = PC2, color = cluster, label = ifelse(cluster == 0, "", protein))) +
  geom_point(size = 2) +
  geom_text(check_overlap = TRUE, size = 2.5, vjust = -1) +
  scale_color_manual(values = c("0" = "grey", "1" = "blue", "2" = "red", "3" = "green", "4" = "purple", "5" = "orange")) +
  theme_minimal() +
  labs(title = "DBSCAN Clustering of Proteins",
       subtitle = "Visualized with PCA (2D)",
       color = "Cluster") +
  theme(plot.title = element_text(face = "bold"))

# Create table: which proteins are in which cluster
clustered_proteins <- split(rownames(clean2_merged_filterd_mitosis), db$cluster)

# Print each cluster's members
for (cl in sort(unique(db$cluster))) {
  cat(paste0("Cluster ", cl, ifelse(cl == 0, " (noise)", ""), ": "))
  cat(paste(clustered_proteins[[as.character(cl)]], collapse = ", "))
  cat("\n\n")
}
```


# 3)looking at plots of different clusters (Linas code) 

Goal: Looking if the plots look similar or not in order to validate the parameters choosen above. This code can be always run to get a better feeling over clusters 
```{r}
# code from ploting a protein to visualize the proteins that seam to make a complex
# View Examples
sample_RBPs_Cluster <- c("RL22_HUMAN", "RL23_HUMAN", "RL24_HUMAN", "RL27_HUMAN", "RL30_HUMAN", "RL34_HUMAN", "RLA1_HUMAN", "RS26_HUMAN", "RS2_HUMAN", "RS6_HUMAN", "RS12_HUMAN") # insert names of clustered proteins you want to compare 

for (r in sample_RBPs_Cluster){
  plot_protein(r)
}

```


# 4)vergleich mit corum daten Ich glaub das müssen wir anders schreiben hier muss die selction von den 91 RBS welche in cluster vorkommen und das man sich dieses exel runterladen kann um sie sich anzuschauen 
Goal: Finding Proteins that we know work in komplex for further positv/ negativ controlls of our clustering 
```{r}

# Analysis of Clusters with CORUM data
RBPs_Mitosis_CORUM_clustered3 <- RBPs_Mitosis_CORUM[RBPs_Mitosis_CORUM %in% c("CLAP1_HUMAN", "ELYS_HUMAN", "KIF14_HUMAN" , "NOP58_HUMAN", "PRPF3_HUMAN", "RBBP6_HUMAN", "RFC1_HUMAN", "ZC11A_HUMAN")]

length(RBPs_Mitosis_CORUM_clustered3)

View(RBPs_Mitosis_CORUM_clustered3)

protein_data[protein_data$Entry %in% c("DDX20_HUMAN", "DSRAD_HUMAN", "SAFB1_HUMAN", "ZCH18_HUMAN"),]


```

# 5) finding the right parameters to choose the perfect cluster size 
Goal: getting a good idea of how the picking of the parameters affects our clustering results by trying all combinations and creating a heat map based on the performance on a cluster (selected from exel from previous chunk). For the heatmap we made up following logic. 

a) Based on all combinations from one cluster (positive control):

If two proteins are in the same cluster → +1

If two proteins are in different clusters → -1

If one or both are classified as noise → 0

b) Based on two (or more) unrelated proteins (negative control):

If they end up in the same cluster as our example proteins → -1

If they end up in different clusters → +1

If noise → 0 (I’m least sure about this case)

```{r}

# -------------- PART 1: Creating a loop for all possible combinations for ε between the numbers ( 0.5-1.5) in steps of 0.1 and for MinPts (1-10) in steps of 1 ----------

# 1. Scale the data
scaled_data <- scale(clean_merged_filterd_mitosis)
protein_names <- rownames(clean_merged_filterd_mitosis)
n_proteins <- nrow(scaled_data)

# 2. Create empty data frame to collect results
results_df <- data.frame(row.names = protein_names)

# 3. Loop over all combinations
for (eps in seq(0.5, 1.5, by = 0.1)) {
  for (minPts in 1:10) {
    
    # Run DBSCAN
    db <- dbscan(scaled_data, eps = eps, minPts = minPts)
    
    # Store cluster assignments
    col_name <- paste0("eps_", eps, "_minPts_", minPts)
    results_df[[col_name]] <- db$cluster
  }
}

# 4. Preview result
head(results_df)

# -------------- PART 2: Creating a loop for all possible combinations for ε between the numbers ( 0.5-1.5) in steps of 0.1 and for MinPts (1-10) in steps of 1 ----------

library(ggplot2)
library(reshape2)


# 1)Define your proteins of interest

target_proteins <- c("RS12_HUMAN", "RS26_HUMAN", "RS2_HUMAN", "RS6_HUMAN") # this would be positiv controll, a complex we know about. 

negative_controls <- c("LPPRC_HUMAN", "UIMC1_HUMAN")  # Here a explenation (biological is needed as to why i choose these )

all_proteins <- c(target_proteins, negative_controls)

# 2) create all pairwise combinations

protein_pairs <- combn(all_proteins, 2, simplify = FALSE)

# --- Step 4: scoring for each DBSCAN setting ---
score_results <- data.frame()

for (col_name in colnames(results_df)) {
  
  cluster_assignments <- as.numeric(results_df[[col_name]])
  names(cluster_assignments) <- rownames(results_df)
  
  pair_scores <- c()

  for (pair in protein_pairs) {
    p1 <- pair[1]
    p2 <- pair[2]
    c1 <- cluster_assignments[p1]
    c2 <- cluster_assignments[p2]

    # Skip if NA
    if (is.na(c1) || is.na(c2)) {
      score <- NA

    # Both are targets
    } else if (p1 %in% target_proteins && p2 %in% target_proteins) {
      if (c1 == 0 || c2 == 0) {
        score <- 0
      } else if (c1 == c2) {
        score <- 1
      } else {
        score <- -1
      }

    # One is negative control, one is target
    } else if ((p1 %in% negative_controls && p2 %in% target_proteins) || 
               (p2 %in% negative_controls && p1 %in% target_proteins)) {
      if (c1 == 0 || c2 == 0) {
        score <- 0
      } else if (c1 == c2) {
        score <- -1
      } else {
        score <- 1  # Properly separated
      }

    # Both are negative controls – don't score this pair
    } else {
      next
    }

    pair_scores <- c(pair_scores, score)
  }

  avg_score <- mean(pair_scores, na.rm = TRUE)

  parts <- strcapture("eps_([0-9.]+)_minPts_([0-9]+)", col_name, data.frame(eps = 0, minPts = 0))
  
  score_results <- rbind(score_results, data.frame(
    eps = as.numeric(parts$eps),
    minPts = as.numeric(parts$minPts),
    score = avg_score
  ))
}

# --- Step 6: Plot heatmap ---
ggplot(score_results, aes(x = eps, y = minPts, fill = score)) +
  geom_tile(color = "grey70") +
  scale_fill_gradient2(low = "red", mid = "white", high = "blue", midpoint = 0, limits = c(-1, 1)) +
  labs(title = "Clustering Consistency of Protein Pairs",
       subtitle = "Based on DBSCAN parameter combinations",
       x = "Epsilon (ε)",
       y = "MinPts",
       fill = "Avg. Pair Score") +
  theme_minimal()


```








# Additional Data for all Proteins using Uniprot and CORUM - Lina
(carefull runs 35 min!!!... grab a coffee :)
```{r}
library(httr)
library(jsonlite)
library(pbapply)  # für Fortschrittsbalken bei langen Listen

# Function für accession ids aus Uniprot
get_accession_from_entryname <- function(entry_name) {
  url <- paste0("https://rest.uniprot.org/uniprotkb/search?query=", entry_name, "&fields=accession&format=json&size=1")
  res <- try(GET(url), silent = TRUE)
  if (inherits(res, "try-error") || res$status_code != 200) {
    return(NA)
  }
  txt <- content(res, "text", encoding = "UTF-8")
  data <- fromJSON(txt, simplifyVector = FALSE)
  if (length(data$results) == 0) {
    return(NA)}
  else{
  return(data$results[[1]]$primaryAccession)}
    
}
# Funktion zum Abrufen der Masse für eine UniProt-ID
get_uniprot_mass <- function(accession_ids) {
  url <- paste0("https://rest.uniprot.org/uniprotkb/", accession_ids, ".json")
  res <- try(GET(url), silent = TRUE)
  if (inherits(res, "try-error") || res$status_code != 200) {
    return(NA)
  }
  data <- fromJSON(content(res, "text", encoding = "UTF-8"))
  return(data$sequence$molWeight)
}

entry_names <- rownames(MS_Table)
accession_ids <- pbsapply(entry_names, get_accession_from_entryname)
masses <- pbsapply(accession_ids, get_uniprot_mass)

#Wichtig, da wir massen unlisten müssen, und 5 Proteine als NA gespeichert werden müssen
masses_vec <- rep(NA_real_, length(accession_ids))
names(masses_vec) <- accession_ids
valid_idx <- which(!sapply(masses, is.null))
masses_vec[valid_idx] <- as.numeric(unlist(masses[valid_idx]))

# DataFrame bauen
protein_data <- data.frame(
  Entry = entry_names,
  UniProtAccession = accession_ids,
  MolecularWeight_kDa = masses_vec / 1000
)

# Load Data from Corum (all HUMAN Complexes)
library(data.table)
corum <- fread("corum_humanComplexes.txt", sep = "\t", header = TRUE) 

#build new table, with colum UniProtAcession and ComplexName 
corum_expanded <- corum[, .(
  UniProtAccession = unlist(strsplit(subunits_uniprot_id, ";"))
), by = .(ComplexName = complex_name)]

corum_expanded <- unique(corum_expanded)

#add a new column to dataframe for additional protein data, and assign TRUE/FALSE if found /not found in CORUM
protein_data$CORUM_member <- protein_data$UniProtAccession %in% corum_expanded$UniProtAccession

#build new table, with column for complex names, assigning each protein all corresponding protein names
corum_complex_list <- corum_expanded[, .(
  CORUM_complex_names = paste(unique(ComplexName), collapse = "; ")
), by = UniProtAccession]

#add complex Names to protein data
protein_data <- merge(protein_data, corum_complex_list, by = "UniProtAccession", all.x = TRUE, sort = FALSE)
protein_data$CORUM_member <- !is.na(protein_data$CORUM_complex_names)

#infos 
head(protein_data)
sum(is.na(protein_data$MolecularWeight_kDa)) # number of proteins, where no molecular weight was avalible 
sum(protein_data$CORUM_member== TRUE) # number of our proteins known to be in complex 

# how many proteins and complexes ar listed in this dataset (Human) 
all_proteins <- unlist(strsplit(corum$subunits_uniprot_id, ";"))
unique_proteins <- unique(all_proteins)
length(unique_proteins) #5205 proteins

n_human_complexes <- unique(corum$complex_id)
length(n_human_complexes) #5366 complexes
```

## New Plot Protein function with all additional data

```{r}
plot_protein_info <- function(x) {
  
  #split up plot area
  layout(matrix(1:2, nrow = 1), widths = c(4, 2))  # 3:2 Verhältnis (Plot : Info)
  par(mar = c(5, 4, 4, 1))
  
  #extract data, define all variables and range of x- and y-achsis
  protein_of_interest <- x 
  protein_row <- MS_Table_Norm[rownames(MS_Table_Norm) == protein_of_interest, ]
  ctrl_values <- as.numeric(protein_row[seq(1, 49, by=2)])
  rnase_values <- as.numeric(protein_row[seq(2, 50, by=2)])
  fractions <- 1:25
  max_val <- max(ctrl_values, rnase_values, na.rm = TRUE)
  ylim_range <- c(0, max_val * 1.2)

  #core plot function using crtl_values
  plot(fractions, ctrl_values, type="o", pch=20, lty=1, lwd = 1.5,  col="forestgreen", ylim= ylim_range,
       xlab="Fraction", ylab="Normalized Intensity", main= protein_of_interest, axes = FALSE)
       
  #add line for rnase_values
  lines(fractions, rnase_values, type="o",pch =20, lty=1, lwd = 1.5,  col="firebrick3")
  
  #color area under the curve
  polygon(c(fractions, rev(fractions)), 
          c(ctrl_values, rep(0, length(ctrl_values))), 
          col=adjustcolor("forestgreen", alpha.f=0.1), border=NA)
  
  polygon(c(fractions, rev(fractions)), 
          c(rnase_values, rep(0, length(rnase_values))), 
          col=adjustcolor("firebrick3", alpha.f=0.1), border=NA)
  
  #add x- and y-achsis with correct lables
  axis(1, at = 1:25, labels = 1:25, cex.axis = 0.7)
  axis(2, cex.axis = 0.7, las =2)
  grid(nx = NULL, ny = NULL, col = "lightgray", lty = "dotted", lwd = 0.8)

  #add legend
  legend("topright", legend=c("Ctrl", "RNase"), col=c("forestgreen", "firebrick3"), 
         lty=1, lwd = 1.5,  pch=20, bg = "white", bty = "o", box.col = NA, horiz = TRUE)
  
  #Info panel
  par(mar = c(0, 0, 2, 0))  # rechte Fläche: keine Achsen
  plot.new()
  
  shift_info <- subset_data_S[rownames(subset_data_S) == x, ]
  protein_info <- protein_data[protein_data$Entry == x, ]
  info_lines <- c(
    paste("CoM Ctrl:",round(shift_info$CoM_Ctrl_mitosis, 1)),
    paste("CoM RNase:", round(shift_info$CoM_RNase_mitosis, 1)),
    paste("Shift Distance:", round(shift_info$shift_distance_mitosis, 1)),
    paste("Identified as RBP:", shift_info$significant_ttest_filtered_mitosis),
    paste("Known Complex (CORUM):", protein_info$CORUM_member),
    paste("Weight (monomeric):", round(protein_info$MolecularWeight_kDa, 2) ,"kDA")
  )
  line_height <- 0.06
  n_lines <- length(info_lines)
  y_start <- 0.5 + (n_lines - 1) * line_height / 2
  for (i in seq_along(info_lines)) {
    y_pos <- y_start - (i - 1) * line_height
    text(x = 0, y = y_pos, labels = info_lines[i], adj = c(0, 1), cex = 0.9)
    }
}

plot_protein_info("RL27_HUMAN")
```


# Linear Regression Analysis - Trying to predict molecular weight through peak position - Lina
--> this method can not be used to predict molecular weight, no sufficient correlation or relevant regression model
--> Possible reasons: 
- position in gradient not only depends on weight and but also densitiy and shape of the protein
- proteins remain in RNA independend complexes after RNase treatment (we tried to exclude all proteins listed in complexes in CORUM databank, however there was still no relevant correlation)
- model using max peak position or CoM are to simplified (data is much more complex)
```{r}
# Find maximal peak position of each protein and build data frame together mit data for molecular weight
max_peak_positions <- numeric(nrow(Peak_Data))

for (p in seq_len(nrow(Peak_Data))) {
  p_data <- Peak_Data [p,]
  peak_heights <- as.numeric(p_data[, paste0("peak", 1:6, "_height_RNase")])
  peak_positions <- as.numeric(p_data[, paste0("peak", 1:6, "_position_RNase")])
  
  if (all(is.na(peak_heights))) {
    max_peak_positions[p] <- NA
  } else {
    max_idx <- which.max(peak_heights)
    max_peak_positions[p] <- peak_positions[max_idx]
  }
  
}  
Protein_Data_for_LR <- data.frame(max_peak_position_RNase = max_peak_positions)
rownames(Protein_Data_for_LR) <- rownames(Peak_Data)

Protein_Data_for_LR$MolecularWeight_kDa <- protein_data$MolecularWeight_kDa
Protein_Data_for_LR$CoM_RNase <- Shift_Data$CoM_RNase

# Try linear regression with maximum peak position

# Correlation tests for molecular weight with maximal peak position 
cor.test(Protein_Data_for_LR$max_peak_position_RNase,
         Protein_Data_for_LR$MolecularWeight_kDa,
         method = "spearman", use = "complete.obs")

# Linear regression models for molecular weight prediction with maximal peak position
lm_model_peak_position <- lm(MolecularWeight_kDa ~ max_peak_position_RNase, data = Protein_Data_for_LR)
summary(lm_model_peak_position)

# five reference proteins analysed with known molecular weight and fraction by Caudron et al.
reference_proteins <- data.frame(
   x = c(3, 6, 9, 11, 14),
   y = c(14, 65, 160, 240, 480),
   name = c("RNaseA 14kDa", "BSA 65kDa", "Aldolase 4*40kDa", "Catalase 4*60kDa", "Ferritin 4*40 kDa") 
)
linear_reference <- lm(y ~ x, data = reference_proteins)

# Scatter plots of molecular weight and maximal peak position, with "expected" linear correlation and complex data

CORUM_comlexes <- protein_data[protein_data$CORUM_member == TRUE, ]
CORUM_comlexes <- Protein_Data_for_LR[rownames(Protein_Data_for_LR) %in% CORUM_comlexes$Entry, ]

library(ggplot2)
library(dplyr)
ggplot(Protein_Data_for_LR %>% filter(MolecularWeight_kDa <= 1000), aes(x = max_peak_position_RNase, y = MolecularWeight_kDa)) +
  geom_point(aes(color = "All analysed Proteins")) +
  geom_point(data = CORUM_comlexes,aes(x = max_peak_position_RNase, y = MolecularWeight_kDa, color = "Proteins in Complex (CORUM)"),alpha = 0.5)  +
  geom_abline(intercept = coef(linear_reference)[1], 
              slope = coef(linear_reference)[2], 
              color = "darkred", size = 1) +
  geom_point(data = reference_proteins, aes(x = x, y = y), color = "darkred", size = 3) +
  geom_text(data = reference_proteins[c(1), ], aes(x = x, y = y, label = name),
            vjust = -1,   hjust = 0.6, color = "darkred", size = 4, fontface = "bold") +
  geom_text(data = reference_proteins[c(5), ], aes(x = x, y = y, label = name),
            vjust = 0.3 ,   hjust = 1.2, color = "darkred", size = 4, fontface = "bold") +
  geom_text(data = reference_proteins[c(2, 3, 4), ], aes(x = x, y = y, label = name),
            vjust = 0.3,   hjust = -0.2, color = "darkred", size = 4, fontface = "bold") +
  theme_classic() + theme(legend.position =  c(0.2, 0.85)) +
  scale_color_manual(values = c("All analysed Proteins" = "gray75", "Proteins in Complex (CORUM)" = "lightcoral")) +
  labs(x = "Peak Position", y = "Molecular Weight (kDa)", color = "Protein Category", 
    title = "Molecular Weight vs. Peak Position ")

#Same but this time trying with CoM

# Correlation
cor.test(Protein_Data_for_LR$CoM_RNase,
         Protein_Data_for_LR$MolecularWeight_kDa,
         method = "spearman", use = "complete.obs")

# Linear Regression
lm_model_CoM <- lm(MolecularWeight_kDa ~ CoM_RNase, data = Protein_Data_for_LR)
summary(lm_model_CoM)

#Scatter Plot
ggplot(Protein_Data_for_LR %>% filter(MolecularWeight_kDa <= 1000), aes(x = CoM_RNase, y = MolecularWeight_kDa)) +
  geom_point(aes(color = "All analysed Proteins")) +
  geom_point(data = CORUM_comlexes,aes(x = CoM_RNase, y = MolecularWeight_kDa, color = "Proteins in Complex (CORUM)"),alpha = 0.5)  +
  geom_abline(intercept = coef(linear_reference)[1], 
              slope = coef(linear_reference)[2], 
              color = "darkred", size = 1) +
  geom_point(data = reference_proteins, aes(x = x, y = y), color = "darkred", size = 3) +
  geom_text(data = reference_proteins[c(1), ], aes(x = x, y = y, label = name),
            vjust = -1,   hjust = 0.6, color = "darkred", size = 4, fontface = "bold") +
  geom_text(data = reference_proteins[c(5), ], aes(x = x, y = y, label = name),
            vjust = 0.3 ,   hjust = 1.2, color = "darkred", size = 4, fontface = "bold") +
  geom_text(data = reference_proteins[c(2, 3, 4), ], aes(x = x, y = y, label = name),
            vjust = 0.3,   hjust = -0.2, color = "darkred", size = 4, fontface = "bold") +
  theme_classic() + theme(legend.position =  c(0.2, 0.85)) +
  scale_color_manual(values = c("All analysed Proteins" = "gray75", "Proteins in Complex (CORUM)" = "lightcoral")) +
  labs(x = "CoM_RNase", y = "Molecular Weight (kDa)",  color = "Protein Category", title = "Molecular Weight vs. CoM_RNase")

```



















# TRY AND ERROR (BackUP)

#doing a PCa analysis in order to look at the distribution of RBPS => could be applyed to selected RBPs from mytosis - Sofia
```{r}
# Load required package
library(ggplot2)

# Assume your data is in a data frame called 'df'
# Rows = proteins, Columns = the 26 features you mentioned
# First, remove rows with any NA values
Peak_Data_clean <- na.omit(Peak_Data)

# Remove columns with zero variance
Peak_Data_clean_clean <- Peak_Data_clean[, apply(Peak_Data_clean, 2, function(col) sd(col, na.rm = TRUE) != 0)]

# Perform PCA (center and scale the data)
pca_result <- prcomp(Peak_Data_clean_clean, center = TRUE, scale. = TRUE)

# Extract the scores for the first two principal components
pc_scores <- as.data.frame(pca_result$x[, 1:2])

# Add protein names as a column (assuming they are rownames)
pc_scores$Protein <- rownames(pc_scores)

# Create a new column that marks whether the protein is in t_test_positives (taken from further steps of the analysis)

pc_scores$Significant <- ifelse(pc_scores$Protein %in% t_test_positives, "Yes", "No")

# Plot the PCA
ggplot(pc_scores, aes(x = PC1, y = PC2, color = Significant)) +
  geom_point(alpha = 0.7, size = 1.5) +
  scale_color_manual(values = c("Yes" = "red", "No" = "black")) +
  theme_minimal() +
  labs(title = "PCA of Protein Features (highlighting significant proteins)",
       x = "PC1", y = "PC2", color = "Significant")

```

## Cluster Cihan Try
```{r}
# 1) Filter only the RBPs relevant in Mitosis 
filtered_shift_Mitosis <- Shift_Data[rownames(Shift_Data) %in% RBPs_Mitosis, ]
filtered_peak_Mitosis <- Peak_Data[rownames(Peak_Data) %in% RBPs_Mitosis, ]

# 2) Selecting only the interesting Ctrl peak columns 
ctrl_peak_cols_cluster <- grep("_Ctrl$", colnames(filtered_peak_Mitosis), value = TRUE)
merged_filterd_mitosis <- filtered_peak_Mitosis[, ctrl_peak_cols_cluster]

# 3) Clean data
merged_filterd_mitosis[is.na(merged_filterd_mitosis)] <- 0

clean2_merged_filterd_mitosis <- merged_filterd_mitosis[, apply(merged_filterd_mitosis, 2, function(col) sd(col) != 0)]

# 4) Prepare matrix for clustering
clean2_merged_filterd_mitosis <- as.matrix(clean2_merged_filterd_mitosis)

# 5) Distance and hierarchical clustering
dist_matrix <- dist(clean2_merged_filterd_mitosis)
hc_ward <- hclust(dist_matrix, method = "ward.D2")

# 6) Plot dendrogram
par(mfrow = c(1,1), mar = c(5, 4, 4, 2))
plot(hc_ward,
     labels = FALSE,
     main = "Ward's Method",
     xlab = "", ylab = "Height",
     cex = 1.2,
     hang = -1)

# 7) Assign clusters (e.g., k = 6)
cluster_membership <- cutree(hc_ward, k = 10)

# 8) Store clustering result in a data frame
protein_clusters <- data.frame(
  Protein = rownames(clean2_merged_filterd_mitosis),
  Cluster = cluster_membership
)

# 9) Sort by cluster number
protein_clusters_sorted <- protein_clusters[order(protein_clusters$Cluster), ]

table(protein_clusters_sorted$Cluster)

# 11) Optional: Plot proteins in a selected cluster, e.g., cluster 5
cluster5_proteins <- protein_clusters_sorted[protein_clusters_sorted$Cluster == 8, "Protein"]

for (r in cluster5_proteins) {
  plot_protein(r)
}







library(cluster)

# Distanzmatrix und hclust musst du vorher schon haben:
# dist_matrix <- dist(peak_matrix)
# hc_ward <- hclust(dist_matrix, method = "ward.D2")

sil_scores <- numeric()

# Schleife für k = 2 bis 10
for (k in 2:10) {
  cluster_assignments <- cutree(hc_ward, k = k)
  sil <- silhouette(cluster_assignments, dist_matrix)
  sil_scores[k] <- mean(sil[, 3])  # Durchschnittliche Silhouettenbreite
}

# Plot
plot(2:10, sil_scores[2:10], type = "b", pch = 19,
     xlab = "Anzahl Cluster (k)",
     ylab = "Durchschnittliche Silhouettenbreite",
     main = "Silhouettenanalyse für hierarchisches Clustering")



```

## Zweiter Chunk des Clusters
```{r}
# 1. peak1_position_Ctrl & peak1_height_Ctrl vorbereiten
peak1_df <- data.frame(
  Protein = rownames(Peak_Data),
  peak1_position_Ctrl = Peak_Data$peak1_position_Ctrl,
  peak1_height_Ctrl = Peak_Data$peak1_height_Ctrl
)

# 2. Merge mit den Clusterzuordnungen
peak_data_with_clusters <- merge(
  protein_clusters_sorted,
  peak1_df,
  by = "Protein"
)

# 3. Leere Liste zur Speicherung der gefilterten Cluster initialisieren
filtered_clusters <- list()

# 4. Schleife über alle Cluster
for (cl in unique(peak_data_with_clusters$Cluster)) {
  cluster_subset <- subset(peak_data_with_clusters, Cluster == cl)
  
  # Rundung auf ganze Zahlen zur Peakgruppierung
  peak_pos <- round(cluster_subset$peak1_position_Ctrl)
  
  # Häufigste Peakposition
  freq_table <- table(peak_pos)
  if (length(freq_table) == 0) next  # überspringe leeren Cluster
  top_peak <- as.numeric(names(freq_table)[which.max(freq_table)])
  
  # Erlaubte Positionen (±1)
  allowed_range <- (top_peak - 1):(top_peak + 1)
  
  # Filter: Position innerhalb Range & Höhe mindestens 5
  keep <- peak_pos %in% allowed_range & cluster_subset$peak1_height_Ctrl >= 5
  filtered <- cluster_subset[keep, ]
  
  # Speichern
  filtered_clusters[[paste0("Cluster_", cl)]] <- filtered
}

# 5. Alle gefilterten Cluster zusammenführen
final_filtered_proteins <- do.call(rbind, filtered_clusters)

# 6. Export als CSV
write.csv(final_filtered_proteins, "RBP_FilteredByPeakPosition.csv", row.names = FALSE)

# 7. Übersicht anzeigen
table(final_filtered_proteins$Cluster)
#

## Plotten, nie streichen
cluster3_proteins_final <- final_filtered_proteins[final_filtered_proteins$Cluster == 8, "Protein"]

for (r in cluster3_proteins_final) {
  plot_protein(r)
}




```

##looking at standart deviation and mean to get an idea 

```{r}


# create empty vectors to store the values

sd_values <- numeric(25)
mean_values <- numeric(25)

# create loop for all 25 fractions 
for (i in 1:25) {
  # Define replicate labels ( RNAse or Ctrl)
  reps <- paste0("RNAse_Rep", 1:3)
  
  # Filter just the current fraction and replicates
  subset_data <- data[data$fraction == paste0("Fraction_", i) & data$replicate %in% reps, ]
  
  # Extract abundance values
  values <- subset_data$abundance
  
  # Compute standard deviation + compute mean
  sd_values[i] <- sd(values)
  
  mean_values[i] <- mean(values)
}

# Create result table 
result_tablesd <- data.frame(
  Fraction = paste0("Fraction_", 1:25),
  SD = sd_values
)
result_tablesd

result_tablemean <- data.frame(
  Fraction = paste0("Fraction_", 1:25),
  MEAN = mean_values
)
result_tablemean

```

##trzing to run Pearson correlation for all proteins => for now between Repetitions Rep1 and Rep2 across 25 fractions for Ctrl and RNase seperatly 

#1) frist creating a long format table with=> Protein names repeat themselfs for all combinations maybe this is the problem 


```{r}
# Load necessary packages
library(dplyr)
library(tidyr)

#naming coloum for Protein names with Protein so i can run my code => this is ugly open for suggestions

MS_Table$Protein <- rownames(MS_Table)
MS_Table2 <- MS_Table %>% relocate(Protein)
head(MS_Table2)

# Step 2: Pivot longer — convert the wide columns into long format
# The first column is protein names, so we keep it as id

ms_long <- MS_Table %>%
  pivot_longer(
    cols = -Protein,  # all columns except the first (protein names)
    names_to = "Condition",  # temporary column to store original column names
    values_to = "Value"      # this column will store the measured values
  )

# Step 3: Separate 'Condition' into Fraction, Treatment, and Replicate
ms_long <- ms_long %>%
  separate(
    col = Condition,
    into = c("Fraction", "Treatment", "Replicate"),
    sep = "_"
  )

# Step 4: Extract the numeric fraction number (since it's like 'Fraction1')
ms_long <- ms_long %>%
  mutate(
    Fraction = as.numeric(sub("Fraction", "", Fraction))
  )

# Step 5: Rename first column to "Protein" (if it's not already)
names(ms_long)[1] <- "Protein"

# Optional: Check result
head(ms_long)
rownames(ms_long)


# Now you have your tidy table:
# Protein | Fraction | Treatment | Replicate | Value



```


#2) with table trying to run pearson correlation 

```{r}

library(dplyr)
library(tidyr)

# First: keep only the replicates we want
filtered <- ms_long %>%
  filter(Replicate %in% c("Rep1", "Rep2"),
         Treatment %in% c("Ctrl", "RNAse"),
         Fraction %in% paste0("Fraction_", 1:25))

# Then: calculate correlation per protein + treatment
results <- filtered %>%
  group_by(Protein, Treatment) %>%
  pivot_wider(
    names_from = Replicate,
    values_from = Value,
    values_fill = list(abundance = 0)   # fill missing values with 0
  ) %>%
  summarise(correlation = cor(Rep1, Rep2), .groups = "drop")  # here something dosent work=> Rep2 is not recognized 

# Print results
print(results)

ms_long %>%
  count(Protein, Treatment)



```


# completly new shit just trying to see if the normalisation was the reason our PC analysis wasnt working, maybe a interesting thing to look for further steps in the pipeline
```{r}
                        # neue Normalization that maybe works better: 


# Log2 transformation (adding 1 to avoid log(0))
MS_log <- log2(MS_Table_Averages + 1)

# Row-wise z-score scaling: center and scale each protein across all samples (fractions)
MS_scaled <- t(scale(t(MS_log)))

rownames(MS_scaled) <- rownames(MS_Table_Averages)

# Optional: check a few rows
head(round(MS_scaled, 2))

#filter proteins with low variance 
# 1. Compute variance across proteins (handle NAs)
var_filter <- apply(MS_scaled, 1, var, na.rm = TRUE)

# 2. Compute the 75th percentile of variance, handling NAs in var_filter
threshold <- quantile(var_filter, 0.75, na.rm = TRUE)

# 3. Filter for high-variance proteins
MS_highvar <- MS_scaled[var_filter > threshold, ]

# If any are missing, fix them by assigning unique names

rownames(MS_highvar) <- make.names(rownames(MS_highvar), unique = TRUE)



                         # Linas code zu Peak characterization just applyed to my code 



# fractions = x
x <- 1:25

# define treshold for peak and build function for peak detection
find_peaks <- function(y, threshold = max(y) * 0.03) { 
  peaks <- which(diff(sign(diff(y))) == -2) + 1 #(+1 shifts index back)
  peaks[y[peaks]>= threshold] 
}

# create empty list for results
peak_results <- list()

# for loop over every protein
for (p in seq_len(nrow(MS_highvar))) {
  
  # extract values for Ctrl and RNase
  row_vals <- as.numeric(MS_highvar [p,])
  ctrl_vals <- row_vals[seq(1, 50, by =2)]
  rnase_vals <- row_vals[seq(2, 50, by=2)]
  
  # create empty list for results
  results_row <- list()
  
  # for loop working with Ctrl values first, then with RNase values
  for (cond in c("Ctrl", "RNase")) {
    y <- if (cond == "Ctrl") ctrl_vals else rnase_vals 
    
    # find peaks with earlier build function, if no peak is detected peak1 is max intensity
    peaks <- find_peaks(y)
    if(length(peaks) == 0) {
      peaks <- which.max(y)
    }
    
    # store numer of peaks, but with a maximum of 6 
    n_peaks <- min(length(peaks), 6)
    
    # extract peak height y_peaks and peak position x_peaks
    y_peaks <- y[peaks]
    x_peaks <- x[peaks]

    # store different results in list 
    results_row[[paste0("n_peaks_", cond)]] <- n_peaks
    
    for(n in seq_len(n_peaks)) {
    results_row[[paste0("peak", n, "_height_", cond)]] <- y_peaks[n]
    results_row[[paste0("peak", n, "_position_", cond)]] <- x_peaks[n]
    }
  }
  # store protein results in lisr
  peak_results[[p]] <- results_row
}

# befor we can store data in new dataframe, we need to assign NA to all columns that have no values 
rows_df <- lapply(peak_results, function(x){
  columns <- c("peak1_height", "peak1_position", "peak2_height", "peak2_position", "peak3_height", "peak3_position", "peak4_height", "peak4_position", "peak5_height", "peak5_position", "peak6_height", "peak6_position")
  for (cond in c("Ctrl", "RNase")) {
    for (c in columns) {
      key <- paste0(c, "_", cond)
      if(!(key %in% names(x))) {
        x[[key]] <- NA
      }
    }
  }
  as.data.frame(x)
})

# store results in new DataFrame (note: rows_df is a list of dataframes so we need "do.call(r.bind,...)")
Peak_Data2 <- do.call(rbind, rows_df)
rownames(Peak_Data2) <- rownames(MS_highvar)

# reorder columns of Peak_Data2
order <- c("n_peaks_Ctrl", "n_peaks_RNase")

for (i in 1:6) {
  order <- c(order, 
                 paste0("peak", i, "_height_Ctrl"),
                 paste0("peak", i, "_position_Ctrl"),
                 paste0("peak", i, "_height_RNase"),
                 paste0("peak", i, "_position_RNase"))
}

Peak_Data2 <- Peak_Data2[, order]

# show head of PeakData to check 
head(Peak_Data2)

colnames(Peak_Data2)




                          # PCa jetzt auf neue daten runnen + vergleich zu RBPs 


# Load required package
library(ggplot2)


# Assume your data is in a data frame called 'df'
# Rows = proteins, Columns = the 26 features you mentioned
# First, remove rows with any NA values
Peak_Data_clean <- na.omit(Peak_Data2)

# Remove columns with zero variance
Peak_Data_clean_clean <- Peak_Data_clean[, apply(Peak_Data_clean, 2, function(col) sd(col, na.rm = TRUE) != 0)]

# Perform PCA (center and scale the data)
pca_result <- prcomp(Peak_Data_clean_clean, center = TRUE, scale. = TRUE)

# Extract the scores for the first two principal components
pc_scores <- as.data.frame(pca_result$x[, 1:2])

# Add protein names as a column (assuming they are rownames)
pc_scores$Protein <- rownames(pc_scores)

# Create a new column that marks whether the protein is in t_test_positives (taken from further steps of the analysis)

pc_scores$Significant <- ifelse(pc_scores$Protein %in% t_test_positives, "RBPs", "No")

# Plot the PCA
ggplot(pc_scores, aes(x = PC1, y = PC2, color = Significant)) +
  geom_point(alpha = 0.7, size = 1.5) +
  scale_color_manual(values = c("RBPs" = "red", "No" = "black")) +
  theme_minimal() +
  labs(title = "PCA of Protein Features (highlighting significant proteins)",
       x = "PC1", y = "PC2", color = "Significant")


```

# lets run it on shift charachteristics 


```{r}

# Select the 4 columns to use for PCA
pca_input <- Shift_Data[, c("CoM_Ctrl", "CoM_RNase", "shift_distance", "shift_direction")]

# Remove rows with NA values
pca_input_clean <- na.omit(pca_input)

# Optionally remove constant columns
pca_input_clean <- pca_input_clean[, apply(pca_input_clean, 2, function(col) sd(col, na.rm = TRUE) != 0)]

# Run PCA
pca_result <- prcomp(pca_input_clean, center = TRUE, scale. = TRUE)

# Extract scores and add protein names
pc_scores <- as.data.frame(pca_result$x[, 1:2])
pc_scores$Protein <- rownames(pca_input_clean)

# Mark significant proteins
pc_scores$Significant <- ifelse(pc_scores$Protein %in% t_test_positives, "RBPs", "No")

# Plot
ggplot(pc_scores, aes(x = PC1, y = PC2, color = Significant)) +
  geom_point(alpha = 0.7, size = 1.5) +
  scale_color_manual(values = c("RBPs" = "red", "No" = "black")) +
  theme_minimal() +
  labs(title = "PCA on shift distance", x = "PC1", y = "PC2", color = "Significant")

```




# ok people ich bin bored also mach ich jetzt noch kmeans clustering nur auf RBPs in mitosis 
```{r}
# Filter only the RBPs relevant in Mitosis 
filtered_data_shift <- Shift_Data[rownames(Shift_Data) %in% RBPs_Mitosis, ]

# Load your dataset (CSV or kmeans frame)
kmeans <- filtered_data_shift # Replace with your file or data frame


# Select 4 specific columns by name or position


K <- kmeans[, c("CoM_Ctrl", "CoM_RNase", "shift_distance")]  # Replace with column names

K <- na.omit(K)          # Remove rows with any NA
K <- as.matrix(K)        # Ensure it’s still a numeric matrix


# Convert to matrix
K <- as.matrix(K)

# K-means clustering
k <- 3                    #number of clusters 
set.seed(42)
kmeans_result <- kmeans(K, centers = k) # here i put in my data 

# Reduce to 2D with PCA
pca_results <- prcomp(K, scale. = TRUE)
K_2D <- pca_results$x[, 1:2]

# Plot clusters
plot(K_2D, col = kmeans_result$cluster, pch = 19,
     main = "K-means Clustering (PCA-reduced 2D)",
     xlab = "PC1", ylab = "PC2")
legend("topright", legend = paste("Cluster", 1:k), col = 1:k, pch = 19)





```

## Test for Normal Distribution (requirement for t-test) 
- Description nessesary and all code descriptions in english
```{r}
# Pakete laden 
library(dplyr)

# Leere Liste für Zwischenspeicherung 
results_list <- list()
counter <- 1

# Proteine durchlaufen
for (protein in rownames(MS_Table)) {
  
  for (fraction_num in 1:25) {
    
    # Die korrekten Spaltennamen für Ctrl generieren
    cols_ctrl <- paste0("Fraction", fraction_num, "_Ctrl_Rep", 1:3)
    
    # Prüfen ob alle Spalten existieren 
    existing_cols <- cols_ctrl[cols_ctrl %in% colnames(MS_Table)]
    
    if(length(existing_cols) == 3){
      
      # Werte extrahieren
      protein_values <- as.numeric(MS_Table[protein, existing_cols])
      
      # Nur testen, wenn es Streuung gibt
      if (length(unique(protein_values)) > 1) {
        shapiro_result <- shapiro.test(protein_values)
        shapiro_W <- shapiro_result$statistic
        shapiro_p <- shapiro_result$p.value
      } else {
        shapiro_W <- NA
        shapiro_p <- NA
      }
      
      # Zwischenspeichern
      results_list[[counter]] <- data.frame(
        Protein_ID = protein,
        Fraction = fraction_num,
        Shapiro_W = shapiro_W,
        Shapiro_p = shapiro_p
      )
      counter <- counter + 1
    }
  }
}

# Am Ende alles zusammenfügen
shapiro_results <- do.call(rbind, results_list)

# Entscheidung über Normalverteilung ergänzen
shapiro_results$Is_Normal_Distributed <- shapiro_results$Shapiro_p >= 0.05

# Ergebnisse ausgeben
head(shapiro_results)

# Übersicht wie viele normalverteilt
table(shapiro_results$Is_Normal_Distributed)
```


# without negative test
```{r}
library(ggplot2)

# --- Step 1: Define your proteins of interest ---
target_proteins <- c("RS12_HUMAN", "RS26_HUMAN", "RS2_HUMAN", "RS6_HUMAN") # Replace with your real protein names


# --- Step 3: Generate all unique protein pairs ---
protein_pairs <- combn(target_proteins, 2, simplify = FALSE)

# --- Step 4: Initialize container for scoring results ---
score_results <- data.frame()

# --- Step 5: Loop through all parameter combinations ---
for (col_name in colnames(results_df)) {
  
  cluster_assignments <- as.numeric(results_df[[col_name]])  # ensure numeric
  names(cluster_assignments) <- rownames(results_df)         # preserve protein names
  
  pair_scores <- c()
  
  for (pair in protein_pairs) {
    p1 <- pair[1]
    p2 <- pair[2]
    
    # Retrieve cluster numbers
    c1 <- cluster_assignments[p1]
    c2 <- cluster_assignments[p2]
    
    # Scoring logic with full NA protection
    if (is.na(c1) || is.na(c2)) {
      score <- NA
    } else if (c1 == 0 || c2 == 0) {
      score <- 0
    } else if (c1 == c2) {
      score <- 1
    } else {
      score <- -1
    }
    
    pair_scores <- c(pair_scores, score)
  }
  
  # Calculate average score, excluding NA
  avg_score <- mean(pair_scores, na.rm = TRUE)
  
  # Extract eps and minPts from column name
  parts <- strcapture("eps_([0-9.]+)_minPts_([0-9]+)", col_name, data.frame(eps = 0, minPts = 0))
  
  score_results <- rbind(score_results, data.frame(
    eps = as.numeric(parts$eps),
    minPts = as.numeric(parts$minPts),
    score = avg_score
  ))
}

# --- Step 6: Plot heatmap ---
ggplot(score_results, aes(x = eps, y = minPts, fill = score)) +
  geom_tile(color = "grey70") +
  scale_fill_gradient2(low = "red", mid = "white", high = "blue", midpoint = 0, limits = c(-1, 1)) +
  labs(title = "Clustering Consistency of Protein Pairs",
       subtitle = "Based on DBSCAN parameter combinations",
       x = "Epsilon (ε)",
       y = "MinPts",
       fill = "Avg. Pair Score") +
  theme_minimal()

#c("RL22_HUMAN", "RL23_HUMAN", "RL24_HUMAN" , "RL27_HUMAN" , "RL30_HUMAN" , "RL34_HUMAN" , "RLA1_HUMAN")

```
 