---
title: "2025-topic-03-group-02-code"
output: html_document
date: "2025-05-16"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

##Loading MS-Data
```{r}
MS_Table <- read.table("RDeeP_HeLa_Mitosis.csv", header = TRUE, row.names = 1, sep = ";")
```

# Data Cleanup
## Despription of the Data
```{r}
n_rows = nrow(MS_Table) 
n_rows # Number of Proteins
n_cols = ncol(MS_Table) 
n_cols # Number of varibale
unique(sapply(MS_Table, class)) # classification of variables
any(is.na(MS_Table)) # missing values
min(MS_Table) # minimum intensity
max(MS_Table) # maximum intensity
```

## Restructuration of the data
Create a dataframe with factors that make it possible to access specific data from MS_Table
```{r}
treatment <- factor(rep(c("Ctrl", "RNAse"), each = 3, length.out = 150))
replicate <- factor(rep(c("Ctrl_Rep1", "Ctrl_Rep2", "Ctrl_Rep3", "RNAse_Rep1","RNAse_Rep2", "RNAse_Rep3"),25))
fraction <- factor(rep(paste0("Fraction_", 1:25), each = 6))

data <- data.frame(rownames = colnames(MS_Table),treatment = treatment, replicate = replicate, fraction = fraction)
data
```
## Normalization of triplicates 
Create a new dataframe with average values of the replicates 
```{r}
average.list <- list() #create list

# for loop, going through all fractions: 
# selecting Ctrl columns for specific fraction
# computing average of these columns 
# adding a new vector to list e.g."Ctrl_Fraction_1" and assigning average values 

for (f in levels(fraction)) {
  
  cols.Ctrl <- which(fraction == f & treatment == "Ctrl") 
  average.Ctrl <- rowMeans(MS_Table[,cols.Ctrl]) 
  average.list[[paste0("Ctrl_",f)]] <- average.Ctrl # paste0 funktion checken
  
  cols.RNAse <- which(fraction == f & treatment == "RNAse")
  average.RNAse <- rowMeans(MS_Table[,cols.RNAse])
  average.list[[paste0("RNAse_",f)]] <- average.RNAse
}

MS_Table_Averages <- as.data.frame(average.list) #convert list to dataframe
rownames(MS_Table_Averages) <- rownames(MS_Table) #assign Protein IDs to average values

#Define new order of columns ("levels" works in alphabetic order, not useful for us)
fractions <- paste0("Fraction_", 1:25)

ordered_names <- as.vector(rbind(
  paste0("Ctrl_", fractions),
  paste0("RNAse_", fractions)
))

MS_Table_Averages <- MS_Table_Averages[, ordered_names]
head(MS_Table_Averages)
```
## Normalization to 100 
Create a new dataframe in which the values for each protein are scaled so that the distribution within the Ctrl and RNAse conditions each sums to 100
--> Note: QQ Plots für Normalverteilung 
```{r}
# Split up Control and RNAse values 
ctrl_cols <- grep("^Ctrl_", colnames(MS_Table_Averages)) # grep function genauer schauen 
rnase_cols <- grep("^RNAse_", colnames(MS_Table_Averages))
# Normalization of each group to 100 
ctrl_norm <- MS_Table_Averages[, ctrl_cols] / rowSums(MS_Table_Averages[, ctrl_cols]) * 100
rnase_norm <- MS_Table_Averages[, rnase_cols] / rowSums(MS_Table_Averages[, rnase_cols]) * 100
# Combine in one table 
MS_Table_Norm <- cbind(ctrl_norm, rnase_norm)
MS_Table_Norm <- MS_Table_Norm[, colnames(MS_Table_Averages)]
head(round(MS_Table_Norm, 2))
# Verify the calculation with one example; the row sum should be ~200 (Ctrl 100% + RNAse 100%)
rowSums(MS_Table_Norm["1433B_HUMAN", ]) 
```
## Reproducibility Analysis
```{r}

```

# Data Analysis
## Gaussian Fitting
--> Wir müssen Multi-Gaus_fitting verwenden, da wir manchmal mehr als eine Peak haben (ich habe mich entschieden 1-3 Peraks zu analysieren)
--> Probleme zu überdenken: Er macht das mit den Ersatz Peak Werten jetzt für fast alle restlichen Proteine, aber wär gut wenn er kurven auch bei Proteinen mit schlechten Werten, aber Proteinen mit mehr als einem Wert machen würde 
--> 1215 Proteine haben nur einen Intensitätswert bei Ctrl und RNAse und werden durch meine Lösung berücksichtigt (also wichtig, aber erklärt nicht die restlichen 1000-2000 Proteine) 

```{r}
# load package to use a stury fuction for gaussian fitting, that also works with critical starting values and sloping curves
library(minpack.lm)

# build multi gaussian sumfuction up to 3 peaks (for later use)
multi_gauss <- function(x, A1, mu1, sigma1,
                        A2 = 0, mu2 = 0, sigma2 = 1,
                        A3 =0, mu3 = 0, sigma3 = 1) {
  A1 * exp(-(x - mu1)^2 / (2 * sigma1^2)) + 
    A2 * exp (-(x - mu2)^2 / (2* sigma2^2)) + 
    A3 * exp(-(x - mu3)^2 / (2* sigma3^2))
}

# build fuction for determination of number of peaks on raw data (for later use)
t = max(y) * 0.03 
find_peaks <- function(y, threshold = t) { 
  peaks <- which(diff(sign(diff(y))) == -2) + 1 #funktion um peaks rauszusuchen durch Steigungsberechnung/änderung (siehe Foto)
  peaks[y[peaks]>= threshold] # [peaks] = peak intensität
}

# create list for results
fit_results <- list()

# x-achsis for fited curves (fraction 1-25)
x <- 1:25

#fitting of every protein (Ctrl and RNAse) using for-loops
# for loop that goes throu every protein/row
for (p in seq_len(nrow(MS_Table_Norm))) {
  protein_id <- rownames(MS_Table_Norm)[p]
  row_vals <- as.numeric(MS_Table_Norm [p,])
  ctrl_vals <- row_vals[seq(1, 50, by =2)]
  rnase_vals <- row_vals[seq(2, 50, by=2)]
  
  results_row <- list(Protein_ID = protein_id)
  
  # for loop that first works with Ctrl, then RNase values 
  for (cond in c("Ctrl", "RNAse")) {
    y <- if (cond == "Ctrl") ctrl_vals else rnase_vals
    peaks <- find_peaks(y)
    if(length(peaks) == 0) {
      peaks <- which.max(y)
    }
    n_peaks <- min(length(peaks),3)
    
    y_peaks <- y[peaks]
    x_peaks <- x[peaks]
    
    #define start values for up to three peaks
    
    starts <- list(A1 = y_peaks[1], mu1 = x_peaks[1], sigma1 = 2)
    if (n_peaks >= 2) {
      starts <- c(starts, list(A2 = y_peaks[2], mu2 = x_peaks[2], sigma2 = 2)) }
      else {
        starts <- c(starts, list(A2 = 0, mu2 = 0, sigma2 = 2))}
    if (n_peaks == 3) {
      starts <- c(starts, list(A3 = y_peaks[3], mu3 = x_peaks[3], sigma3 = 2)) }
      else {
        starts <- c(starts, list(A3 = 0, mu3 = 0, sigma3 = 2))}

  
    # fitting with our multi gaussian fuction and try(), collect fit data in vector
    if (n_peaks == 1) {
      fit <- try(nlsLM(y ~ A1 * exp(-(x - mu1)^2 / (2 * sigma1^2)),
                 start = list(A1 = y_peaks[1], mu1 = x_peaks[1], sigma1 = 2),
                 control = list(maxiter = 500, warnOnly = TRUE)),
                 silent = TRUE)
      } 
    else if (n_peaks == 2) {
      fit <- try(nlsLM(y ~ multi_gauss(x, A1, mu1, sigma1, A2, mu2, sigma2),
                 start = list(A1 = y_peaks[1], mu1 = x_peaks[1], sigma1 = 2,
                              A2 = y_peaks[2], mu2 = x_peaks[2], sigma2 = 2),
                 control = list(maxiter = 500, warnOnly = TRUE)),
                 silent = TRUE)
      } 
    else {
        fit <- try(nlsLM(y ~ multi_gauss(x, A1, mu1, sigma1, A2, mu2, sigma2, A3, mu3, sigma3),
                 start = list(A1 = y_peaks[1], mu1 = x_peaks[1], sigma1 = 2,
                              A2 = y_peaks[2], mu2 = x_peaks[2], sigma2 = 2,
                              A3 = y_peaks[3], mu3 = x_peaks[3], sigma3 = 2),
                 control = list(maxiter = 500, warnOnly = TRUE)),
                 silent = TRUE)}
    
    # collect results for this protein in results_row and ad to fit_results list
    
    if(!inherits(fit, "try-error")) {
      coef_vals <- coef(fit)
      for (i in names(coef_vals)) {
        results_row[[paste0(i,"_", cond)]] <- coef_vals[i]
      }
      results_row[[paste0("Fit_OK_", cond)]] <- TRUE
      results_row[[paste0("n_peaks_", cond)]] <- n_peaks
    }
    else if (max(y, na.rm = TRUE) > 10) {
      peak_pos <- which.max(y)
      peak_val <- suppressWarnings(max(y, na.rm = TRUE))
      if(is.finite(peak_val) && peak_val > 5) {
      
      results_row[[paste0("A1_",cond)]] <- peak_val
      results_row[[paste0("mu1_",cond)]] <- peak_pos
      results_row[[paste0("sigma1_",cond)]] <- NA
      results_row[[paste0("Fit_OK_",cond)]] <- FALSE
      results_row[[paste0("n_peaks_",cond)]] <- 1
      }
    }
    else {
      results_row[[paste0("Fit_OK_", cond)]] <- FALSE
      results_row[[paste0("n_peaks_", cond)]] <- 0
    }
  }
  fit_results[[p]] <- results_row
}

# make data.frame out of list (quite comlicated, cause not every protein has the same amout of values)
rows_df <- lapply(fit_results, function(x){
  fields <- c("A1", "mu1", "sigma1", "A2", "mu2", "sigma2", "A3", "mu3", "sigma3")
  for (cond in c("Ctrl", "RNAse")) {
    for (f in fields) {
      key <- paste0(f, "_", cond)
      if(!(key %in% names(x))) {
        x[[key]] <- NA
      }
    }
    if(!paste0("Fit_OK_", cond) %in% names(x)) x[[paste0("Fit_OK_", cond)]] <- FALSE
    if(!paste0("n_peaks_", cond) %in% names(x)) x[[paste0("n_peaks_", cond)]] <- 0
  }
  as.data.frame(x)
})
MS_Data_Fitted <- do.call(rbind, rows_df)
rownames(MS_Data_Fitted) <- rownames(MS_Table_Norm)
head(MS_Data_Fitted)
sum(MS_Data_Fitted$Fit_OK_Ctrl & MS_Data_Fitted$Fit_OK_RNAse) # Number of proteins that where successfully fitted
sum(!is.na(MS_Data_Fitted$A1_Ctrl) & !is.na(MS_Data_Fitted$A1_RNAse)) # Numer of proteins in which a peak could successfully be detected
```




######## BackUP
Idee Correlation: 
- mit allen 3 Reps und Proteinenanzahl die wir signifikant empfinden (langsam rantasten, wann sieht man keinen Unterschied mehr) --> Sofia macht R-Werte etc  
- schöne Heatmap :)))) --> Cihan macht Korrelationsmatrix und Heatmap 
- zwar schwieriger wahrscheinlicher, aber cooler 

Idee Normalisierung der Daten: 
- MS-Tabel komplett normalisieren 
- einfacher, aber nicht so schön 



## Reproducibility Analysis
```{r}
# Choose your protein of interest
protein_name <- "1433G_HUMAN"

# Extract abundance values (they are in the row named "1433B_HUMAN")
abundance_values <- as.numeric(MS_Table[protein_name, ])

# Add them to the metadata table
data_copie <- data
data_copie$abundance <- abundance_values

data_copie
```



```{r}

# create empty vectors to store the values

sd_values <- numeric(25)
mean_values <- numeric(25)

# create loop for all 25 fractions 
for (i in 1:25) {
  # Define replicate labels ( RNAse or Ctrl)
  reps <- paste0("RNAse_Rep", 1:3)
  
  # Filter just the current fraction and replicates
  subset_data <- data[data$fraction == paste0("Fraction_", i) & data$replicate %in% reps, ]
  
  # Extract abundance values
  values <- subset_data$abundance
  
  # Compute standard deviation + compute mean
  sd_values[i] <- sd(values)
  
  mean_values[i] <- mean(values)
}

# Create result table 
result_tablesd <- data.frame(
  Fraction = paste0("Fraction_", 1:25),
  SD = sd_values
)
result_tablesd

result_tablemean <- data.frame(
  Fraction = paste0("Fraction_", 1:25),
  MEAN = mean_values
)
result_tablemean

```
--> hier wurde doch basicly schon unser Barplot gemacht, wie wir ihn dann für jedes Protein mit unseren Normalisierten Values machen wollen oder? (Zusammenhang Reproducibility?)
```{r}
# code for a barplot

# Combine by 'fraction' column
result_table <- merge(result_tablesd, result_tablemean, by = "Fraction")

# Optional: rename for clarity
colnames(result_table) <- c("Fraction", "Mean", "SD")

# Sort fractions numerically
result_table$Fraction_num <- as.numeric(gsub("Fraction_", "", result_table$Fraction))
result_table <- result_table[order(result_table$Fraction_num), ]

# Plot bars and store bar positions
bar_positions <- barplot(result_table$Mean,
                         names.arg = result_table$Fraction,
                         las = 2,
                         col = "lightblue",
                         ylim = c(0, max(result_table$Mean + result_table$SD, na.rm = TRUE)),
                         main = "Mean Abundance per Fraction",
                         ylab = "Mean Abundance")

```


