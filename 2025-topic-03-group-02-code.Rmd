---
title: "2025-topic-03-group-02-code"
output: html_document
date: "2025-05-16"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Legend for all tables / dataframes:

- MS_Table: Original table
- MS_Table_Averages: Triplicates normalised (average)
- MS_Table_Norm: Triplicates normalised + Amount of protein normalised

- shapiro_results: results of test on normal distribution
- full_correlation_results: results of spearman correlation

- Peak_Data: Number of peaks, peak heights and peak positions for Ctrl and RNase (on MS_Table_Norm)
- Shift_Data: CoM for Ctrl and RNAse, Shift distance and Shift direction (+ Shift Significance) (on MS_Table_Norm)

- Norm_Data_for_t: Amount of protein normalised for all replicates
- CoM_Data_for_t: CoM for Ctrl and RNAse for all replicates

#Loading MS-Data
```{r}
MS_Table <- read.table("RDeeP_HeLa_Mitosis.csv", header = TRUE, row.names = 1, sep = ";")
```

# Data Cleanup
## Despription of the Data
```{r}
n_rows = nrow(MS_Table) 
n_rows # Number of Proteins
n_cols = ncol(MS_Table) 
n_cols # Number of varibale
unique(sapply(MS_Table, class)) # classification of variables
any(is.na(MS_Table)) # missing values
min(MS_Table) # minimum intensity
max(MS_Table) # maximum intensity


```

## Restructuration of the data
Create a dataframe with factors that make it possible to access specific data from MS_Table
```{r}
treatment <- factor(rep(c("Ctrl", "RNase"), each = 3, length.out = 150))
replicate <- factor(rep(c("Ctrl_Rep1", "Ctrl_Rep2", "Ctrl_Rep3", "RNase_Rep1","RNase_Rep2", "RNase_Rep3"),25))
fraction <- factor(rep(paste0("Fraction_", 1:25), each = 6))

data <- data.frame(rownames = colnames(MS_Table),treatment = treatment, replicate = replicate, fraction = fraction)
data
```
## Normalization of triplicates 
Create a new dataframe with average values of the replicates 
```{r}
average.list <- list() #create list

# for loop, going through all fractions: 
# selecting Ctrl columns for specific fraction
# computing average of these columns 
# adding a new vector to list e.g."Ctrl_Fraction_1" and assigning average values 

for (f in levels(fraction)) {
  
  cols.Ctrl <- which(fraction == f & treatment == "Ctrl") 
  average.Ctrl <- rowMeans(MS_Table[,cols.Ctrl]) 
  average.list[[paste0("Ctrl_",f)]] <- average.Ctrl # paste0 funktion checken
  
  cols.RNase <- which(fraction == f & treatment == "RNase")
  average.RNase <- rowMeans(MS_Table[,cols.RNase])
  average.list[[paste0("RNase_",f)]] <- average.RNase
}

MS_Table_Averages <- as.data.frame(average.list) #convert list to dataframe
rownames(MS_Table_Averages) <- rownames(MS_Table) #assign Protein IDs to average values

#Define new order of columns ("levels" works in alphabetic order, not useful for us)
fractions <- paste0("Fraction_", 1:25)

ordered_names <- as.vector(rbind(
  paste0("Ctrl_", fractions),
  paste0("RNase_", fractions)
))

MS_Table_Averages <- MS_Table_Averages[, ordered_names]
head(MS_Table_Averages)
```
## Normalization to 100 
- Create a new dataframe in which the values for each protein are scaled so that the distribution within the Ctrl and RNAse conditions each sums to 100
```{r}
# Split up Control and RNAse values 
ctrl_cols <- grep("^Ctrl_", colnames(MS_Table_Averages)) # grep function genauer schauen 
rnase_cols <- grep("^RNase_", colnames(MS_Table_Averages))

# Normalization of each group to 100 
ctrl_norm <- MS_Table_Averages[, ctrl_cols] / rowSums(MS_Table_Averages[, ctrl_cols]) * 100
rnase_norm <- MS_Table_Averages[, rnase_cols] / rowSums(MS_Table_Averages[, rnase_cols]) * 100

# Combine in one table 
MS_Table_Norm <- cbind(ctrl_norm, rnase_norm)
MS_Table_Norm <- MS_Table_Norm[, colnames(MS_Table_Averages)]
head(round(MS_Table_Norm, 2))

# Verify the calculation with one example; the row sum should be ~200 (Ctrl 100% + RNAse 100%)
rowSums(MS_Table_Norm["1433B_HUMAN", ]) 
```

## Plotting a protein with normalised data 
```{r}
# Choose Protein
protein_of_interest <- "CPSF5_HUMAN" # hier dein Protein einsetzen

# Extract protein data
protein_row <- MS_Table_Norm[rownames(MS_Table_Norm) == protein_of_interest, ]

# Store Ctrl and RNase Values 
ctrl_values <- as.numeric(protein_row[seq(1, 49, by=2)])
rnase_values <- as.numeric(protein_row[seq(2, 50, by=2)])

fractions <- 1:25

# Plot
plot(fractions, ctrl_values, type="o", pch=16, lty=1, col="green", ylim=range(c(ctrl_values, rnase_values)),
     xlab="Fraction", ylab="Normalized Intensity", main=protein_of_interest)
lines(fractions, rnase_values, type="o",pch =16, lty=1, col="red")
legend("topright", legend=c("Ctrl", "RNase"), col=c("green", "red"), lty=1, pch=16)
```

## Test for Normal Distribution (requirement for t-test) 
- Description nessesary and all code descriptions in english
```{r}
# Pakete laden 
library(dplyr)

# Leere Liste für Zwischenspeicherung 
results_list <- list()
counter <- 1

# Proteine durchlaufen
for (protein in rownames(MS_Table)) {
  
  for (fraction_num in 1:25) {
    
    # Die korrekten Spaltennamen für Ctrl generieren
    cols_ctrl <- paste0("Fraction", fraction_num, "_Ctrl_Rep", 1:3)
    
    # Prüfen ob alle Spalten existieren 
    existing_cols <- cols_ctrl[cols_ctrl %in% colnames(MS_Table)]
    
    if(length(existing_cols) == 3){
      
      # Werte extrahieren
      protein_values <- as.numeric(MS_Table[protein, existing_cols])
      
      # Nur testen, wenn es Streuung gibt
      if (length(unique(protein_values)) > 1) {
        shapiro_result <- shapiro.test(protein_values)
        shapiro_W <- shapiro_result$statistic
        shapiro_p <- shapiro_result$p.value
      } else {
        shapiro_W <- NA
        shapiro_p <- NA
      }
      
      # Zwischenspeichern
      results_list[[counter]] <- data.frame(
        Protein_ID = protein,
        Fraction = fraction_num,
        Shapiro_W = shapiro_W,
        Shapiro_p = shapiro_p
      )
      counter <- counter + 1
    }
  }
}

# Am Ende alles zusammenfügen
shapiro_results <- do.call(rbind, results_list)

# Entscheidung über Normalverteilung ergänzen
shapiro_results$Is_Normal_Distributed <- shapiro_results$Shapiro_p >= 0.05

# Ergebnisse ausgeben
head(shapiro_results)

# Übersicht wie viele normalverteilt
table(shapiro_results$Is_Normal_Distributed)
```

## Reproducibility Analysis
- Description nessesary and all code descriptions in english
```{r}
# Create empty dataframe for correlation 
full_correlation_results <- data.frame(
  Treatment = character(),
  Replicate_1 = character(),
  Fraction_1 = character(),
  Replicate_2 = character(),
  Fraction_2 = character(),
  Spearman_r = numeric(),
  stringsAsFactors = FALSE
)

# iterate over both Ctrl and RNase Treatment 
for (treatment in c("Ctrl", "RNase")) {
  
  # Create all possible rep-fraction combinations
  combo1 <- expand.grid(Rep = 1:3, Fraction = 1:25)
  combo2 <- expand.grid(Rep = 1:3, Fraction = 1:25)
  
  # iterate for every possible combination
  for (i in 1:nrow(combo1)) {
    for (j in 1:nrow(combo2)) {
      
      rep1 <- combo1$Rep[i]
      frac1 <- combo1$Fraction[i]
      rep2 <- combo2$Rep[j]
      frac2 <- combo2$Fraction[j]
      
      # Find right column position 
      col1 <- which(replicate == paste0(treatment, "_Rep", rep1) & fraction == paste0("Fraction_", frac1))
      col2 <- which(replicate == paste0(treatment, "_Rep", rep2) & fraction == paste0("Fraction_", frac2))
      
      # calculate Spearmen correlation
      cor_value <- cor(MS_Table[, col1], MS_Table[, col2], method = "spearman", use = "complete.obs")
      
      # safe results in dataframe
      full_correlation_results <- rbind(full_correlation_results, data.frame(
        Treatment = treatment,
        Replicate_1 = paste0("Rep", rep1),
        Fraction_1 = paste0("Fraction_", frac1),
        Replicate_2 = paste0("Rep", rep2),
        Fraction_2 = paste0("Fraction_", frac2),
        Spearman_r = cor_value
      ))
    }
  }
}


head(full_correlation_results)


library(tidyverse)
library(pheatmap)

# create column for each axis 
full_correlation_results <- full_correlation_results %>%
   mutate(Row = paste0(Replicate_1, "_F", gsub("Fraction_", "", Fraction_1)),
         Col = paste0(Replicate_2, "_F", gsub("Fraction_", "", Fraction_2)))

# we select treament RNase for our heatmap
treatment_to_plot <- "RNase"

# filter table for selected treatment 
heatmap_data <- full_correlation_results %>%
  filter(Treatment == treatment_to_plot) %>%
  select(Row, Col, Spearman_r)

# convert into matrix 
heatmap_matrix <- heatmap_data %>%
  pivot_wider(names_from = Col, values_from = Spearman_r, values_fill = NA) %>%
  column_to_rownames("Row") %>%
  as.matrix()

# create heatmap
pheatmap(heatmap_matrix,
         main = paste("Spearman Correlation Heatmap -", treatment_to_plot),
         cluster_rows = FALSE, 
         cluster_cols = FALSE, 
         show_rownames = TRUE, 
         show_colnames = TRUE,
         fontsize_row = 4,
         fontsize_col = 4)

```

# Data Analysis

## Peak Characteristics 
- Find number of peaks, all peak positions and corresponding peak heights and store in a df for later use
- Caluculated on normalised data (average of triplicates)
```{r}
# fractions = x
x <- 1:25

# define treshold for peak and build function for peak detection
find_peaks <- function(y, threshold = max(y) * 0.03) { 
  peaks <- which(diff(sign(diff(y))) == -2) + 1 #(+1 shifts index back)
  peaks[y[peaks]>= threshold] 
}

# create empty list for results
peak_results <- list()

# for loop over every protein
for (p in seq_len(nrow(MS_Table_Norm))) {
  
  # extract values for Ctrl and RNase
  row_vals <- as.numeric(MS_Table_Norm [p,])
  ctrl_vals <- row_vals[seq(1, 50, by =2)]
  rnase_vals <- row_vals[seq(2, 50, by=2)]
  
  # create empty list for results
  results_row <- list()
  
  # for loop working with Ctrl values first, then with RNase values
  for (cond in c("Ctrl", "RNase")) {
    y <- if (cond == "Ctrl") ctrl_vals else rnase_vals 
    
    # find peaks with earlier build function, if no peak is detected peak1 is max intensity
    peaks <- find_peaks(y)
    if(length(peaks) == 0) {
      peaks <- which.max(y)
    }
    
    # store numer of peaks, but with a maximum of 6 
    n_peaks <- min(length(peaks), 6)
    
    # extract peak height y_peaks and peak position x_peaks
    y_peaks <- y[peaks]
    x_peaks <- x[peaks]

    # store different results in list 
    results_row[[paste0("n_peaks_", cond)]] <- n_peaks
    
    for(n in seq_len(n_peaks)) {
    results_row[[paste0("peak", n, "_height_", cond)]] <- y_peaks[n]
    results_row[[paste0("peak", n, "_position_", cond)]] <- x_peaks[n]
    }
  }
  # store protein results in lisr
  peak_results[[p]] <- results_row
}

# befor we can store data in new dataframe, we need to assign NA to all columns that have no values 
rows_df <- lapply(peak_results, function(x){
  columns <- c("peak1_height", "peak1_position", "peak2_height", "peak2_position", "peak3_height", "peak3_position", "peak4_height", "peak4_position", "peak5_height", "peak5_position", "peak6_height", "peak6_position")
  for (cond in c("Ctrl", "RNase")) {
    for (c in columns) {
      key <- paste0(c, "_", cond)
      if(!(key %in% names(x))) {
        x[[key]] <- NA
      }
    }
  }
  as.data.frame(x)
})

# store results in new DataFrame (note: rows_df is a list of dataframes so we need "do.call(r.bind,...)")
Peak_Data <- do.call(rbind, rows_df)
rownames(Peak_Data) <- rownames(MS_Table_Norm)

# reorder columns of Peak_Data
order <- c("n_peaks_Ctrl", "n_peaks_RNase")

for (i in 1:6) {
  order <- c(order, 
                 paste0("peak", i, "_height_Ctrl"),
                 paste0("peak", i, "_position_Ctrl"),
                 paste0("peak", i, "_height_RNase"),
                 paste0("peak", i, "_position_RNase"))
}

Peak_Data <- Peak_Data[, order]

# show head of PeakData to check 
head(Peak_Data)

```
#doing a PCa analysis in order to look at the distribution of RBPS => could be applyed to selected RBPs from mytosis


```{r}
# Load required package
library(ggplot2)

# Assume your data is in a data frame called 'df'
# Rows = proteins, Columns = the 26 features you mentioned
# First, remove rows with any NA values
Peak_Data_clean <- na.omit(Peak_Data)

# Remove columns with zero variance
Peak_Data_clean_clean <- Peak_Data_clean[, apply(Peak_Data_clean, 2, function(col) sd(col, na.rm = TRUE) != 0)]

# Perform PCA (center and scale the data)
pca_result <- prcomp(Peak_Data_clean_clean, center = TRUE, scale. = TRUE)

# Extract the scores for the first two principal components
pc_scores <- as.data.frame(pca_result$x[, 1:2])

# Add protein names as a column (assuming they are rownames)
pc_scores$Protein <- rownames(pc_scores)

# Create a new column that marks whether the protein is in t_test_positives (taken from further steps of the analysis)

pc_scores$Significant <- ifelse(pc_scores$Protein %in% t_test_positives, "Yes", "No")

# Plot the PCA
ggplot(pc_scores, aes(x = PC1, y = PC2, color = Significant)) +
  geom_point(alpha = 0.7, size = 1.5) +
  scale_color_manual(values = c("Yes" = "red", "No" = "black")) +
  theme_minimal() +
  labs(title = "PCA of Protein Features (highlighting significant proteins)",
       x = "PC1", y = "PC2", color = "Significant")

```


# Shift Characteristics
- Determine shift distance and shift direction for all proteins and store in a df
- Shift distance is calculated using caluculations of CoM (Center of Mass) for Ctrl and RNAse and caluculating deviation
- Shift direction is specified as +1, 0 or -1; +1 is a left-shift, -1 a right shift
- Caluculated on normalised data (average of triplicates)
```{r}
# fractions = x
x <- 1:25

# empty vectors for results (with length of number of proteins)
CoM_Ctrl <- numeric(nrow(MS_Table_Norm))
CoM_RNase <- numeric(nrow(MS_Table_Norm))
shift_distance <- numeric(nrow(MS_Table_Norm))
shift_direction <- numeric(nrow(MS_Table_Norm))

# for loop over every protein
for (p in seq_len(nrow(MS_Table_Norm))) {
  
  # extract values for Ctrl and RNase
  row_vals <- as.numeric(MS_Table_Norm [p,])
  ctrl_vals <- row_vals[seq(1, 50, by =2)]
  rnase_vals <- row_vals[seq(2, 50, by=2)]
  
  # calculate CoM, shift distance and shift direction
  CoM_Ctrl[p] <- sum(ctrl_vals * x) / sum(ctrl_vals)
  CoM_RNase[p] <- sum(rnase_vals * x) / sum(rnase_vals)
  shift_distance[p] <- CoM_Ctrl[p] - CoM_RNase[p] 
  shift_direction[p] <- sign(shift_distance[p]) 
}

# store results in new dataframe 
Shift_Data <- data.frame(
  CoM_Ctrl = CoM_Ctrl,
  CoM_RNase = CoM_RNase,
  shift_distance = shift_distance,
  shift_direction = shift_direction,
  row.names = rownames(MS_Table_Norm))

head(Shift_Data)

#numer of proteins with shift based on average values (just for interesst, delete later)
sum(Shift_Data$shift_distance > 1, na.rm = TRUE)
```
##T-Test 
### First Normalization of whole MS_Table to 100 
- We decided to run the statistical test on normalised values, so all replicates need to be normalised to 100
```{r}
# Split up all Ctrl and RNAse values and their individual Reps 
ctrl_cols_t1 <- grep("_Ctrl_Rep1", colnames(MS_Table))
ctrl_cols_t2 <- grep("_Ctrl_Rep2", colnames(MS_Table))
ctrl_cols_t3 <- grep("_Ctrl_Rep3", colnames(MS_Table))
RNase_cols_t1 <- grep("_RNase_Rep1", colnames(MS_Table))
RNase_cols_t2 <- grep("_RNase_Rep2", colnames(MS_Table))
RNase_cols_t3 <- grep("_RNase_Rep3", colnames(MS_Table))

# Normalization of each group to 100 
ctrl_norm_t1 <- MS_Table[, ctrl_cols_t1] / rowSums(MS_Table[, ctrl_cols_t1]) * 100
ctrl_norm_t2 <- MS_Table[, ctrl_cols_t2] / rowSums(MS_Table[, ctrl_cols_t2]) * 100
ctrl_norm_t3 <- MS_Table[, ctrl_cols_t3] / rowSums(MS_Table[, ctrl_cols_t3]) * 100
RNase_norm_t1 <- MS_Table[, RNase_cols_t1] / rowSums(MS_Table[, RNase_cols_t1]) * 100
RNase_norm_t2 <- MS_Table[, RNase_cols_t2] / rowSums(MS_Table[, RNase_cols_t2]) * 100
RNase_norm_t3 <- MS_Table[, RNase_cols_t3] / rowSums(MS_Table[, RNase_cols_t3]) * 100

# Combine in one table 
Norm_Data_for_t <- cbind(ctrl_norm_t1, RNase_norm_t1, ctrl_norm_t2, RNase_norm_t2, ctrl_norm_t3, RNase_norm_t3)

# In gewünschter Reihenfolge ordnen
fractions <- 1:25
reps <- 1:3
conditions <- c("Ctrl", "RNase") 


ordered_names <- c()

for (fraction in fractions) {
  for (rep in reps) {
    for (condition in conditions) {
      name <- paste0("Fraction", fraction, "_", condition, "_Rep", rep)
      ordered_names <- c(ordered_names, name)
    }
  }
}

Norm_Data_for_t <- Norm_Data_for_t[, ordered_names]
head(Norm_Data_for_t)
# Verify the calculation with one example; the row sum should be ~600 (3*Ctrl 100% + 3*RNAse 100%)
rowSums(Norm_Data_for_t["1433B_HUMAN", ]) 
```

### Caluclation of Center of mass (CoM) 
- CoM (Center of mass) values are calculated for all replicates and treatments and stored in df
```{r}
# aufstellen von variablen 

fractions <- 1:25
conditions <- c("Ctrl", "RNase")
replicates <- c("Rep1", "Rep2", "Rep3")

#liste erstellen 

results_com <- list()

#looping through conditions and replicates as we want them all seperate

for (cond in conditions) {
  for (rep in replicates) {
    
#selecting colums with grep diesen strich verssteh ich nicht "chat sagt "makes one combined pattern with ORs (|) between them, so grep matches any of them."

    pattern <- paste0("^Fraction", fractions, "_", cond, "_", rep, "$")
    cols <- grep(paste(pattern, collapse="|"), colnames(Norm_Data_for_t), value = TRUE)  

    subdata <- Norm_Data_for_t[, cols]   
#storing coloums 

    subdata <- subdata[, order(as.numeric(gsub("Fraction(\\d+)_.*", "\\1", cols)))]  #extracts the fraction number from column names.

#center of mass calculation

    com <- apply(subdata, 1, function(x) {
      sum(x * fractions) / sum(x)
    })
#store result in list 

    results_com[[paste(cond, rep, sep = "_")]] <- com
  }
}

#convert list to dataframe

# After the loops have finished:
CoM_Data_for_t <- as.data.frame(results_com)   # convert list into data frame

# Add correct rownames:
rownames(CoM_Data_for_t) <- rownames(Norm_Data_for_t)

# View the first few rows to check
head(CoM_Data_for_t)
```

### Calculating Shift-Values for T-Test
- Calculate deviation between CoM of Ctrl and CoM of RNase and store in df for t-test 
```{r}
Shift_Data_for_t <- data.frame(
  shift_distance_rep1 = CoM_Data_for_t[, 1] - CoM_Data_for_t[, 4],
  shift_distance_rep2 = CoM_Data_for_t[, 2] - CoM_Data_for_t[, 5],
  shift_distance_rep3 = CoM_Data_for_t[, 3] - CoM_Data_for_t[, 6],
  row.names = rownames(CoM_Data_for_t)
)

head(Shift_Data_for_t)
any(is.na(Shift_Data_for_t))
sum(is.na(Shift_Data_for_t))
```

### T-Test
```{r}
# create empty columns for statistical test results 
Shift_Data$shapiro_p <- NA
Shift_Data$normal_distributed <- NA
Shift_Data$p_value_ttest_filtered <- NA
Shift_Data$significant_ttest_filtered <- NA

# iterate over all proteins 
for (protein in rownames(Shift_Data_for_t)) {
  
  # extract shift distances for each replicate
  shift_values <- as.numeric(Shift_Data_for_t[protein, c("shift_distance_rep1", "shift_distance_rep2", "shift_distance_rep3")])
  
  # make sure that no NAs are present
  if (all(!is.na(shift_values))) {
    
    # check if all values are identical (no variance)
    if (length(unique(shift_values)) == 1) {
      
      # set normal distribution to TRUE if no variance is present
      Shift_Data[protein, "shapiro_p"] <- NA
      Shift_Data[protein, "normal_distributed"] <- TRUE
      
    } else {
      
      # perform Shapiro-Wilk test to check for normal distribution
      shapiro_result <- shapiro.test(shift_values)
      Shift_Data[protein, "shapiro_p"] <- shapiro_result$p.value
      Shift_Data[protein, "normal_distributed"] <- shapiro_result$p.value >= 0.05
    }
    
    # perfrom one-sided t-test if data is normal distributed
    if (Shift_Data[protein, "normal_distributed"] == TRUE) {
      
      test_result <- t.test(shift_values, mu = 1, alternative = "greater")
      
      Shift_Data[protein, "p_value_ttest_filtered"] <- test_result$p.value
      Shift_Data[protein, "significant_ttest_filtered"] <- ifelse(test_result$p.value < 0.05, TRUE, FALSE)
      
    } else {
      # no t-test applied if data is not normal distributed
      Shift_Data[protein, "p_value_ttest_filtered"] <- NA
      Shift_Data[protein, "significant_ttest_filtered"] <- NA
    }
  }
}

# summary of proteins regarding normal distribution
table(Shift_Data$normal_distributed, useNA = "ifany")

# summary of proteins regarding significant of t-test
table(Shift_Data$significant_ttest_filtered, useNA = "ifany")

head(Shift_Data)
```
## Validation of T-Test 

```{r}
library(glue)

#loading list of uniprot RBPs (HUMAN)
uniprot_rbps <- read.delim("uniprotkb_RNA_binding_HUMAN_AND_model_o_2025_06_09.tsv", header = TRUE, sep = "\t", stringsAsFactors = FALSE)

#comparison of uniprot RBPs with our T-Test positive RBPs
known_rbps <- uniprot_rbps$Entry.Name

t_test_positives <- rownames(Shift_Data[Shift_Data$significant_ttest_filtered == TRUE & !is.na(Shift_Data$significant_ttest_filtered), ])

overlap_MS_Table <- intersect(rownames(MS_Table), known_rbps)
overlap_t_test <- intersect(t_test_positives, known_rbps)

glue("Number of known RBPs in UniProt: {length(known_rbps)}")
glue("Number of UniProt RBPs tested with R-DeeP: {length(overlap_MS_Table)}")
glue("Number identified as RBPs (T-Test positive): {length(overlap_t_test)}")
glue("Hit rate: {round(length(overlap_t_test)/length(overlap_MS_Table)*100, 2)}%")

# validation of test using three listed positive and negative controls

# RBM10, SMN1 and FMR1 have been listed many times as RBPs (Quellen raussuchen)
pos_controls <- c("RBM10_HUMAN", "SMN_HUMAN", "FMR1_HUMAN")
pos_df <- data.frame(
  Protein_Postive_Control = pos_controls,
  InDataset = pos_controls %in% rownames(MS_Table),
  TTest = pos_controls %in% t_test_positives)

print(pos_df)

# ATP5F1A, SDHB and COX4I1 are often used as negative controls(Quellen raussuchen)
neg_controls <- c("ACTB_HUMAN", "SDHB_HUMAN", "COX41_HUMAN")
neg_df <- data.frame(
  Protein_Negative_Control = neg_controls,
  InDataset = neg_controls %in% rownames(MS_Table),
  TTest = neg_controls %in% t_test_positives)

print(neg_df)
```
### Analyse Verbesserungen T-Test (FALSE NEGATIVE RATE)?????
-> learnings so far: Bsp. HTSF1 aufgrund von Normalverteilung FALSE rausgeflogen (klarer Shift erkennbar), LSM8 auch, aber kein Shift (SNRPA)
--> RPP29_HUMAN zeigt immer Shift über 1 aber anscheinend nicht signifikant genug??? p=0,08
--> vielleicht ist 1 Fraktion Shift zu viel? 
--> 36 Proteine sind rausgeflogen weil es nur Daten von RNAse gab / ode nur Ctrl 
--> 31 Proteine sind rausgeflogen weil sie den Normalverteilungstest nicht bestanden haben
--> insgesamt könnte man durch veränderung des Normalisierungszeugs bis zu 10 Prozent der nicht identifizierten Proteine mögl. finden
--> Nur 23 Proteine wären bei alpha = 0.1 dazugekommen
--> von einem Sample aus 40 nicht identifizierten hätte ich bei 6 einen Shift vermutet, 8 sind aufgrund von Normalisierung / fehlenden Angaben (siehe oben) rausgeflogen, d.h. ich würde sagen 81 Prozent der wirklich getesteten Proteine wurden korrekt als nicht RBPs identifiziert, 19 Prozent der getesteten hätten vlt. RBPs werden sollen (mögl. andere Kriterien) 

```{r}
### alle Uniprot Proteine die nicht gefunden wurden
not_indentified <- known_rbps[! known_rbps %in% t_test_positives & known_rbps %in% rownames(MS_Table)]
length(not_indentified)

sum(is.na(Shift_Data[not_indentified, "shapiro_p"]))
sum(Shift_Data[not_indentified, "normal_distributed"] == FALSE)
sum(Shift_Data[not_indentified, "p_value_ttest_filtered"] < 0.1, na.rm = TRUE)
```
```{r}
plot_protein <- function(x) {
  protein_of_interest <- x 
  protein_row <- MS_Table_Norm[rownames(MS_Table_Norm) == protein_of_interest, ]
  ctrl_values <- as.numeric(protein_row[seq(1, 49, by=2)])
  rnase_values <- as.numeric(protein_row[seq(2, 50, by=2)])
  fractions <- 1:25

  plot(fractions, ctrl_values, type="o", pch=16, lty=1, col="green", ylim=range(c(ctrl_values, rnase_values)),
       xlab="Fraction", ylab="Normalized Intensity", main= protein_of_interest)
       
  lines(fractions, rnase_values, type="o",pch =16, lty=1, col="red")
  legend("topright", legend=c("Ctrl", "RNase"), col=c("green", "red"), lty=1, pch=16)
}

sample_not_identified <- head( not_indentified, 40)
for (s in sample_not_identified ){
  plot_protein(s)
}

print(Shift_Data_for_t[sample_not_identified,])
print(Shift_Data[sample_not_identified, c("shapiro_p","normal_distributed","p_value_ttest_filtered","significant_ttest_filtered")])
```

## T-Test for non-synchronised HELA Cells (Copied and adjusted Pipeline)
```{r}
#loading Data
MS_Table_NS <- read.table("RDeeP_HeLa_NS.csv", header = TRUE, row.names = 1, sep = ";")

#Dataframe
treatment <- factor(rep(c("Ctrl", "RNase"), each = 3, length.out = 150))
replicate <- factor(rep(c("Ctrl_Rep1", "Ctrl_Rep2", "Ctrl_Rep3", "RNase_Rep1","RNase_Rep2", "RNase_Rep3"),25))
fraction <- factor(rep(paste0("Fraction_", 1:25), each = 6))

data <- data.frame(rownames = colnames(MS_Table),treatment = treatment, replicate = replicate, fraction = fraction)

# normalisation of triplicates
average.list.NS <- list() 

for (f in levels(fraction)) {
  
  cols.Ctrl <- which(fraction == f & treatment == "Ctrl") 
  average.Ctrl <- rowMeans(MS_Table_NS[,cols.Ctrl]) 
  average.list.NS[[paste0("Ctrl_",f)]] <- average.Ctrl 
  
  cols.RNase <- which(fraction == f & treatment == "RNase")
  average.RNase <- rowMeans(MS_Table_NS[,cols.RNase])
  average.list.NS[[paste0("RNase_",f)]] <- average.RNase
}

MS_Table_Averages_NS <- as.data.frame(average.list.NS) 
rownames(MS_Table_Averages_NS) <- rownames(MS_Table_NS)

fractions <- paste0("Fraction_", 1:25)

ordered_names <- as.vector(rbind(
  paste0("Ctrl_", fractions),
  paste0("RNase_", fractions)
))

MS_Table_Averages_NS <- MS_Table_Averages_NS[, ordered_names]

# Normalisation to 100

ctrl_cols <- grep("^Ctrl_", colnames(MS_Table_Averages_NS)) 
rnase_cols <- grep("^RNase_", colnames(MS_Table_Averages_NS))

ctrl_norm <- MS_Table_Averages_NS[, ctrl_cols] / rowSums(MS_Table_Averages_NS[, ctrl_cols]) * 100
rnase_norm <- MS_Table_Averages_NS[, rnase_cols] / rowSums(MS_Table_Averages_NS[, rnase_cols]) * 100

MS_Table_Norm_NS <- cbind(ctrl_norm, rnase_norm)
MS_Table_Norm_NS <- MS_Table_Norm_NS[, colnames(MS_Table_Averages_NS)]

# Fuction for protein ploting 
plot_protein_NS <- function(x) {
  protein_of_interest <- x 
  protein_row <- MS_Table_Norm_NS[rownames(MS_Table_Norm_NS) == protein_of_interest, ]
  ctrl_values <- as.numeric(protein_row[seq(1, 49, by=2)])
  rnase_values <- as.numeric(protein_row[seq(2, 50, by=2)])
  fractions <- 1:25

  plot(fractions, ctrl_values, type="o", pch=16, lty=1, col="green", ylim=range(c(ctrl_values, rnase_values)),
       xlab="Fraction", ylab="Normalized Intensity", main= paste(protein_of_interest, "non-synchronised"))
       
  lines(fractions, rnase_values, type="o",pch =16, lty=1, col="red")
  legend("topright", legend=c("Ctrl", "RNase"), col=c("green", "red"), lty=1, pch=16)
}

# Shift Characteristics based on normalised Data and CoM
x <- 1:25

CoM_Ctrl_NS <- numeric(nrow(MS_Table_Norm_NS))
CoM_RNase_NS <- numeric(nrow(MS_Table_Norm_NS))
shift_distance_NS <- numeric(nrow(MS_Table_Norm_NS))
shift_direction_NS <- numeric(nrow(MS_Table_Norm_NS))

for (p in seq_len(nrow(MS_Table_Norm_NS))) {

  row_vals <- as.numeric(MS_Table_Norm_NS [p,])
  ctrl_vals <- row_vals[seq(1, 50, by =2)]
  rnase_vals <- row_vals[seq(2, 50, by=2)]

  CoM_Ctrl_NS[p] <- sum(ctrl_vals * x) / sum(ctrl_vals)
  CoM_RNase_NS[p] <- sum(rnase_vals * x) / sum(rnase_vals)
  shift_distance_NS[p] <- CoM_Ctrl_NS[p] - CoM_RNase_NS[p] 
  shift_direction_NS[p] <- sign(shift_distance_NS[p]) 
}

Shift_Data_NS <- data.frame(
  CoM_Ctrl= CoM_Ctrl_NS,
  CoM_RNase = CoM_RNase_NS,
  shift_distance = shift_distance_NS,
  shift_direction= shift_direction_NS,
  row.names = rownames(MS_Table_Norm_NS))

# Normalisation of MS_Table_NS to 100

ctrl_cols_t1 <- grep("_Ctrl_Rep1", colnames(MS_Table_NS))
ctrl_cols_t2 <- grep("_Ctrl_Rep2", colnames(MS_Table_NS))
ctrl_cols_t3 <- grep("_Ctrl_Rep3", colnames(MS_Table_NS))
RNase_cols_t1 <- grep("_RNase_Rep1", colnames(MS_Table_NS))
RNase_cols_t2 <- grep("_RNase_Rep2", colnames(MS_Table_NS))
RNase_cols_t3 <- grep("_RNase_Rep3", colnames(MS_Table_NS))

ctrl_norm_t1 <- MS_Table_NS[, ctrl_cols_t1] / rowSums(MS_Table_NS[, ctrl_cols_t1]) * 100
ctrl_norm_t2 <- MS_Table_NS[, ctrl_cols_t2] / rowSums(MS_Table_NS[, ctrl_cols_t2]) * 100
ctrl_norm_t3 <- MS_Table_NS[, ctrl_cols_t3] / rowSums(MS_Table_NS[, ctrl_cols_t3]) * 100
RNase_norm_t1 <- MS_Table_NS[, RNase_cols_t1] / rowSums(MS_Table_NS[, RNase_cols_t1]) * 100
RNase_norm_t2 <- MS_Table_NS[, RNase_cols_t2] / rowSums(MS_Table_NS[, RNase_cols_t2]) * 100
RNase_norm_t3 <- MS_Table_NS[, RNase_cols_t3] / rowSums(MS_Table_NS[, RNase_cols_t3]) * 100

Norm_Data_for_t_NS <- cbind(ctrl_norm_t1, RNase_norm_t1, ctrl_norm_t2, RNase_norm_t2, ctrl_norm_t3, RNase_norm_t3)

fractions <- 1:25
reps <- 1:3
conditions <- c("Ctrl", "RNase") 
ordered_names <- c()
for (fraction in fractions) {
  for (rep in reps) {
    for (condition in conditions) {
      name <- paste0("Fraction", fraction, "_", condition, "_Rep", rep)
      ordered_names <- c(ordered_names, name)
    }
  }
}
Norm_Data_for_t_NS <- Norm_Data_for_t_NS[, ordered_names]

#Calculation of CoM for T-Test

fractions <- 1:25
conditions <- c("Ctrl", "RNase")
replicates <- c("Rep1", "Rep2", "Rep3")

results_com_NS <- list()

for (cond in conditions) {
  for (rep in replicates) {
    pattern <- paste0("^Fraction", fractions, "_", cond, "_", rep, "$")
    cols <- grep(paste(pattern, collapse="|"), colnames(Norm_Data_for_t_NS), value = TRUE)  
    subdata <- Norm_Data_for_t_NS[, cols]   
    subdata <- subdata[, order(as.numeric(gsub("Fraction(\\d+)_.*", "\\1", cols)))]  
    com <- apply(subdata, 1, function(x) {
      sum(x * fractions) / sum(x)
    })

    results_com_NS[[paste(cond, rep, sep = "_")]] <- com
  }
}

CoM_Data_for_t_NS <- as.data.frame(results_com_NS)  

rownames(CoM_Data_for_t_NS) <- rownames(Norm_Data_for_t_NS)

# Calculating Shift-Values for T-Test

Shift_Data_for_t_NS <- data.frame(
  shift_distance_rep1 = CoM_Data_for_t_NS[, 1] - CoM_Data_for_t_NS[, 4],
  shift_distance_rep2 = CoM_Data_for_t_NS[, 2] - CoM_Data_for_t_NS[, 5],
  shift_distance_rep3 = CoM_Data_for_t_NS[, 3] - CoM_Data_for_t_NS[, 6],
  row.names = rownames(CoM_Data_for_t_NS)
)

#T-Test

Shift_Data_NS$shapiro_p <- NA
Shift_Data_NS$normal_distributed <- NA
Shift_Data_NS$p_value_ttest_filtered <- NA
Shift_Data_NS$significant_ttest_filtered <- NA

for (protein in rownames(Shift_Data_for_t_NS)) {
 
  shift_values <- as.numeric(Shift_Data_for_t_NS[protein, c("shift_distance_rep1", "shift_distance_rep2", "shift_distance_rep3")])

  if (all(!is.na(shift_values))) {

    if (length(unique(shift_values)) == 1) {
      Shift_Data_NS[protein, "shapiro_p"] <- NA
      Shift_Data_NS[protein, "normal_distributed"] <- TRUE
      
    } else {
      shapiro_result <- shapiro.test(shift_values)
      Shift_Data_NS[protein, "shapiro_p"] <- shapiro_result$p.value
      Shift_Data_NS[protein, "normal_distributed"] <- shapiro_result$p.value >= 0.05
    }
    
    if (Shift_Data_NS[protein, "normal_distributed"] == TRUE) {
      test_result <- t.test(shift_values, mu = 1, alternative = "greater")
      Shift_Data_NS[protein, "p_value_ttest_filtered"] <- test_result$p.value
      Shift_Data_NS[protein, "significant_ttest_filtered"] <- ifelse(test_result$p.value < 0.05, TRUE, FALSE)
      
    } else {
      Shift_Data_NS[protein, "p_value_ttest_filtered"] <- NA
      Shift_Data_NS[protein, "significant_ttest_filtered"] <- NA
    }
  }
}
#Analysis of results for Nonsynchronised HeLa Cells
table(Shift_Data_NS$significant_ttest_filtered, useNA = "ifany")
```

#Comparison of Proteins found as RBP in Mitosis vs. in NS_Hela 
```{r}
t_test_positives_NS <- rownames(Shift_Data_NS[Shift_Data_NS$significant_ttest_filtered == TRUE & !is.na(Shift_Data_NS$significant_ttest_filtered), ])

overlap_analysis <- intersect(rownames(MS_Table_NS), rownames(MS_Table))
overlap_t_test_positivs <- intersect(t_test_positives, t_test_positives_NS)
RBPs_Mitosis <- setdiff(t_test_positives, t_test_positives_NS)
RBPs_Mitosis <- intersect(RBPs_Mitosis, overlap_analysis)

glue("Number of Proteins in sample NS_Hela: {length(rownames(MS_Table_NS))}")
glue("Number of Proteins analysed in both samples: {length(overlap_analysis)}")
glue("Number of RBPs found in both samples: {length(overlap_t_test_positivs)}")
glue("Number RBPs found only in Mitosis: {length(RBPs_Mitosis)}")

sample_RBPs_Mitosis <- head(RBPs_Mitosis,20)
for (r in sample_RBPs_Mitosis){
  plot_protein(r)
  plot_protein_NS(r)
}
```

#Clustering to find posible RBP complexes in our RBPs in Mitosis

```{r}
#from the two shift and peak characteristics we extract some variables creating a new merged table which also has only the names of the RBPs that are aktive in mitosis 

# 1) Filter only the RBPs relevant in Mitosis 

filtered_shift_Mitosis <- Shift_Data[rownames(Shift_Data) %in% RBPs_Mitosis, ]

filtered_peak_Mitosis <- Peak_Data[rownames(Peak_Data) %in% RBPs_Mitosis, ]

# 2) Selecting only the interesting coloumns creating comon dataframe

merged_filterd_mitosis <- cbind(filtered_shift_Mitosis[, c("CoM_Ctrl", "CoM_RNase", "shift_distance")], filtered_peak_Mitosis[, c("n_peaks_Ctrl", "n_peaks_RNase","peak1_height_Ctrl", "peak1_height_RNase", "peak2_height_Ctrl", "peak2_height_RNase", "peak1_position_Ctrl", "peak1_position_RNase" , "peak2_position_Ctrl", "peak2_position_RNase" )])

head(merged_filterd_mitosis)

# 3) clean data for further steps 

# Remove rows with NA values

clean_merged_filterd_mitosis <- na.omit(merged_filterd_mitosis)

# Optionally remove constant columns

clean2_merged_filterd_mitosis <- clean_merged_filterd_mitosis[, apply(clean_merged_filterd_mitosis, 2, function(col) sd(col, na.rm = TRUE) != 0)]

# 4) do hirarchical clustering in order to determin a good k value (number of clusters)


clean2_merged_filterd_mitosis <- as.matrix(clean2_merged_filterd_mitosis)   # Convert to numeric matrix if it's not already

# Distance matrix (Euclidean)
dist_matrix <- dist(clean2_merged_filterd_mitosis)

# Hierarchical clustering with different linkage methods
hc_ward <- hclust(dist_matrix, method = "ward.D2")
#hc_average <- hclust(dist_matrix, method = "average")
#hc_complete <- hclust(dist_matrix, method = "complete")
#hc_single <- hclust(dist_matrix, method = "single")

# Plot all 4 dendrograms
par(mfrow = c(2, 2))
#plot(hc_ward, main = "Ward's Method")
#plot(hc_average, main = "Average Linkage")
#plot(hc_complete, main = "Complete Linkage")
#plot(hc_single, main = "Single Linkage")

plot(hc_ward, labels = FALSE, main = "Ward's Method (no labels)")

# extra )image to save maybe for poster 

png("C://Users//Sofi//Desktop//4 Semester//Bioinfo_project//Downloadsdendrogram_large.png", width = 1200, height = 800)
plot(hc_ward, labels = FALSE, main = "Ward's Method (Large Output)")
dev.off()

# run k means in order to see how it looks at different number of clusters

# Convert to matrix
K <- as.matrix(clean2_merged_filterd_mitosis)
# K-means clustering
k <- 3                    #number of clusters 
set.seed(42)
kmeans_result <- kmeans(K, centers = k) # here i put in my data 

# Reduce to 2D with PCA
pca_results <- prcomp(K, scale. = TRUE)
K_2D <- pca_results$x[, 1:2]

# Plot clusters
plot(K_2D, col = kmeans_result$cluster, pch = 19,
     main = "K-means Clustering (PCA-reduced 2D)",
     xlab = "PC1", ylab = "PC2")
legend("topright", legend = paste("Cluster", 1:k), col = 1:k, pch = 19)


```
# only k means so i can look at it better
```{r}
# Convert to matrix
K <- as.matrix(clean2_merged_filterd_mitosis)
# K-means clustering
k <- 50                   #number of clusters 
set.seed(42)
kmeans_result <- kmeans(K, centers = k) # here i put in my data 

# Reduce to 2D with PCA
pca_results <- prcomp(K, scale. = TRUE)
K_2D <- pca_results$x[, 1:2]

# Plot clusters
plot(K_2D, col = kmeans_result$cluster, pch = 19,
     main = "K-means Clustering (PCA-reduced 2D)",
     xlab = "PC1", ylab = "PC2")
legend("topright", legend = paste("Cluster", 1:k), col = 1:k, pch = 19)


```

# Linear Regression Analysis
## Get official molecular weight from Uniprot (vorsicht Leute Code läuft 35 Min!!!... laufen Lassen und Kaffe holen) :)
```{r}
library(httr)
library(jsonlite)
library(pbapply)  # für Fortschrittsbalken bei langen Listen

# Function für accession ids aus Uniprot
get_accession_from_entryname <- function(entry_name) {
  url <- paste0("https://rest.uniprot.org/uniprotkb/search?query=", entry_name, "&fields=accession&format=json&size=1")
  res <- try(GET(url), silent = TRUE)
  if (inherits(res, "try-error") || res$status_code != 200) {
    return(NA)
  }
  txt <- content(res, "text", encoding = "UTF-8")
  data <- fromJSON(txt, simplifyVector = FALSE)
  if (length(data$results) == 0) {
    return(NA)}
  else{
  return(data$results[[1]]$primaryAccession)}
    
}
# Funktion zum Abrufen der Masse für eine UniProt-ID
get_uniprot_mass <- function(accession_ids) {
  url <- paste0("https://rest.uniprot.org/uniprotkb/", accession_ids, ".json")
  res <- try(GET(url), silent = TRUE)
  if (inherits(res, "try-error") || res$status_code != 200) {
    return(NA)
  }
  data <- fromJSON(content(res, "text", encoding = "UTF-8"))
  return(data$sequence$molWeight)
}

entry_names <- rownames(MS_Table)
accession_ids <- pbsapply(entry_names, get_accession_from_entryname)
masses <- pbsapply(accession_ids, get_uniprot_mass)

#Wichtig, da wir massen unlisten müssen, und 5 Proteine als NA gespeichert werden müssen
masses_vec <- rep(NA_real_, length(accession_ids))
names(masses_vec) <- accession_ids
valid_idx <- which(!sapply(masses, is.null))
masses_vec[valid_idx] <- as.numeric(unlist(masses[valid_idx]))

# DataFrame bauen
protein_mass_df <- data.frame(
  UniProtAccession = accession_ids,
  MolecularWeight_kDa = masses_vec / 1000
)
head(protein_mass_df)
sum(is.na(protein_mass_df$MolecularWeight_kDa))
```
# Correlation Analysis Molekular Weight with Maximum Peak Position
--> So ist da einfach keine wirklcihe Correlation, leichte Correlationen leigt aber aher an Masse als an tatsächlihcer COrrelation, und lineare Regressionsmodelle sind auch mist
--> Wir haben ein Problem,die meisten Proteine liegen auch in gegenwart von RNAse noch als Komplex /Quartärstruktur vor (unabhängig von RNAse) Ich hab die monomergewichte und man weis ja garnicht, welche Proteine wir miteinandern doch ncoh in Komplexen hängen
--> vlt. mit menschlichen Proteine die sicher Monomere sind ein Model bauen und dann dadurch irgendwie gucken, ob Proteine als Komplex vorliegen oder nicht???
```{r}
# irgendwie die Peak_Position von dem Peak mit max peak height bei RNase für jedes Portein raussuchen

max_peak_positions <- numeric(nrow(Peak_Data))

for (p in seq_len(nrow(Peak_Data))) {
  p_data <- Peak_Data [p,]
  peak_heights <- as.numeric(p_data[, paste0("peak", 1:6, "_height_RNase")])
  peak_positions <- as.numeric(p_data[, paste0("peak", 1:6, "_position_RNase")])
  
  if (all(is.na(peak_heights))) {
    max_peak_positions[p] <- NA
  } else {
    max_idx <- which.max(peak_heights)
    max_peak_positions[p] <- peak_positions[max_idx]
  }
  
}  

Protein_Data_for_LR <- data.frame(max_peak_position_RNase = max_peak_positions)
rownames(Protein_Data_for_LR) <- rownames(Peak_Data)

# Anfügen der Molecular Weight
Protein_Data_for_LR$MolecularWeight_kDa <- protein_mass_df$MolecularWeight_kDa
Protein_Data_for_LR$CoM_RNase <- Shift_Data$CoM_RNase

# Plotting
library(ggplot2)
library(dplyr)
ggplot(Protein_Data_for_LR %>% filter(MolecularWeight_kDa <= 1000), aes(x = max_peak_position_RNase, y = MolecularWeight_kDa)) +
  geom_point() +
  labs(x = "Peak Position", y = "Molecular Weight (kDa)",
    title = "Molecular Weight vs. Peak Position ")

ggplot(Protein_Data_for_LR %>% filter(MolecularWeight_kDa <= 1000), aes(x = CoM_RNase, y = MolecularWeight_kDa)) +
  geom_point() +
  labs(x = "CoM_RNase", y = "Molecular Weight (kDa)",
    title = "Molecular Weight vs. CoM_RNase")

# Correlation Tests
cor.test(Protein_Data_for_LR$max_peak_position_RNase,
         Protein_Data_for_LR$MolecularWeight_kDa,
         method = "spearman", use = "complete.obs")

cor.test(Protein_Data_for_LR$CoM_RNase,
         Protein_Data_for_LR$MolecularWeight_kDa,
         method = "spearman", use = "complete.obs")

# Linerare Regressionsanalyse
lm_model_peak_position <- lm(MolecularWeight_kDa ~ max_peak_position_RNase, data = Protein_Data_for_LR)
summary(lm_model_peak_position)

lm_model_CoM <- lm(MolecularWeight_kDa ~ CoM_RNase, data = Protein_Data_for_LR)
summary(lm_model_CoM)
```

# TRY AND ERROR (BackUP)
##looking at standart deviation and mean to get an idea 

```{r}


# create empty vectors to store the values

sd_values <- numeric(25)
mean_values <- numeric(25)

# create loop for all 25 fractions 
for (i in 1:25) {
  # Define replicate labels ( RNAse or Ctrl)
  reps <- paste0("RNAse_Rep", 1:3)
  
  # Filter just the current fraction and replicates
  subset_data <- data[data$fraction == paste0("Fraction_", i) & data$replicate %in% reps, ]
  
  # Extract abundance values
  values <- subset_data$abundance
  
  # Compute standard deviation + compute mean
  sd_values[i] <- sd(values)
  
  mean_values[i] <- mean(values)
}

# Create result table 
result_tablesd <- data.frame(
  Fraction = paste0("Fraction_", 1:25),
  SD = sd_values
)
result_tablesd

result_tablemean <- data.frame(
  Fraction = paste0("Fraction_", 1:25),
  MEAN = mean_values
)
result_tablemean

```

##trzing to run Pearson correlation for all proteins => for now between Repetitions Rep1 and Rep2 across 25 fractions for Ctrl and RNase seperatly 

#1) frist creating a long format table with=> Protein names repeat themselfs for all combinations maybe this is the problem 


```{r}
# Load necessary packages
library(dplyr)
library(tidyr)

#naming coloum for Protein names with Protein so i can run my code => this is ugly open for suggestions

MS_Table$Protein <- rownames(MS_Table)
MS_Table2 <- MS_Table %>% relocate(Protein)
head(MS_Table2)

# Step 2: Pivot longer — convert the wide columns into long format
# The first column is protein names, so we keep it as id

ms_long <- MS_Table %>%
  pivot_longer(
    cols = -Protein,  # all columns except the first (protein names)
    names_to = "Condition",  # temporary column to store original column names
    values_to = "Value"      # this column will store the measured values
  )

# Step 3: Separate 'Condition' into Fraction, Treatment, and Replicate
ms_long <- ms_long %>%
  separate(
    col = Condition,
    into = c("Fraction", "Treatment", "Replicate"),
    sep = "_"
  )

# Step 4: Extract the numeric fraction number (since it's like 'Fraction1')
ms_long <- ms_long %>%
  mutate(
    Fraction = as.numeric(sub("Fraction", "", Fraction))
  )

# Step 5: Rename first column to "Protein" (if it's not already)
names(ms_long)[1] <- "Protein"

# Optional: Check result
head(ms_long)
rownames(ms_long)


# Now you have your tidy table:
# Protein | Fraction | Treatment | Replicate | Value



```


#2) with table trying to run pearson correlation 

```{r}

library(dplyr)
library(tidyr)

# First: keep only the replicates we want
filtered <- ms_long %>%
  filter(Replicate %in% c("Rep1", "Rep2"),
         Treatment %in% c("Ctrl", "RNAse"),
         Fraction %in% paste0("Fraction_", 1:25))

# Then: calculate correlation per protein + treatment
results <- filtered %>%
  group_by(Protein, Treatment) %>%
  pivot_wider(
    names_from = Replicate,
    values_from = Value,
    values_fill = list(abundance = 0)   # fill missing values with 0
  ) %>%
  summarise(correlation = cor(Rep1, Rep2), .groups = "drop")  # here something dosent work=> Rep2 is not recognized 

# Print results
print(results)

ms_long %>%
  count(Protein, Treatment)



```


# completly new shit just trying to see if the normalisation was the reason our PC analysis wasnt working, maybe a interesting thing to look for further steps in the pipeline
```{r}
                        # neue Normalization that maybe works better: 


# Log2 transformation (adding 1 to avoid log(0))
MS_log <- log2(MS_Table_Averages + 1)

# Row-wise z-score scaling: center and scale each protein across all samples (fractions)
MS_scaled <- t(scale(t(MS_log)))

rownames(MS_scaled) <- rownames(MS_Table_Averages)

# Optional: check a few rows
head(round(MS_scaled, 2))

#filter proteins with low variance 
# 1. Compute variance across proteins (handle NAs)
var_filter <- apply(MS_scaled, 1, var, na.rm = TRUE)

# 2. Compute the 75th percentile of variance, handling NAs in var_filter
threshold <- quantile(var_filter, 0.75, na.rm = TRUE)

# 3. Filter for high-variance proteins
MS_highvar <- MS_scaled[var_filter > threshold, ]

# If any are missing, fix them by assigning unique names

rownames(MS_highvar) <- make.names(rownames(MS_highvar), unique = TRUE)



                         # Linas code zu Peak characterization just applyed to my code 



# fractions = x
x <- 1:25

# define treshold for peak and build function for peak detection
find_peaks <- function(y, threshold = max(y) * 0.03) { 
  peaks <- which(diff(sign(diff(y))) == -2) + 1 #(+1 shifts index back)
  peaks[y[peaks]>= threshold] 
}

# create empty list for results
peak_results <- list()

# for loop over every protein
for (p in seq_len(nrow(MS_highvar))) {
  
  # extract values for Ctrl and RNase
  row_vals <- as.numeric(MS_highvar [p,])
  ctrl_vals <- row_vals[seq(1, 50, by =2)]
  rnase_vals <- row_vals[seq(2, 50, by=2)]
  
  # create empty list for results
  results_row <- list()
  
  # for loop working with Ctrl values first, then with RNase values
  for (cond in c("Ctrl", "RNase")) {
    y <- if (cond == "Ctrl") ctrl_vals else rnase_vals 
    
    # find peaks with earlier build function, if no peak is detected peak1 is max intensity
    peaks <- find_peaks(y)
    if(length(peaks) == 0) {
      peaks <- which.max(y)
    }
    
    # store numer of peaks, but with a maximum of 6 
    n_peaks <- min(length(peaks), 6)
    
    # extract peak height y_peaks and peak position x_peaks
    y_peaks <- y[peaks]
    x_peaks <- x[peaks]

    # store different results in list 
    results_row[[paste0("n_peaks_", cond)]] <- n_peaks
    
    for(n in seq_len(n_peaks)) {
    results_row[[paste0("peak", n, "_height_", cond)]] <- y_peaks[n]
    results_row[[paste0("peak", n, "_position_", cond)]] <- x_peaks[n]
    }
  }
  # store protein results in lisr
  peak_results[[p]] <- results_row
}

# befor we can store data in new dataframe, we need to assign NA to all columns that have no values 
rows_df <- lapply(peak_results, function(x){
  columns <- c("peak1_height", "peak1_position", "peak2_height", "peak2_position", "peak3_height", "peak3_position", "peak4_height", "peak4_position", "peak5_height", "peak5_position", "peak6_height", "peak6_position")
  for (cond in c("Ctrl", "RNase")) {
    for (c in columns) {
      key <- paste0(c, "_", cond)
      if(!(key %in% names(x))) {
        x[[key]] <- NA
      }
    }
  }
  as.data.frame(x)
})

# store results in new DataFrame (note: rows_df is a list of dataframes so we need "do.call(r.bind,...)")
Peak_Data2 <- do.call(rbind, rows_df)
rownames(Peak_Data2) <- rownames(MS_highvar)

# reorder columns of Peak_Data2
order <- c("n_peaks_Ctrl", "n_peaks_RNase")

for (i in 1:6) {
  order <- c(order, 
                 paste0("peak", i, "_height_Ctrl"),
                 paste0("peak", i, "_position_Ctrl"),
                 paste0("peak", i, "_height_RNase"),
                 paste0("peak", i, "_position_RNase"))
}

Peak_Data2 <- Peak_Data2[, order]

# show head of PeakData to check 
head(Peak_Data2)

colnames(Peak_Data2)




                          # PCa jetzt auf neue daten runnen + vergleich zu RBPs 


# Load required package
library(ggplot2)


# Assume your data is in a data frame called 'df'
# Rows = proteins, Columns = the 26 features you mentioned
# First, remove rows with any NA values
Peak_Data_clean <- na.omit(Peak_Data2)

# Remove columns with zero variance
Peak_Data_clean_clean <- Peak_Data_clean[, apply(Peak_Data_clean, 2, function(col) sd(col, na.rm = TRUE) != 0)]

# Perform PCA (center and scale the data)
pca_result <- prcomp(Peak_Data_clean_clean, center = TRUE, scale. = TRUE)

# Extract the scores for the first two principal components
pc_scores <- as.data.frame(pca_result$x[, 1:2])

# Add protein names as a column (assuming they are rownames)
pc_scores$Protein <- rownames(pc_scores)

# Create a new column that marks whether the protein is in t_test_positives (taken from further steps of the analysis)

pc_scores$Significant <- ifelse(pc_scores$Protein %in% t_test_positives, "RBPs", "No")

# Plot the PCA
ggplot(pc_scores, aes(x = PC1, y = PC2, color = Significant)) +
  geom_point(alpha = 0.7, size = 1.5) +
  scale_color_manual(values = c("RBPs" = "red", "No" = "black")) +
  theme_minimal() +
  labs(title = "PCA of Protein Features (highlighting significant proteins)",
       x = "PC1", y = "PC2", color = "Significant")


```

# lets run it on shift charachteristics 


```{r}

# Select the 4 columns to use for PCA
pca_input <- Shift_Data[, c("CoM_Ctrl", "CoM_RNase", "shift_distance", "shift_direction")]

# Remove rows with NA values
pca_input_clean <- na.omit(pca_input)

# Optionally remove constant columns
pca_input_clean <- pca_input_clean[, apply(pca_input_clean, 2, function(col) sd(col, na.rm = TRUE) != 0)]

# Run PCA
pca_result <- prcomp(pca_input_clean, center = TRUE, scale. = TRUE)

# Extract scores and add protein names
pc_scores <- as.data.frame(pca_result$x[, 1:2])
pc_scores$Protein <- rownames(pca_input_clean)

# Mark significant proteins
pc_scores$Significant <- ifelse(pc_scores$Protein %in% t_test_positives, "RBPs", "No")

# Plot
ggplot(pc_scores, aes(x = PC1, y = PC2, color = Significant)) +
  geom_point(alpha = 0.7, size = 1.5) +
  scale_color_manual(values = c("RBPs" = "red", "No" = "black")) +
  theme_minimal() +
  labs(title = "PCA on shift distance", x = "PC1", y = "PC2", color = "Significant")

```




# ok people ich bin bored also mach ich jetzt noch kmeans clustering nur auf RBPs in mitosis 
```{r}
# Filter only the RBPs relevant in Mitosis 
filtered_data_shift <- Shift_Data[rownames(Shift_Data) %in% RBPs_Mitosis, ]

# Load your dataset (CSV or kmeans frame)
kmeans <- filtered_data_shift # Replace with your file or data frame


# Select 4 specific columns by name or position


K <- kmeans[, c("CoM_Ctrl", "CoM_RNase", "shift_distance")]  # Replace with column names

K <- na.omit(K)          # Remove rows with any NA
K <- as.matrix(K)        # Ensure it’s still a numeric matrix


# Convert to matrix
K <- as.matrix(K)

# K-means clustering
k <- 3                    #number of clusters 
set.seed(42)
kmeans_result <- kmeans(K, centers = k) # here i put in my data 

# Reduce to 2D with PCA
pca_results <- prcomp(K, scale. = TRUE)
K_2D <- pca_results$x[, 1:2]

# Plot clusters
plot(K_2D, col = kmeans_result$cluster, pch = 19,
     main = "K-means Clustering (PCA-reduced 2D)",
     xlab = "PC1", ylab = "PC2")
legend("topright", legend = paste("Cluster", 1:k), col = 1:k, pch = 19)





```