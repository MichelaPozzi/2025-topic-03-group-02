---
title: "2025-topic-03-group-02-code"
output: html_document
date: "2025-05-16"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

##Loading MS-Data
```{r}
MS_Table <- read.table("RDeeP_HeLa_Mitosis.csv", header = TRUE, row.names = 1, sep = ";")
```

# Data Cleanup
## Despription of the Data
```{r}
n_rows = nrow(MS_Table) 
n_rows # Number of Proteins
n_cols = ncol(MS_Table) 
n_cols # Number of varibale
unique(sapply(MS_Table, class)) # classification of variables
any(is.na(MS_Table)) # missing values
min(MS_Table) # minimum intensity
max(MS_Table) # maximum intensity
```

## Restructuration of the data
Create a dataframe with factors that make it possible to access specific data from MS_Table
```{r}
treatment <- factor(rep(c("Ctrl", "RNAse"), each = 3, length.out = 150))
replicate <- factor(rep(c("Ctrl_Rep1", "Ctrl_Rep2", "Ctrl_Rep3", "RNAse_Rep1","RNAse_Rep2", "RNAse_Rep3"),25))
fraction <- factor(rep(paste0("Fraction_", 1:25), each = 6))

data <- data.frame(rownames = colnames(MS_Table),treatment = treatment, replicate = replicate, fraction = fraction)
data
```
## Normalization of triplicates 
Create a new dataframe with average values of the replicates 
```{r}
average.list <- list() #create list

# for loop, going through all fractions: 
# selecting Ctrl columns for specific fraction
# computing average of these columns 
# adding a new vector to list e.g."Ctrl_Fraction_1" and assigning average values 

for (f in levels(fraction)) {
  
  cols.Ctrl <- which(fraction == f & treatment == "Ctrl") 
  average.Ctrl <- rowMeans(MS_Table[,cols.Ctrl]) 
  average.list[[paste0("Ctrl_",f)]] <- average.Ctrl # paste0 funktion checken
  
  cols.RNAse <- which(fraction == f & treatment == "RNAse")
  average.RNAse <- rowMeans(MS_Table[,cols.RNAse])
  average.list[[paste0("RNAse_",f)]] <- average.RNAse
}

MS_Table_Averages <- as.data.frame(average.list) #convert list to dataframe
rownames(MS_Table_Averages) <- rownames(MS_Table) #assign Protein IDs to average values

#Define new order of columns ("levels" works in alphabetic order, not useful for us)
fractions <- paste0("Fraction_", 1:25)

ordered_names <- as.vector(rbind(
  paste0("Ctrl_", fractions),
  paste0("RNAse_", fractions)
))

MS_Table_Averages <- MS_Table_Averages[, ordered_names]
head(MS_Table_Averages)
```
## Normalization to 100 
Create a new dataframe in which the values for each protein are scaled so that the distribution within the Ctrl and RNAse conditions each sums to 100
```{r}
# Split up Control and RNAse values 
ctrl_cols <- grep("^Ctrl_", colnames(MS_Table_Averages)) # grep function genauer schauen 
rnase_cols <- grep("^RNAse_", colnames(MS_Table_Averages))
# Normalization of each group to 100 
ctrl_norm <- MS_Table_Averages[, ctrl_cols] / rowSums(MS_Table_Averages[, ctrl_cols]) * 100
rnase_norm <- MS_Table_Averages[, rnase_cols] / rowSums(MS_Table_Averages[, rnase_cols]) * 100
# Combine in one table 
MS_Table_Norm <- cbind(ctrl_norm, rnase_norm)
MS_Table_Norm <- MS_Table_Norm[, colnames(MS_Table_Averages)]
head(round(MS_Table_Norm, 2))
# Verify the calculation with one example; the row sum should be ~200 (Ctrl 100% + RNAse 100%)
rowSums(MS_Table_Norm["1433B_HUMAN", ]) 
```


## Testung auf Normalverteilung 
--> work in progress, nicht sicher ob wir das direkt schon brauchen 
--> hab nur bisschen rumprobiert 
--> Note: QQ Plots für Normalverteilung 
```{r}
# Beispielhaftes Protein auswählen
protein_qq <- "1433E_HUMAN"
# Daten für xy-Punktdiagramm sammeln
fractions_xy <- 1:25
ctrl_xy <- grep("^Ctrl_", colnames(MS_Table_Norm), value = TRUE)
protein_val_xy <- as.numeric(MS_Table_Norm[protein_qq, ctrl_xy])
# Daten für QQ-Plot sammeln
ctrl_qq <- grep("^Ctrl_", colnames(MS_Table_Averages), value = TRUE)
protein_val_qq <- as.numeric(MS_Table_Averages[protein_qq, ctrl_qq])
log_val_qq <- log(protein_val_qq + 1)
# Histogramm erstellen
hist(log_val_qq, breaks = 10, col = "pink", main = paste("Histogramm:", protein_qq))
# QQ-Plot erstellen
qqnorm(log_val_qq,
       main = paste("QQ-Plot für", protein_qq, "(nur Ctrl)"),
       pch = 19, col = "darkgreen")
qqline(log_val_qq, col = "red", lwd = 2)
# Auf Normalverteilung testen (nach log Transformation siehe Zeile 100)
shapiro.test(log_val_qq)
# xy-Punktdiagramm plotten
plot(fractions_xy, protein_val_xy, type = "o", col = "blue", pch = 16,
     xlab = "Fraktion", ylab = "Intensität",
     main = paste("Protein:", protein_qq, "(Ctrl)"))

```





## Reproducibility Analysis
```{r}

```

# Data Analysis
## Gaussian Fitting

```{r}
# Load package to use a sturdy fuction for gaussian fitting, that also works with critical starting values and sloping curves

library(minpack.lm)

# Build multi gaussian sumfuction up to 3 peaks (for later use)
# note: A = amplitude (height of peak), µ = mean (peak position); sigma = standard deviation (width of peak), x = fraction
# we can exclude the normalization factor, since our data is already normalized
# for more than one peak we need to sum up the gaussian curves of multiple peaks
# for the 2nd /3rd peak we are using default values, so we can also use the function for one peak

multi_gauss <- function(x, A1, mu1, sigma1,
                          A2 = 0, mu2 = 0, sigma2 = 1,
                          A3 =0, mu3 = 0, sigma3 = 1) {
    A1 * exp(-(x - mu1)^2 / (2 * sigma1^2)) + 
    A2 * exp (-(x - mu2)^2 / (2* sigma2^2)) + 
    A3 * exp(-(x - mu3)^2 / (2* sigma3^2))
  }

# build fuction to determin of number of peaks on raw data (for later use)
# threshold t is the minimal peak hight we are acepting (3% of maximal intensity, the rest ist noise) <- has proven to be a good limit
# note: diff() computes the slope between to points, sign() then gives the sign of the slope +1/0/-1, if slope changes from positive to negative diff() between +1 and -1 = -2

t = max(y) * 0.03 
find_peaks <- function(y, threshold = t) { 
  peaks <- which(diff(sign(diff(y))) == -2) + 1 #(+1 shifts index back)
  peaks[y[peaks]>= threshold] # [peaks] = peak intensität <- only those over thresohold
}

# create list for results

fit_results <- list()

# x-achsis for fited curves (fraction 1-25)

x <- 1:25

# fitting of every protein (Ctrl and RNAse) using for-loops
# for loop that goes through every protein/row, extracts the Ctrl values and RNAse and saves them in seperate vectors

for (p in seq_len(nrow(MS_Table_Norm))) {
  row_vals <- as.numeric(MS_Table_Norm [p,])
  ctrl_vals <- row_vals[seq(1, 50, by =2)]
  rnase_vals <- row_vals[seq(2, 50, by=2)]
  
  #create emty list for results of this protein
  
  results_row <- list()
  
  # second for loop that first works with Ctrl, then RNAse values of protein
  # with cond and vector c("Ctrl", "RNAse"), we are computing the for loop to run exactly two times, first under condition "Ctrl" then under condition "RNAse"
  # in the first loop under "Ctrl" the ctrl_values are used, then in the second loop the rnase_vals
  #
  for (cond in c("Ctrl", "RNAse")) {
    y <- if (cond == "Ctrl") ctrl_vals else rnase_vals 
    
    # finding peaks, if no peaks are detected --> fallback mechanism: find maximum intensity and asign fraction as peak position
    
    peaks <- find_peaks(y)
    if(length(peaks) == 0) {
      peaks <- which.max(y)
    }
    
    #determine how many peaks have been found, but use 3 at a max
    
    n_peaks <- min(length(peaks),3)
    
    # extract intensity values for each peak as starting values for A (y[peaks]) and fraction of each peak as starting value for mu (x[peaks])
    
    y_peaks <- y[peaks]
    x_peaks <- x[peaks]
    
    #define start values for up to three peaks using if clauses; sigma = 2 was an estimate that has proven to be a good starting value, since there are 25 fractions
    
    starts <- list(A1 = y_peaks[1], mu1 = x_peaks[1], sigma1 = 2)
    if (n_peaks >= 2) {
      starts <- c(starts, list(A2 = y_peaks[2], mu2 = x_peaks[2], sigma2 = 2)) }
      else {
        starts <- c(starts, list(A2 = 0, mu2 = 0, sigma2 = 2))}
    if (n_peaks == 3) {
      starts <- c(starts, list(A3 = y_peaks[3], mu3 = x_peaks[3], sigma3 = 2)) }
      else {
        starts <- c(starts, list(A3 = 0, mu3 = 0, sigma3 = 2))}

  
    # fitting with our multi gaussian fuction and try(), collect fit data in vector "fit"
    # using if clauses to go through every possibility: 1, 2,  or 3 peaks, and build a model with 1 up to three gaussian curves
    # we can't use multi_gauss with one peak, so we fit those with a normal gauss function (has proven to be necessary)
    # nlsLM = function that fits our gaussian curves formular /function we are giving "y ~..." (this is a nonlinear fitting fuction)
    # we need a lower and a upper limit, since in extreme cases, the estimation can be unrealistic (proven)
    # we are using "maxiter = 500" , meaning that the function will try to fit until 500 iterations and not break of earlier/longer search time (proven to be needed, since the function would terminate many estimations, that could be successful)
    # not all fits ar going to be successful:
    # "warnOnly" guarantees that the code keeps running, even if the fitting of a protein is not successful (happens for a few proteins)
    # function try() is another important protective measure, to ensure, that if "try" was not successful, the code keeps running, and there is only an error message for this protein (silent = TRUE <- error message not shown in console) 
    
    if (n_peaks == 1) {
      fit <- try(nlsLM(y ~ A1 * exp(-((x - mu1)^2) / (2 * sigma1^2)),
                       start = list(A1 = y_peaks[1], mu1 = x_peaks[1], sigma1 = 2),
                                    lower = c(A1 = 0, mu1 = 1, sigma1 = 0.3),
                                    upper = c(A1 = Inf, mu1 = 25, sigma1 = 5),
                       control = list(maxiter = 500, warnOnly = TRUE)
                       ), 
                 silent = TRUE)
      } 
    else if (n_peaks == 2) {
      fit <- try(nlsLM(y ~ multi_gauss(x, A1, mu1, sigma1, A2, mu2, sigma2),
                       start = list(
                         A1 = y_peaks[1], mu1 = x_peaks[1], sigma1 = 2,
                         A2 = y_peaks[2], mu2 = x_peaks[2], sigma2 = 2),
                       lower = c(A1 = 0, mu1 = 1, sigma1 = 0.3,
                                 A2 = 0, mu2 = 1, sigma2 = 0.3),
                       upper = c(A1 = Inf, mu1 = 25, sigma1 = 5,
                                 A2 = Inf, mu2 = 25, sigma2 = 5),
                       control = list(maxiter = 500, warnOnly = TRUE)
                       ), 
                 silent = TRUE)
      } 
    else {fit <- try(nlsLM(y ~ multi_gauss(x, A1, mu1, sigma1, A2, mu2, sigma2, A3, mu3, sigma3),
                           start = list(
                              A1 = y_peaks[1], mu1 = x_peaks[1], sigma1 = 2,
                             A2 = y_peaks[2], mu2 = x_peaks[2], sigma2 = 2,
                             A3 = y_peaks[3], mu3 = x_peaks[3], sigma3 = 2),
                           lower = c(A1 = 0, mu1 = 1, sigma1 = 0.3,
                                     A2 = 0, mu2 = 1, sigma2 = 0.3,
                                     A3 = 0, mu3 = 1, sigma3 = 0.3),
                           upper = c(A1 = Inf, mu1 = 25, sigma1 = 5,
                                     A2 = Inf, mu2 = 25, sigma2 = 5,
                                     A3 = Inf, mu3 = 25, sigma3 = 5),
                           control = list(maxiter = 500, warnOnly = TRUE)
                           ), 
                     silent = TRUE)
   }
    
    # collect results for this protein in results_row and add to fit_results list
    # if clauses for when there is no "try-error" message (successful fit) for protein and when there is an error (n)
    # "coef" extracts parameter values (A1, mu1, ../ coefficients)
    # give parameters name in loist results_row and assign computed values 
    # "paste0" takes a text frgment given and puts them together without spaces
    # [[]] needed to access a specific value, not a list
    # assign new variable "Fit_OK_ " to result list to show successful and not successfully fitted proteins
    
    if(!inherits(fit, "try-error")) {
      coef_vals <- coef(fit)
      for (i in names(coef_vals)) {
        results_row[[paste0(i,"_", cond)]] <- coef_vals[i]
      }
      results_row[[paste0("Fit_OK_", cond)]] <- TRUE
      results_row[[paste0("n_peaks_", cond)]] <- n_peaks
    }
    else {
      results_row[[paste0("Fit_OK_", cond)]] <- FALSE
      results_row[[paste0("n_peaks_", cond)]] <- 0
    }
  }
  # close for loop, and save protein data in list fit_results
  fit_results[[p]] <- results_row
}

# make data.frame out of list (quite complicated, cause not every protein has the same amount of values)
# going through data for each protein x in fit_results
# if there is no value for a specific field/parameter (A1, mu1,...) we are assigning "NA" (%in% = "is included in")

rows_df <- lapply(fit_results, function(x){
  fields <- c("A1", "mu1", "sigma1", "A2", "mu2", "sigma2", "A3", "mu3", "sigma3")
  for (cond in c("Ctrl", "RNAse")) {
    for (f in fields) {
      key <- paste0(f, "_", cond)
      if(!(key %in% names(x))) {
        x[[key]] <- NA
      }
    }
  }
  as.data.frame(x)
})

#assemble all date in one dataframe
# problem: rows_df is a list of one row dataframes (since we used lapply), we need to split up the list with do.call, and bind all dataframes with rbind
MS_Data_Fitted <- do.call(rbind, rows_df)
rownames(MS_Data_Fitted) <- rownames(MS_Table_Norm)
head(MS_Data_Fitted)

# Number of proteins that where successfully fitted
sum(MS_Data_Fitted$Fit_OK_Ctrl & MS_Data_Fitted$Fit_OK_RNAse) 

```

## Plotting a Protein
```{r}
# choos protein
protein <- "AB1IP_HUMAN"  

# find data for protein in MS_Data_Fitted and 
row <- MS_Data_Fitted[rownames(MS_Data_Fitted) == protein, , drop = FALSE]

# x-Achse
x_vals <- seq(1, 25, by = 0.1)

# Gaussian-Kurvenfunktion (für Ctrl oder RNAse)
gauss_curve <- function(row, condition, x) {
  y <- rep(0, length(x))
  n_peaks <- row[[paste0("n_peaks_", condition)]]
  for (i in 1:n_peaks) {
    A <- row[[paste0("A", i, "_", condition)]]
    mu <- row[[paste0("mu", i, "_", condition)]]
    sigma <- row[[paste0("sigma", i, "_", condition)]]
    y <- y + A * exp(-((x - mu)^2) / (2 * sigma^2))
  }
  return(y)
}

# Berechne die Kurven
y_ctrl <- gauss_curve(row, "Ctrl", x_vals)
y_rnase <- gauss_curve(row, "RNAse", x_vals)

# Plot
plot(x_vals, y_ctrl, type = "l", col = "green", lwd = 2,
     ylim = range(c(y_ctrl, y_rnase), na.rm = TRUE),
     xlab = "Fraktion", ylab = "Fit-Intensität",
     main = paste("Gaussian-Fits für", protein))
lines(x_vals, y_rnase, col = "red", lwd = 2)

legend("topright", legend = c("Ctrl", "RNAse"),
       col = c("green", "red"), lwd = 2)

```


######## BackUP
Idee Correlation: 
- mit allen 3 Reps und Proteinenanzahl die wir signifikant empfinden (langsam rantasten, wann sieht man keinen Unterschied mehr) --> Sofia macht R-Werte etc  
- schöne Heatmap :)))) --> Cihan macht Korrelationsmatrix und Heatmap 
- zwar schwieriger wahrscheinlicher, aber cooler 

Idee Normalisierung der Daten: 
- MS-Tabel komplett normalisieren 
- einfacher, aber nicht so schön 



## Reproducibility Analysis
```{r}
# Choose your protein of interest
protein_name <- "1433G_HUMAN"

# Extract abundance values (they are in the row named "1433B_HUMAN")
abundance_values <- as.numeric(MS_Table[protein_name, ])

# Add them to the metadata table
data_copie <- data
data_copie$abundance <- abundance_values

data_copie
```



```{r}

# create empty vectors to store the values

sd_values <- numeric(25)
mean_values <- numeric(25)

# create loop for all 25 fractions 
for (i in 1:25) {
  # Define replicate labels ( RNAse or Ctrl)
  reps <- paste0("RNAse_Rep", 1:3)
  
  # Filter just the current fraction and replicates
  subset_data <- data[data$fraction == paste0("Fraction_", i) & data$replicate %in% reps, ]
  
  # Extract abundance values
  values <- subset_data$abundance
  
  # Compute standard deviation + compute mean
  sd_values[i] <- sd(values)
  
  mean_values[i] <- mean(values)
}

# Create result table 
result_tablesd <- data.frame(
  Fraction = paste0("Fraction_", 1:25),
  SD = sd_values
)
result_tablesd

result_tablemean <- data.frame(
  Fraction = paste0("Fraction_", 1:25),
  MEAN = mean_values
)
result_tablemean

```
--> hier wurde doch basicly schon unser Barplot gemacht, wie wir ihn dann für jedes Protein mit unseren Normalisierten Values machen wollen oder? (Zusammenhang Reproducibility?)
```{r}
# code for a barplot

# Combine by 'fraction' column
result_table <- merge(result_tablesd, result_tablemean, by = "Fraction")

# Optional: rename for clarity
colnames(result_table) <- c("Fraction", "Mean", "SD")

# Sort fractions numerically
result_table$Fraction_num <- as.numeric(gsub("Fraction_", "", result_table$Fraction))
result_table <- result_table[order(result_table$Fraction_num), ]

# Plot bars and store bar positions
bar_positions <- barplot(result_table$Mean,
                         names.arg = result_table$Fraction,
                         las = 2,
                         col = "lightblue",
                         ylim = c(0, max(result_table$Mean + result_table$SD, na.rm = TRUE)),
                         main = "Mean Abundance per Fraction",
                         ylab = "Mean Abundance")

```

### beak up gaussian fitting
```{r}
# load package to use a stury fuction for gaussian fitting, that also works with critical starting values and sloping curves
library(minpack.lm)

# build multi gaussian sumfuction up to 3 peaks (for later use)
multi_gauss <- function(x, A1, mu1, sigma1,
                        A2 = 0, mu2 = 0, sigma2 = 1,
                        A3 =0, mu3 = 0, sigma3 = 1) {
  A1 * exp(-(x - mu1)^2 / (2 * sigma1^2)) + 
    A2 * exp (-(x - mu2)^2 / (2* sigma2^2)) + 
    A3 * exp(-(x - mu3)^2 / (2* sigma3^2))
}

# build fuction for determination of number of peaks on raw data (for later use)
t = max(y) * 0.03 
find_peaks <- function(y, threshold = t) { 
  peaks <- which(diff(sign(diff(y))) == -2) + 1 #funktion um peaks rauszusuchen durch Steigungsberechnung/änderung (siehe Foto)
  peaks[y[peaks]>= threshold] # [peaks] = peak intensität
}

# create list for results
fit_results <- list()

# x-achsis for fited curves (fraction 1-25)
x <- 1:25

#fitting of every protein (Ctrl and RNAse) using for-loops
# for loop that goes throu every protein/row
for (p in seq_len(nrow(MS_Table_Norm))) {
  protein_id <- rownames(MS_Table_Norm)[p]
  row_vals <- as.numeric(MS_Table_Norm [p,])
  ctrl_vals <- row_vals[seq(1, 50, by =2)]
  rnase_vals <- row_vals[seq(2, 50, by=2)]
  
  results_row <- list(Protein_ID = protein_id)
  
  # for loop that first works with Ctrl, then RNase values 
  for (cond in c("Ctrl", "RNAse")) {
    y <- if (cond == "Ctrl") ctrl_vals else rnase_vals
    peaks <- find_peaks(y)
    if(length(peaks) == 0) {
      peaks <- which.max(y)
    }
    n_peaks <- min(length(peaks),3)
    
    y_peaks <- y[peaks]
    x_peaks <- x[peaks]
    
    #define start values for up to three peaks
    
    starts <- list(A1 = y_peaks[1], mu1 = x_peaks[1], sigma1 = 2)
    if (n_peaks >= 2) {
      starts <- c(starts, list(A2 = y_peaks[2], mu2 = x_peaks[2], sigma2 = 2)) }
      else {
        starts <- c(starts, list(A2 = 0, mu2 = 0, sigma2 = 2))}
    if (n_peaks == 3) {
      starts <- c(starts, list(A3 = y_peaks[3], mu3 = x_peaks[3], sigma3 = 2)) }
      else {
        starts <- c(starts, list(A3 = 0, mu3 = 0, sigma3 = 2))}

  
    # fitting with our multi gaussian fuction and try(), collect fit data in vector
    if (n_peaks == 1) {
      fit <- try(nlsLM(y ~ A1 * exp(-(x - mu1)^2 / (2 * sigma1^2)),
                 start = list(A1 = y_peaks[1], mu1 = x_peaks[1], sigma1 = 2),
                 control = list(maxiter = 500, warnOnly = TRUE)
                 ),
                 silent = TRUE)
      } 
    else if (n_peaks == 2) {
      fit <- try(nlsLM(y ~ multi_gauss(x, A1, mu1, sigma1, A2, mu2, sigma2),
                 start = list(A1 = y_peaks[1], mu1 = x_peaks[1], sigma1 = 2,
                              A2 = y_peaks[2], mu2 = x_peaks[2], sigma2 = 2),
                 control = list(maxiter = 500, warnOnly = TRUE)
                 ),
                 silent = TRUE)
      } 
    else {
        fit <- try(nlsLM(y ~ multi_gauss(x, A1, mu1, sigma1, A2, mu2, sigma2, A3, mu3, sigma3),
                 start = list(A1 = y_peaks[1], mu1 = x_peaks[1], sigma1 = 2,
                              A2 = y_peaks[2], mu2 = x_peaks[2], sigma2 = 2,
                              A3 = y_peaks[3], mu3 = x_peaks[3], sigma3 = 2),
                 control = list(maxiter = 500, warnOnly = TRUE)
                 ),
                 silent = TRUE)}
    
    # collect results for this protein in results_row and ad to fit_results list
    
    if(!inherits(fit, "try-error")) {
      coef_vals <- coef(fit)
      for (i in names(coef_vals)) {
        results_row[[paste0(i,"_", cond)]] <- coef_vals[i]
      }
      results_row[[paste0("Fit_OK_", cond)]] <- TRUE
      results_row[[paste0("n_peaks_", cond)]] <- n_peaks
    }
    else if (max(y, na.rm = TRUE) > 10) {
      peak_pos <- which.max(y)
      peak_val <- suppressWarnings(max(y, na.rm = TRUE))
      if(is.finite(peak_val) && peak_val > 5) {
      
      results_row[[paste0("A1_",cond)]] <- peak_val
      results_row[[paste0("mu1_",cond)]] <- peak_pos
      results_row[[paste0("sigma1_",cond)]] <- NA
      results_row[[paste0("Fit_OK_",cond)]] <- FALSE
      results_row[[paste0("n_peaks_",cond)]] <- 1
      }
    }
    else {
      results_row[[paste0("Fit_OK_", cond)]] <- FALSE
      results_row[[paste0("n_peaks_", cond)]] <- 0
    }
  }
  fit_results[[p]] <- results_row
}

# make data.frame out of list (quite comlicated, cause not every protein has the same amout of values)
rows_df <- lapply(fit_results, function(x){
  fields <- c("A1", "mu1", "sigma1", "A2", "mu2", "sigma2", "A3", "mu3", "sigma3")
  for (cond in c("Ctrl", "RNAse")) {
    for (f in fields) {
      key <- paste0(f, "_", cond)
      if(!(key %in% names(x))) {
        x[[key]] <- NA
      }
    }
    if(!paste0("Fit_OK_", cond) %in% names(x)) x[[paste0("Fit_OK_", cond)]] <- FALSE
    if(!paste0("n_peaks_", cond) %in% names(x)) x[[paste0("n_peaks_", cond)]] <- 0
  }
  as.data.frame(x)
})
MS_Data_Fitted <- do.call(rbind, rows_df)
rownames(MS_Data_Fitted) <- rownames(MS_Table_Norm)
head(MS_Data_Fitted)
sum(MS_Data_Fitted$Fit_OK_Ctrl & MS_Data_Fitted$Fit_OK_RNAse) # Number of proteins that where successfully fitted
sum(!is.na(MS_Data_Fitted$A1_Ctrl) & !is.na(MS_Data_Fitted$A1_RNAse)) # Numer of proteins in which a peak could successfully be detected

````


