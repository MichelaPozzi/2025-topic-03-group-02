---
title: "2025-topic-03-group-02-code"
output: html_document
date: "2025-05-16"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Legend for all tables / dataframes:

- MS_Table: Original table
- MS_Table_Averages: Triplicates normalised (average)
- MS_Table_Norm: Triplicates normalised + Amount of protein normalised

- shapiro_results: results of test on normal distribution
- full_correlation_results: results of spearman correlation

- Peak_Data: Number of peaks, peak heights and peak positions for Ctrl and RNase (on MS_Table_Norm)
- Shift_Data: CoM for Ctrl and RNAse, Shift distance and Shift direction (+ Shift Significance) (on MS_Table_Norm)

- Norm_Data_for_t: Amount of protein normalised for all replicates
- CoM_Data_for_t: CoM for Ctrl and RNAse for all replicates

#Loading MS-Data
```{r}
MS_Table <- read.table("RDeeP_HeLa_Mitosis.csv", header = TRUE, row.names = 1, sep = ";")
```

# Data Cleanup
## Despription of the Data
```{r}
n_rows = nrow(MS_Table) 
n_rows # Number of Proteins
n_cols = ncol(MS_Table) 
n_cols # Number of varibale
unique(sapply(MS_Table, class)) # classification of variables
any(is.na(MS_Table)) # missing values
min(MS_Table) # minimum intensity
max(MS_Table) # maximum intensity


```

## Restructuration of the data
Create a dataframe with factors that make it possible to access specific data from MS_Table
```{r}
treatment <- factor(rep(c("Ctrl", "RNase"), each = 3, length.out = 150))
replicate <- factor(rep(c("Ctrl_Rep1", "Ctrl_Rep2", "Ctrl_Rep3", "RNase_Rep1","RNase_Rep2", "RNase_Rep3"),25))
fraction <- factor(rep(paste0("Fraction_", 1:25), each = 6))

data <- data.frame(rownames = colnames(MS_Table),treatment = treatment, replicate = replicate, fraction = fraction)
data
```
## Normalization of triplicates 
Create a new dataframe with average values of the replicates 
```{r}
average.list <- list() #create list

# for loop, going through all fractions: 
# selecting Ctrl columns for specific fraction
# computing average of these columns 
# adding a new vector to list e.g."Ctrl_Fraction_1" and assigning average values 

for (f in levels(fraction)) {
  
  cols.Ctrl <- which(fraction == f & treatment == "Ctrl") 
  average.Ctrl <- rowMeans(MS_Table[,cols.Ctrl]) 
  average.list[[paste0("Ctrl_",f)]] <- average.Ctrl # paste0 funktion checken
  
  cols.RNase <- which(fraction == f & treatment == "RNase")
  average.RNase <- rowMeans(MS_Table[,cols.RNase])
  average.list[[paste0("RNase_",f)]] <- average.RNase
}

MS_Table_Averages <- as.data.frame(average.list) #convert list to dataframe
rownames(MS_Table_Averages) <- rownames(MS_Table) #assign Protein IDs to average values

#Define new order of columns ("levels" works in alphabetic order, not useful for us)
fractions <- paste0("Fraction_", 1:25)

ordered_names <- as.vector(rbind(
  paste0("Ctrl_", fractions),
  paste0("RNase_", fractions)
))

MS_Table_Averages <- MS_Table_Averages[, ordered_names]
head(MS_Table_Averages)
```
## Normalization to 100 
- Create a new dataframe in which the values for each protein are scaled so that the distribution within the Ctrl and RNAse conditions each sums to 100
```{r}
# Split up Control and RNAse values 
ctrl_cols <- grep("^Ctrl_", colnames(MS_Table_Averages)) # grep function genauer schauen 
rnase_cols <- grep("^RNase_", colnames(MS_Table_Averages))

# Normalization of each group to 100 
ctrl_norm <- MS_Table_Averages[, ctrl_cols] / rowSums(MS_Table_Averages[, ctrl_cols]) * 100
rnase_norm <- MS_Table_Averages[, rnase_cols] / rowSums(MS_Table_Averages[, rnase_cols]) * 100

# Combine in one table 
MS_Table_Norm <- cbind(ctrl_norm, rnase_norm)
MS_Table_Norm <- MS_Table_Norm[, colnames(MS_Table_Averages)]
head(round(MS_Table_Norm, 2))

# Verify the calculation with one example; the row sum should be ~200 (Ctrl 100% + RNAse 100%)
rowSums(MS_Table_Norm["1433B_HUMAN", ]) 
```

## Plotting a protein with normalised data 
```{r}
# Choos Protein
protein_of_interest <- "ABCF1_HUMAN" # hier dein Protein einsetzen

# Extract protein data
protein_row <- MS_Table_Norm[rownames(MS_Table_Norm) == protein_of_interest, ]

# Store Ctrl and RNase Values 
ctrl_values <- as.numeric(protein_row[seq(1, 49, by=2)])
rnase_values <- as.numeric(protein_row[seq(2, 50, by=2)])

fractions <- 1:25

# Plot
plot(fractions, ctrl_values, type="o", pch=16, lty=1, col="green", ylim=range(c(ctrl_values, rnase_values)),
     xlab="Fraction", ylab="Normalized Intensity", main=protein_of_interest)
lines(fractions, rnase_values, type="o",pch =16, lty=1, col="red")
legend("topright", legend=c("Ctrl", "RNase"), col=c("green", "red"), lty=1, pch=16)
```

## Test for Normal Distribution (requirement for t-test) 
- Description nessesary and all code descriptions in english
```{r}
# Pakete laden 
library(dplyr)

# Leere Liste für Zwischenspeicherung 
results_list <- list()
counter <- 1

# Proteine durchlaufen
for (protein in rownames(MS_Table)) {
  
  for (fraction_num in 1:25) {
    
    # Die korrekten Spaltennamen für Ctrl generieren
    cols_ctrl <- paste0("Fraction", fraction_num, "_Ctrl_Rep", 1:3)
    
    # Prüfen ob alle Spalten existieren 
    existing_cols <- cols_ctrl[cols_ctrl %in% colnames(MS_Table)]
    
    if(length(existing_cols) == 3){
      
      # Werte extrahieren
      protein_values <- as.numeric(MS_Table[protein, existing_cols])
      
      # Nur testen, wenn es Streuung gibt
      if (length(unique(protein_values)) > 1) {
        shapiro_result <- shapiro.test(protein_values)
        shapiro_W <- shapiro_result$statistic
        shapiro_p <- shapiro_result$p.value
      } else {
        shapiro_W <- NA
        shapiro_p <- NA
      }
      
      # Zwischenspeichern
      results_list[[counter]] <- data.frame(
        Protein_ID = protein,
        Fraction = fraction_num,
        Shapiro_W = shapiro_W,
        Shapiro_p = shapiro_p
      )
      counter <- counter + 1
    }
  }
}

# Am Ende alles zusammenfügen
shapiro_results <- do.call(rbind, results_list)

# Entscheidung über Normalverteilung ergänzen
shapiro_results$Is_Normal_Distributed <- shapiro_results$Shapiro_p >= 0.05

# Ergebnisse ausgeben
head(shapiro_results)

# Übersicht wie viele normalverteilt
table(shapiro_results$Is_Normal_Distributed)
```

## Reproducibility Analysis
- Description nessesary and all code descriptions in english
```{r}
# Create empty dataframe for correlation 
full_correlation_results <- data.frame(
  Treatment = character(),
  Replicate_1 = character(),
  Fraction_1 = character(),
  Replicate_2 = character(),
  Fraction_2 = character(),
  Spearman_r = numeric(),
  stringsAsFactors = FALSE
)

# iterate over both Ctrl and RNase Treatment 
for (treatment in c("Ctrl", "RNase")) {
  
  # Create all possible rep-fraction combinations
  combo1 <- expand.grid(Rep = 1:3, Fraction = 1:25)
  combo2 <- expand.grid(Rep = 1:3, Fraction = 1:25)
  
  # iterate for every possible combination
  for (i in 1:nrow(combo1)) {
    for (j in 1:nrow(combo2)) {
      
      rep1 <- combo1$Rep[i]
      frac1 <- combo1$Fraction[i]
      rep2 <- combo2$Rep[j]
      frac2 <- combo2$Fraction[j]
      
      # Find right column position 
      col1 <- which(replicate == paste0(treatment, "_Rep", rep1) & fraction == paste0("Fraction_", frac1))
      col2 <- which(replicate == paste0(treatment, "_Rep", rep2) & fraction == paste0("Fraction_", frac2))
      
      # calculate Spearmen correlation
      cor_value <- cor(MS_Table[, col1], MS_Table[, col2], method = "spearman", use = "complete.obs")
      
      # safe results in dataframe
      full_correlation_results <- rbind(full_correlation_results, data.frame(
        Treatment = treatment,
        Replicate_1 = paste0("Rep", rep1),
        Fraction_1 = paste0("Fraction_", frac1),
        Replicate_2 = paste0("Rep", rep2),
        Fraction_2 = paste0("Fraction_", frac2),
        Spearman_r = cor_value
      ))
    }
  }
}


head(full_correlation_results)


library(tidyverse)
library(pheatmap)

# create column for each axis 
full_correlation_results <- full_correlation_results %>%
   mutate(Row = paste0(Replicate_1, "_F", gsub("Fraction_", "", Fraction_1)),
         Col = paste0(Replicate_2, "_F", gsub("Fraction_", "", Fraction_2)))

# we select treament RNase for our heatmap
treatment_to_plot <- "RNase"

# filter table for selected treatment 
heatmap_data <- full_correlation_results %>%
  filter(Treatment == treatment_to_plot) %>%
  select(Row, Col, Spearman_r)

# convert into matrix 
heatmap_matrix <- heatmap_data %>%
  pivot_wider(names_from = Col, values_from = Spearman_r, values_fill = NA) %>%
  column_to_rownames("Row") %>%
  as.matrix()

# create heatmap
pheatmap(heatmap_matrix,
         main = paste("Spearman Correlation Heatmap -", treatment_to_plot),
         cluster_rows = FALSE, 
         cluster_cols = FALSE, 
         show_rownames = TRUE, 
         show_colnames = TRUE,
         fontsize_row = 4,
         fontsize_col = 4)

```

# Data Analysis

## Peak Characteristics 
- Find number of peaks, all peak positions and corresponding peak heights and store in a df for later use
- Caluculated on normalised data (average of triplicates)
```{r}
# define treshold for peak and build function for peak detection
t = max(y) * 0.03 
find_peaks <- function(y, threshold = t) { 
  peaks <- which(diff(sign(diff(y))) == -2) + 1 #(+1 shifts index back)
  peaks[y[peaks]>= threshold] 
}

# create empty list for results
peak_results <- list()

# for loop over every protein
for (p in seq_len(nrow(MS_Table_Norm))) {
  
  # extract values for Ctrl and RNase
  row_vals <- as.numeric(MS_Table_Norm [p,])
  ctrl_vals <- row_vals[seq(1, 50, by =2)]
  rnase_vals <- row_vals[seq(2, 50, by=2)]
  
  # create empty list for results
  results_row <- list()
  
  # for loop working with Ctrl values first, then with RNase values
  for (cond in c("Ctrl", "RNase")) {
    y <- if (cond == "Ctrl") ctrl_vals else rnase_vals 
    
    # find peaks with earlier build function, if no peak is detected peak1 is max intensity
    peaks <- find_peaks(y)
    if(length(peaks) == 0) {
      peaks <- which.max(y)
    }
    
    # store numer of peaks, but with a maximum of 6 
    n_peaks <- min(length(peaks), 6)
    
    # extract peak height y_peaks and peak position x_peaks
    y_peaks <- y[peaks]
    x_peaks <- x[peaks]

    # store different results in list 
    results_row[[paste0("n_peaks_", cond)]] <- n_peaks
    
    for(n in seq_len(n_peaks)) {
    results_row[[paste0("peak", n, "_height_", cond)]] <- y_peaks[n]
    results_row[[paste0("peak", n, "_position_", cond)]] <- x_peaks[n]
    }
  }
  # store protein results in lisr
  peak_results[[p]] <- results_row
}

# befor we can store data in new dataframe, we need to assign NA to all columns that have no values 
rows_df <- lapply(peak_results, function(x){
  columns <- c("peak1_height", "peak1_position", "peak2_height", "peak2_position", "peak3_height", "peak3_position", "peak4_height", "peak4_position", "peak5_height", "peak5_position", "peak6_height", "peak6_position")
  for (cond in c("Ctrl", "RNase")) {
    for (c in columns) {
      key <- paste0(c, "_", cond)
      if(!(key %in% names(x))) {
        x[[key]] <- NA
      }
    }
  }
  as.data.frame(x)
})

# store results in new DataFrame (note: rows_df is a list of dataframes so we need "do.call(r.bind,...)")
Peak_Data <- do.call(rbind, rows_df)
rownames(Peak_Data) <- rownames(MS_Table_Norm)

# reorder columns of Peak_Data
order <- c("n_peaks_Ctrl", "n_peaks_RNase")

for (i in 1:6) {
  order <- c(order, 
                 paste0("peak", i, "_height_Ctrl"),
                 paste0("peak", i, "_position_Ctrl"),
                 paste0("peak", i, "_height_RNase"),
                 paste0("peak", i, "_position_RNase"))
}

Peak_Data <- Peak_Data[, order]

# show head of PeakData to check 
head(Peak_Data)
```

# Shift Characteristics
- Determine shift distance and shift direction for all proteins and store in a df
- Shift distance is calculated using caluculations of CoM (Center of Mass) for Ctrl and RNAse and caluculating deviation
- Shift direction is specified as +1, 0 or -1; +1 is a left-shift, -1 a right shift
- Caluculated on normalised data (average of triplicates)
```{r}
# fractions = x
x <- 1:25

# empty vectors for results (with length of number of proteins)
CoM_Ctrl <- numeric(nrow(MS_Table_Norm))
CoM_RNase <- numeric(nrow(MS_Table_Norm))
shift_distance <- numeric(nrow(MS_Table_Norm))
shift_direction <- numeric(nrow(MS_Table_Norm))

# for loop over every protein
for (p in seq_len(nrow(MS_Table_Norm))) {
  
  # extract values for Ctrl and RNase
  row_vals <- as.numeric(MS_Table_Norm [p,])
  ctrl_vals <- row_vals[seq(1, 50, by =2)]
  rnase_vals <- row_vals[seq(2, 50, by=2)]
  
  # calculate CoM, shift distance and shift direction
  CoM_Ctrl[p] <- sum(ctrl_vals * x) / sum(ctrl_vals)
  CoM_RNase[p] <- sum(rnase_vals * x) / sum(rnase_vals)
  shift_distance[p] <- CoM_Ctrl[p] - CoM_RNase[p] 
  shift_direction[p] <- sign(shift_distance[p]) 
}

# store results in new dataframe 
Shift_Data <- data.frame(
  CoM_Ctrl = CoM_Ctrl,
  CoM_RNase = CoM_RNase,
  shift_distance = shift_distance,
  shift_direction = shift_direction,
  row.names = rownames(MS_Table_Norm))

head(Shift_Data)

#numer of proteins with shift based on average values (just for interesst, delete later)
sum(Shift_Data$shift_distance > 1, na.rm = TRUE)
```
##T-Test 
### First Normalization of whole MS_Table to 100 
- We decided to run the statistical test on normalised values, so all replicates need to be normalised to 100
```{r}
# Split up all Ctrl and RNAse values and their individual Reps 
ctrl_cols_t1 <- grep("_Ctrl_Rep1", colnames(MS_Table))
ctrl_cols_t2 <- grep("_Ctrl_Rep2", colnames(MS_Table))
ctrl_cols_t3 <- grep("_Ctrl_Rep3", colnames(MS_Table))
RNase_cols_t1 <- grep("_RNase_Rep1", colnames(MS_Table))
RNase_cols_t2 <- grep("_RNase_Rep2", colnames(MS_Table))
RNase_cols_t3 <- grep("_RNase_Rep3", colnames(MS_Table))

# Normalization of each group to 100 
ctrl_norm_t1 <- MS_Table[, ctrl_cols_t1] / rowSums(MS_Table[, ctrl_cols_t1]) * 100
ctrl_norm_t2 <- MS_Table[, ctrl_cols_t2] / rowSums(MS_Table[, ctrl_cols_t2]) * 100
ctrl_norm_t3 <- MS_Table[, ctrl_cols_t3] / rowSums(MS_Table[, ctrl_cols_t3]) * 100
RNase_norm_t1 <- MS_Table[, RNase_cols_t1] / rowSums(MS_Table[, RNase_cols_t1]) * 100
RNase_norm_t2 <- MS_Table[, RNase_cols_t2] / rowSums(MS_Table[, RNase_cols_t2]) * 100
RNase_norm_t3 <- MS_Table[, RNase_cols_t3] / rowSums(MS_Table[, RNase_cols_t3]) * 100

# Combine in one table 
Norm_Data_for_t <- cbind(ctrl_norm_t1, RNase_norm_t1, ctrl_norm_t2, RNase_norm_t2, ctrl_norm_t3, RNase_norm_t3)

# In gewünschter Reihenfolge ordnen
fractions <- 1:25
reps <- 1:3
conditions <- c("Ctrl", "RNase") 


ordered_names <- c()

for (fraction in fractions) {
  for (rep in reps) {
    for (condition in conditions) {
      name <- paste0("Fraction", fraction, "_", condition, "_Rep", rep)
      ordered_names <- c(ordered_names, name)
    }
  }
}

Norm_Data_for_t <- Norm_Data_for_t[, ordered_names]
head(Norm_Data_for_t)
# Verify the calculation with one example; the row sum should be ~600 (3*Ctrl 100% + 3*RNAse 100%)
rowSums(Norm_Data_for_t["1433B_HUMAN", ]) 
```

### Caluclation of Center of mass (CoM) 
- CoM (Center of mass) values are calculated for all replicates and treatments and stored in df
```{r}
# aufstellen von variablen 

fractions <- 1:25
conditions <- c("Ctrl", "RNase")
replicates <- c("Rep1", "Rep2", "Rep3")

#liste erstellen 

results_com <- list()

#looping through conditions and replicates as we want them all seperate

for (cond in conditions) {
  for (rep in replicates) {
    
#selecting colums with grep diesen strich verssteh ich nicht "chat sagt "makes one combined pattern with ORs (|) between them, so grep matches any of them."

    pattern <- paste0("^Fraction", fractions, "_", cond, "_", rep, "$")
    cols <- grep(paste(pattern, collapse="|"), colnames(Norm_Data_for_t), value = TRUE)  

    subdata <- Norm_Data_for_t[, cols]   
#storing coloums 

    subdata <- subdata[, order(as.numeric(gsub("Fraction(\\d+)_.*", "\\1", cols)))]  #extracts the fraction number from column names.

#center of mass calculation

    com <- apply(subdata, 1, function(x) {
      sum(x * fractions) / sum(x)
    })
#store result in list 

    results_com[[paste(cond, rep, sep = "_")]] <- com
  }
}

#convert list to dataframe

# After the loops have finished:
CoM_Data_for_t <- as.data.frame(results_com)   # convert list into data frame

# Add correct rownames:
rownames(CoM_Data_for_t) <- rownames(Norm_Data_for_t)

# View the first few rows to check
head(CoM_Data_for_t)
```
### Calculating Shift-Values for T-Test
- Calculate deviation between CoM of Ctrl and CoM of RNase and store in df for t-test 
```{r}
Shift_Data_for_t <- data.frame(
  shift_distance_rep1 = CoM_Data_for_t[, 1] - CoM_Data_for_t[, 4],
  shift_distance_rep2 = CoM_Data_for_t[, 2] - CoM_Data_for_t[, 5],
  shift_distance_rep3 = CoM_Data_for_t[, 3] - CoM_Data_for_t[, 6],
  row.names = rownames(CoM_Data_for_t)
)

head(Shift_Data_for_t)
any(is.na(Shift_Data_for_t))
```

### T-Test

```{r}
# create empty columns for statistical test results 
Shift_Data$shapiro_p <- NA
Shift_Data$normal_distributed <- NA
Shift_Data$p_value_ttest_filtered <- NA
Shift_Data$significant_ttest_filtered <- NA

# iterate over all proteins 
for (protein in rownames(Shift_Data_for_t)) {
  
  # extract shift distances for each replicate
  shift_values <- as.numeric(Shift_Data_for_t[protein, c("shift_distance_rep1", "shift_distance_rep2", "shift_distance_rep3")])
  
  # make sure that no NAs are present
  if (all(!is.na(shift_values))) {
    
    # check if all values are identical (no variance)
    if (length(unique(shift_values)) == 1) {
      
      # set normal distribution to TRUE if no variance is present
      Shift_Data[protein, "shapiro_p"] <- NA
      Shift_Data[protein, "normal_distributed"] <- TRUE
      
    } else {
      
      # perform Shapiro-Wilk test to check for normal distribution
      shapiro_result <- shapiro.test(shift_values)
      Shift_Data[protein, "shapiro_p"] <- shapiro_result$p.value
      Shift_Data[protein, "normal_distributed"] <- shapiro_result$p.value >= 0.05
    }
    
    # perfrom one-sided t-test if data is normal distributed
    if (Shift_Data[protein, "normal_distributed"] == TRUE) {
      
      test_result <- t.test(shift_values, mu = 0, alternative = "less")
      
      Shift_Data[protein, "p_value_ttest_filtered"] <- test_result$p.value
      Shift_Data[protein, "significant_ttest_filtered"] <- ifelse(test_result$p.value < 0.05, TRUE, FALSE)
      
    } else {
      # no t-test applied if data is not normal distributed
      Shift_Data[protein, "p_value_ttest_filtered"] <- NA
      Shift_Data[protein, "significant_ttest_filtered"] <- NA
    }
  }
}


head(Shift_Data)

# summary of proteins regarding normal distribution
table(Shift_Data$normal_distributed, useNA = "ifany")

# summary of proteins regarding significant of t-test
table(Shift_Data$significant_ttest_filtered, useNA = "ifany")



```










# TRY AND ERROR (BackUP)
##looking at standart deviation and mean to get an idea 

```{r}


# create empty vectors to store the values

sd_values <- numeric(25)
mean_values <- numeric(25)

# create loop for all 25 fractions 
for (i in 1:25) {
  # Define replicate labels ( RNAse or Ctrl)
  reps <- paste0("RNAse_Rep", 1:3)
  
  # Filter just the current fraction and replicates
  subset_data <- data[data$fraction == paste0("Fraction_", i) & data$replicate %in% reps, ]
  
  # Extract abundance values
  values <- subset_data$abundance
  
  # Compute standard deviation + compute mean
  sd_values[i] <- sd(values)
  
  mean_values[i] <- mean(values)
}

# Create result table 
result_tablesd <- data.frame(
  Fraction = paste0("Fraction_", 1:25),
  SD = sd_values
)
result_tablesd

result_tablemean <- data.frame(
  Fraction = paste0("Fraction_", 1:25),
  MEAN = mean_values
)
result_tablemean

```

##trzing to run Pearson correlation for all proteins => for now between Repetitions Rep1 and Rep2 across 25 fractions for Ctrl and RNase seperatly 

#1) frist creating a long format table with=> Protein names repeat themselfs for all combinations maybe this is the problem 


```{r}
# Load necessary packages
library(dplyr)
library(tidyr)

#naming coloum for Protein names with Protein so i can run my code => this is ugly open for suggestions

MS_Table$Protein <- rownames(MS_Table)
MS_Table2 <- MS_Table %>% relocate(Protein)
head(MS_Table2)

# Step 2: Pivot longer — convert the wide columns into long format
# The first column is protein names, so we keep it as id

ms_long <- MS_Table %>%
  pivot_longer(
    cols = -Protein,  # all columns except the first (protein names)
    names_to = "Condition",  # temporary column to store original column names
    values_to = "Value"      # this column will store the measured values
  )

# Step 3: Separate 'Condition' into Fraction, Treatment, and Replicate
ms_long <- ms_long %>%
  separate(
    col = Condition,
    into = c("Fraction", "Treatment", "Replicate"),
    sep = "_"
  )

# Step 4: Extract the numeric fraction number (since it's like 'Fraction1')
ms_long <- ms_long %>%
  mutate(
    Fraction = as.numeric(sub("Fraction", "", Fraction))
  )

# Step 5: Rename first column to "Protein" (if it's not already)
names(ms_long)[1] <- "Protein"

# Optional: Check result
head(ms_long)
rownames(ms_long)


# Now you have your tidy table:
# Protein | Fraction | Treatment | Replicate | Value



```


#2) with table trying to run pearson correlation 

```{r}

library(dplyr)
library(tidyr)

# First: keep only the replicates we want
filtered <- ms_long %>%
  filter(Replicate %in% c("Rep1", "Rep2"),
         Treatment %in% c("Ctrl", "RNAse"),
         Fraction %in% paste0("Fraction_", 1:25))

# Then: calculate correlation per protein + treatment
results <- filtered %>%
  group_by(Protein, Treatment) %>%
  pivot_wider(
    names_from = Replicate,
    values_from = Value,
    values_fill = list(abundance = 0)   # fill missing values with 0
  ) %>%
  summarise(correlation = cor(Rep1, Rep2), .groups = "drop")  # here something dosent work=> Rep2 is not recognized 

# Print results
print(results)

ms_long %>%
  count(Protein, Treatment)



```

