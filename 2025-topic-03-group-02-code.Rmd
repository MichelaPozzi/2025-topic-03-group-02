---
title: "2025-topic-03-group-02-code"
output: html_document
date: "2025-05-16"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

##Loading MS-Data
```{r}
MS_Table <- read.table("RDeeP_HeLa_Mitosis.csv", header = TRUE, row.names = 1, sep = ";")
```

# Data Cleanup
## Despription of the Data
```{r}
n_rows = nrow(MS_Table) 
n_rows # Number of Proteins
n_cols = ncol(MS_Table) 
n_cols # Number of varibale
unique(sapply(MS_Table, class)) # classification of variables
any(is.na(MS_Table)) # missing values
min(MS_Table) # minimum intensity
max(MS_Table) # maximum intensity


```

## Restructuration of the data
Create a dataframe with factors that make it possible to access specific data from MS_Table
```{r}
treatment <- factor(rep(c("Ctrl", "RNAse"), each = 3, length.out = 150))
replicate <- factor(rep(c("Ctrl_Rep1", "Ctrl_Rep2", "Ctrl_Rep3", "RNAse_Rep1","RNAse_Rep2", "RNAse_Rep3"),25))
fraction <- factor(rep(paste0("Fraction_", 1:25), each = 6))

data <- data.frame(rownames = colnames(MS_Table),treatment = treatment, replicate = replicate, fraction = fraction)
data
```
## Normalization of triplicates 
Create a new dataframe with average values of the replicates 
```{r}
average.list <- list() #create list

# for loop, going through all fractions: 
# selecting Ctrl columns for specific fraction
# computing average of these columns 
# adding a new vector to list e.g."Ctrl_Fraction_1" and assigning average values 

for (f in levels(fraction)) {
  
  cols.Ctrl <- which(fraction == f & treatment == "Ctrl") 
  average.Ctrl <- rowMeans(MS_Table[,cols.Ctrl]) 
  average.list[[paste0("Ctrl_",f)]] <- average.Ctrl # paste0 funktion checken
  
  cols.RNAse <- which(fraction == f & treatment == "RNAse")
  average.RNAse <- rowMeans(MS_Table[,cols.RNAse])
  average.list[[paste0("RNAse_",f)]] <- average.RNAse
}

MS_Table_Averages <- as.data.frame(average.list) #convert list to dataframe
rownames(MS_Table_Averages) <- rownames(MS_Table) #assign Protein IDs to average values

#Define new order of columns ("levels" works in alphabetic order, not useful for us)
fractions <- paste0("Fraction_", 1:25)

ordered_names <- as.vector(rbind(
  paste0("Ctrl_", fractions),
  paste0("RNAse_", fractions)
))

MS_Table_Averages <- MS_Table_Averages[, ordered_names]
head(MS_Table_Averages)
```
## Normalization to 100 
Create a new dataframe in which the values for each protein are scaled so that the distribution within the Ctrl and RNAse conditions each sums to 100
```{r}
# Split up Control and RNAse values 
ctrl_cols <- grep("^Ctrl_", colnames(MS_Table_Averages)) # grep function genauer schauen 
rnase_cols <- grep("^RNAse_", colnames(MS_Table_Averages))
# Normalization of each group to 100 
ctrl_norm <- MS_Table_Averages[, ctrl_cols] / rowSums(MS_Table_Averages[, ctrl_cols]) * 100
rnase_norm <- MS_Table_Averages[, rnase_cols] / rowSums(MS_Table_Averages[, rnase_cols]) * 100
# Combine in one table 
MS_Table_Norm <- cbind(ctrl_norm, rnase_norm)
MS_Table_Norm <- MS_Table_Norm[, colnames(MS_Table_Averages)]
head(round(MS_Table_Norm, 2))
# Verify the calculation with one example; the row sum should be ~200 (Ctrl 100% + RNAse 100%)
rowSums(MS_Table_Norm["1433B_HUMAN", ]) 
```


## Normalization of whole MS_Table to 100  
```{r}
# Split up all Ctrl and RNAse values and their individual Reps 
ctrl_cols_t1 <- grep("_Ctrl_Rep1", colnames(MS_Table))
ctrl_cols_t2 <- grep("_Ctrl_Rep2", colnames(MS_Table))
ctrl_cols_t3 <- grep("_Ctrl_Rep3", colnames(MS_Table))
RNAse_cols_t1 <- grep("_RNase_Rep1", colnames(MS_Table))
RNAse_cols_t2 <- grep("_RNase_Rep2", colnames(MS_Table))
RNAse_cols_t3 <- grep("_RNase_Rep3", colnames(MS_Table))

# Normalization of each group to 100 
ctrl_norm_t1 <- MS_Table[, ctrl_cols_t1] / rowSums(MS_Table[, ctrl_cols_t1]) * 100
ctrl_norm_t2 <- MS_Table[, ctrl_cols_t2] / rowSums(MS_Table[, ctrl_cols_t2]) * 100
ctrl_norm_t3 <- MS_Table[, ctrl_cols_t3] / rowSums(MS_Table[, ctrl_cols_t3]) * 100
RNAse_norm_t1 <- MS_Table[, RNAse_cols_t1] / rowSums(MS_Table[, RNAse_cols_t1]) * 100
RNAse_norm_t2 <- MS_Table[, RNAse_cols_t2] / rowSums(MS_Table[, RNAse_cols_t2]) * 100
RNAse_norm_t3 <- MS_Table[, RNAse_cols_t3] / rowSums(MS_Table[, RNAse_cols_t3]) * 100

# Combine in one table 
MS_Table_Norm_for_t <- cbind(ctrl_norm_t1, RNAse_norm_t1, ctrl_norm_t2, RNAse_norm_t2, ctrl_norm_t3, RNAse_norm_t3)

# In gewünschter Reihenfolge ordnen
fractions <- 1:25
reps <- 1:3
conditions <- c("Ctrl", "RNase") 


ordered_names <- c()

for (fraction in fractions) {
  for (rep in reps) {
    for (condition in conditions) {
      name <- paste0("Fraction", fraction, "_", condition, "_Rep", rep)
      ordered_names <- c(ordered_names, name)
    }
  }
}

MS_Table_Norm_for_t <- MS_Table_Norm_for_t[, ordered_names]
head(MS_Table_Norm_for_t)
# Verify the calculation with one example; the row sum should be ~600 (3*Ctrl 100% + 3*RNAse 100%)
rowSums(MS_Table_Norm_for_t["1433B_HUMAN", ]) 
```


## Plotting a protein with normalised data (Notfitted)
```{r}
# Protein auswählen
protein_of_interest <- "ABCF1_HUMAN" # hier dein Protein einsetzen

# Zeile für das Protein extrahieren
protein_row <- MS_Table_Norm[rownames(MS_Table_Norm) == protein_of_interest, ]

# Vektoren für Ctrl und RNAse erstellen
ctrl_values <- as.numeric(protein_row[seq(1, 49, by=2)])
rnase_values <- as.numeric(protein_row[seq(2, 50, by=2)])

# Fraktionen
fractions <- 1:25

# Plot
plot(fractions, ctrl_values, type="o", pch=16, lty=1, col="green", ylim=range(c(ctrl_values, rnase_values)),
     xlab="Fraction", ylab="Normalized Intensity", main=protein_of_interest)
lines(fractions, rnase_values, type="o",pch =16, lty=1, col="red")
legend("topright", legend=c("Ctrl", "RNAse"), col=c("green", "red"), lty=1, pch=16)
```

## Testung auf Normalverteilung 
--> work in progress, nicht sicher ob wir das direkt schon brauchen 
--> hab nur bisschen rumprobiert ---> Bin mir wirklich nicht sicher ob das so stimmt, muss ich nochmal anschauen, aber bin zu müde, möchte es aber hier schon mal speichern 
--> Note: QQ Plots für Normalverteilung 
```{r}
# Pakete laden 
library(dplyr)

# Leere Liste für Zwischenspeicherung 
results_list <- list()
counter <- 1

# Proteine durchlaufen
for (protein in rownames(MS_Table)) {
  
  for (fraction_num in 1:25) {
    
    # Die korrekten Spaltennamen für Ctrl generieren
    cols_ctrl <- paste0("Fraction", fraction_num, "_Ctrl_Rep", 1:3)
    
    # Prüfen ob alle Spalten existieren 
    existing_cols <- cols_ctrl[cols_ctrl %in% colnames(MS_Table)]
    
    if(length(existing_cols) == 3){
      
      # Werte extrahieren
      protein_values <- as.numeric(MS_Table[protein, existing_cols])
      
      # Nur testen, wenn es Streuung gibt
      if (length(unique(protein_values)) > 1) {
        shapiro_result <- shapiro.test(protein_values)
        shapiro_W <- shapiro_result$statistic
        shapiro_p <- shapiro_result$p.value
      } else {
        shapiro_W <- NA
        shapiro_p <- NA
      }
      
      # Zwischenspeichern
      results_list[[counter]] <- data.frame(
        Protein_ID = protein,
        Fraction = fraction_num,
        Shapiro_W = shapiro_W,
        Shapiro_p = shapiro_p
      )
      counter <- counter + 1
    }
  }
}

# Am Ende alles zusammenfügen
shapiro_results <- do.call(rbind, results_list)

# Entscheidung über Normalverteilung ergänzen
shapiro_results$Is_Normal_Distributed <- shapiro_results$Shapiro_p >= 0.05

# Ergebnisse ausgeben
head(shapiro_results)

# Übersicht wie viele normalverteilt
table(shapiro_results$Is_Normal_Distributed)



```

## Reproducibility Analysis
```{r}
# Leere Liste für Ergebnisse
full_correlation_results <- data.frame(
  Treatment = character(),
  Replicate_1 = character(),
  Fraction_1 = character(),
  Replicate_2 = character(),
  Fraction_2 = character(),
  Spearman_r = numeric(),
  stringsAsFactors = FALSE
)

# Alle Treatments durchgehen (Ctrl und RNAse)
for (treatment in c("Ctrl", "RNAse")) {
  
  # Alle Replikat-Fraktions-Kombinationen erzeugen
  combo1 <- expand.grid(Rep = 1:3, Fraction = 1:25)
  combo2 <- expand.grid(Rep = 1:3, Fraction = 1:25)
  
  # Für jede mögliche Kombination
  for (i in 1:nrow(combo1)) {
    for (j in 1:nrow(combo2)) {
      
      rep1 <- combo1$Rep[i]
      frac1 <- combo1$Fraction[i]
      rep2 <- combo2$Rep[j]
      frac2 <- combo2$Fraction[j]
      
      # Spaltenpositionen finden
      col1 <- which(replicate == paste0(treatment, "_Rep", rep1) & fraction == paste0("Fraction_", frac1))
      col2 <- which(replicate == paste0(treatment, "_Rep", rep2) & fraction == paste0("Fraction_", frac2))
      
      # Pearson Korrelation berechnen
      cor_value <- cor(MS_Table[, col1], MS_Table[, col2], method = "spearman", use = "complete.obs")
      
      # Ergebnis speichern
      full_correlation_results <- rbind(full_correlation_results, data.frame(
        Treatment = treatment,
        Replicate_1 = paste0("Rep", rep1),
        Fraction_1 = paste0("Fraction_", frac1),
        Replicate_2 = paste0("Rep", rep2),
        Fraction_2 = paste0("Fraction_", frac2),
        Spearman_r = cor_value
      ))
    }
  }
}

# Ergebnis anschauen
head(full_correlation_results)


library(tidyverse)
library(pheatmap)

# Erstmal eine Spalte erzeugen für die beiden Achsen
full_correlation_results <- full_correlation_results %>%
   mutate(Row = paste0(Replicate_1, "_F", gsub("Fraction_", "", Fraction_1)),
         Col = paste0(Replicate_2, "_F", gsub("Fraction_", "", Fraction_2)))

# Wir machen das einmal für ein Treatment, z.B. "RNAse"
treatment_to_plot <- "RNAse"

# Tabelle filtern
heatmap_data <- full_correlation_results %>%
  filter(Treatment == treatment_to_plot) %>%
  select(Row, Col, Spearman_r)

# In Matrix umwandeln
heatmap_matrix <- heatmap_data %>%
  pivot_wider(names_from = Col, values_from = Spearman_r, values_fill = NA) %>%
  column_to_rownames("Row") %>%
  as.matrix()

# Jetzt Heatmap zeichnen
pheatmap(heatmap_matrix,
         main = paste("Spearman Correlation Heatmap -", treatment_to_plot),
         cluster_rows = FALSE, 
         cluster_cols = FALSE, 
         show_rownames = TRUE, 
         show_colnames = TRUE,
         fontsize_row = 4,
         fontsize_col = 4)

```

# Data Analysis
## Peak Characteristics

```{r}
t = max(y) * 0.03 
find_peaks <- function(y, threshold = t) { 
  peaks <- which(diff(sign(diff(y))) == -2) + 1 #(+1 shifts index back)
  peaks[y[peaks]>= threshold] # [peaks] = peak intensität <- only those over thresohold
}

peak_results <- list()


for (p in seq_len(nrow(MS_Table_Norm))) {
  row_vals <- as.numeric(MS_Table_Norm [p,])
  ctrl_vals <- row_vals[seq(1, 50, by =2)]
  rnase_vals <- row_vals[seq(2, 50, by=2)]
  
  results_row <- list()
  
  for (cond in c("Ctrl", "RNAse")) {
    y <- if (cond == "Ctrl") ctrl_vals else rnase_vals 
    
    peaks <- find_peaks(y)
    if(length(peaks) == 0) {
      peaks <- which.max(y)
    }
    
    n_peaks <- min(length(peaks), 6)
    
    y_peaks <- y[peaks]
    x_peaks <- x[peaks]

    results_row[[paste0("n_peaks_", cond)]] <- n_peaks
    for(n in seq_len(n_peaks)) {
    results_row[[paste0("peak", n, "_height_", cond)]] <- y_peaks[n]
    results_row[[paste0("peak", n, "_position_", cond)]] <- x_peaks[n]
    }
  }
  
  peak_results[[p]] <- results_row
}


rows_df <- lapply(peak_results, function(x){
  columns <- c("peak1_height", "peak1_position", "peak2_height", "peak2_position", "peak3_height", "peak3_position", "peak4_height", "peak4_position", "peak5_height", "peak5_position", "peak6_height", "peak6_position")
  for (cond in c("Ctrl", "RNAse")) {
    for (c in columns) {
      key <- paste0(c, "_", cond)
      if(!(key %in% names(x))) {
        x[[key]] <- NA
      }
    }
  }
  as.data.frame(x)
})

Peak_Data <- do.call(rbind, rows_df)
rownames(Peak_Data) <- rownames(MS_Table_Norm)

#reorder columns
order <- c("n_peaks_Ctrl", "n_peaks_RNAse")

for (i in 1:6) {
  order <- c(order, 
                 paste0("peak", i, "_height_Ctrl"),
                 paste0("peak", i, "_position_Ctrl"),
                 paste0("peak", i, "_height_RNAse"),
                 paste0("peak", i, "_position_RNAse"))
}

# Reordne den DataFrame
Peak_Data <- Peak_Data[, order]
head(Peak_Data)
```


--> Idee zur Lösung: CoM verwenden (Center of Mass über alle Fraktionen, hat laut ChatGPT auch Maiwen verwendet und sei methodisch korrekt) --> als Test sollen wir Wilcoxson Rank-Sum-Test verwenden? aber hab ich noch nicht drüber navhgedacht


# Center of mass function (CoM) trough all replicates and conditions for all proteins :)
```{r}
# aufstellen von variablen 

fractions <- 1:25
conditions <- c("Ctrl", "RNase")
replicates <- c("Rep1", "Rep2", "Rep3")

#liste erstellen 

results_com <- list()

#looping through conditions and replicates as we want them all seperate

for (cond in conditions) {
  for (rep in replicates) {
    
#selecting colums with grep diesen strich verssteh ich nicht "chat sagt "makes one combined pattern with ORs (|) between them, so grep matches any of them."

    pattern <- paste0("^Fraction", fractions, "_", cond, "_", rep, "$")
    cols <- grep(paste(pattern, collapse="|"), colnames(MS_Table_Norm_for_t), value = TRUE)  

    subdata <- MS_Table_Norm_for_t[, cols]   
#storing coloums 

    subdata <- subdata[, order(as.numeric(gsub("Fraction(\\d+)_.*", "\\1", cols)))]  #extracts the fraction number from column names.

#center of mass calculation

    com <- apply(subdata, 1, function(x) {
      sum(x * fractions) / sum(x)
    })
#store result in list 

    results_com[[paste(cond, rep, sep = "_")]] <- com
  }
}

#convert list to dataframe

# After the loops have finished:
com_MS_Table_Norm_for_t <- as.data.frame(results_ttest)   # convert list into data frame

# Add correct rownames:
rownames(com_MS_Table_Norm_for_t) <- rownames(MS_Table_Norm_for_t)

# View the first few rows to check
head(com_MS_Table_Norm_for_t)
```



```{r}
# Berechnung CoM erstmal beispielhaft über Normalisierte Daten
# Shift nach Links ist RBP, d.h. Shift_Distance > 1

x <- seq(1:25)

CoM_Ctrl <- numeric(nrow(MS_Table_Norm))
CoM_RNAse <- numeric(nrow(MS_Table_Norm))
Shift_distance <- numeric(nrow(MS_Table_Norm))
Shift_direction <- numeric(nrow(MS_Table_Norm))


for (p in seq_len(nrow(MS_Table_Norm))) {
  row_vals <- as.numeric(MS_Table_Norm [p,])
  ctrl_vals <- row_vals[seq(1, 50, by =2)]
  rnase_vals <- row_vals[seq(2, 50, by=2)]
  
  CoM_Ctrl[p] <- sum(ctrl_vals * x) / sum(ctrl_vals)
  CoM_RNAse[p] <- sum(rnase_vals * x) / sum(rnase_vals)
  Shift_distance[p] <- CoM_Ctrl[p] - CoM_RNAse[p] 
  Shift_direction[p] <- sign(Shift_distance[p]) # -1 would be right shift, 1 would be left shift
}

 Shift_Data_2 <- data.frame(
  CoM_Ctrl = CoM_Ctrl,
  CoM_RNAse = CoM_RNAse,
  Shift_distance = Shift_distance,
  Shift_direction = Shift_direction,
  row.names = rownames(MS_Table_Norm))

head(Shift_Data_2)
sum(Shift_Data_2$Shift_distance > 1, na.rm = TRUE)
```


# Try and error (BackUP)
##looking at standart deviation and mean to get an idea 

```{r}


# create empty vectors to store the values

sd_values <- numeric(25)
mean_values <- numeric(25)

# create loop for all 25 fractions 
for (i in 1:25) {
  # Define replicate labels ( RNAse or Ctrl)
  reps <- paste0("RNAse_Rep", 1:3)
  
  # Filter just the current fraction and replicates
  subset_data <- data[data$fraction == paste0("Fraction_", i) & data$replicate %in% reps, ]
  
  # Extract abundance values
  values <- subset_data$abundance
  
  # Compute standard deviation + compute mean
  sd_values[i] <- sd(values)
  
  mean_values[i] <- mean(values)
}

# Create result table 
result_tablesd <- data.frame(
  Fraction = paste0("Fraction_", 1:25),
  SD = sd_values
)
result_tablesd

result_tablemean <- data.frame(
  Fraction = paste0("Fraction_", 1:25),
  MEAN = mean_values
)
result_tablemean

```

##trzing to run Pearson correlation for all proteins => for now between Repetitions Rep1 and Rep2 across 25 fractions for Ctrl and RNase seperatly 

#1) frist creating a long format table with=> Protein names repeat themselfs for all combinations maybe this is the problem 


```{r}
# Load necessary packages
library(dplyr)
library(tidyr)

#naming coloum for Protein names with Protein so i can run my code => this is ugly open for suggestions

MS_Table$Protein <- rownames(MS_Table)
MS_Table2 <- MS_Table %>% relocate(Protein)
head(MS_Table2)

# Step 2: Pivot longer — convert the wide columns into long format
# The first column is protein names, so we keep it as id

ms_long <- MS_Table %>%
  pivot_longer(
    cols = -Protein,  # all columns except the first (protein names)
    names_to = "Condition",  # temporary column to store original column names
    values_to = "Value"      # this column will store the measured values
  )

# Step 3: Separate 'Condition' into Fraction, Treatment, and Replicate
ms_long <- ms_long %>%
  separate(
    col = Condition,
    into = c("Fraction", "Treatment", "Replicate"),
    sep = "_"
  )

# Step 4: Extract the numeric fraction number (since it's like 'Fraction1')
ms_long <- ms_long %>%
  mutate(
    Fraction = as.numeric(sub("Fraction", "", Fraction))
  )

# Step 5: Rename first column to "Protein" (if it's not already)
names(ms_long)[1] <- "Protein"

# Optional: Check result
head(ms_long)
rownames(ms_long)


# Now you have your tidy table:
# Protein | Fraction | Treatment | Replicate | Value



```


#2) with table trying to run pearson correlation 

```{r}

library(dplyr)
library(tidyr)

# First: keep only the replicates we want
filtered <- ms_long %>%
  filter(Replicate %in% c("Rep1", "Rep2"),
         Treatment %in% c("Ctrl", "RNAse"),
         Fraction %in% paste0("Fraction_", 1:25))

# Then: calculate correlation per protein + treatment
results <- filtered %>%
  group_by(Protein, Treatment) %>%
  pivot_wider(
    names_from = Replicate,
    values_from = Value,
    values_fill = list(abundance = 0)   # fill missing values with 0
  ) %>%
  summarise(correlation = cor(Rep1, Rep2), .groups = "drop")  # here something dosent work=> Rep2 is not recognized 

# Print results
print(results)

ms_long %>%
  count(Protein, Treatment)



```

